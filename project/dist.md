# dist

## dist/analyzeConversations.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/analyzeConversations.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
// Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
// This software is licensed under the MIT License.
// Path: src/analyzeConversations.ts
// This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
// Script to analyze conversation data from a JSON file
// "I count characters so you don't have to!"
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var ConversationAnalyzer_1 = require("./ConversationAnalyzer");
var fs = require("fs/promises");
function analyzeFile(filePath, options) {
    return __awaiter(this, void 0, void 0, function () {
        var data, analyzer, result, byteLength, results, sortedConversations, idLength, bytesLength_1, padSpaces_1, totalConversations_1, grandTotal_1, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, fs.readFile(filePath, "utf8")];
                case 1:
                    data = _a.sent();
                    analyzer = new ConversationAnalyzer_1.ConversationAnalyzer(JSON.parse(data));
                    // If message ID is provided, show detailed message info
                    if (options.messageId) {
                        result = analyzer.findMessageById(options.messageId);
                        if (!result) {
                            console.error("Message with ID ".concat(options.messageId, " not found"));
                            process.exit(1);
                        }
                        byteLength = new TextEncoder().encode(result.message.content).length;
                        console.log("\nMessage Details:");
                        console.log("-----------------");
                        console.log("Conversation: ".concat(result.conversation.name, " (").concat(result.conversation.id, ")"));
                        console.log("Message ID: ".concat(result.message.id));
                        console.log("Sender: ".concat(result.message.sender));
                        console.log("Character Length: ".concat(result.message.content.length, " characters"));
                        console.log("Byte Length: ".concat(byteLength, " bytes"));
                        console.log("\nContent:");
                        console.log("-----------------");
                        console.log(result.message.content);
                        return [2 /*return*/];
                    }
                    results = analyzer.analyze();
                    // Print results in a formatted way
                    console.log("Conversation Analysis Results\n");
                    sortedConversations = results.conversationMetrics.sort(function (a, b) { return b.totalSize - a.totalSize; });
                    idLength = 36;
                    bytesLength_1 = 12;
                    padSpaces_1 = function (length) { return " ".repeat(length); };
                    totalConversations_1 = 0;
                    grandTotal_1 = 0;
                    sortedConversations.forEach(function (conv) {
                        // Filter messages if minBytes is specified
                        var filteredMessages = options.minBytes
                            ? conv.messageLengths.filter(function (msg) { return msg.byteLength >= options.minBytes; })
                            : conv.messageLengths;
                        // Skip conversation if all messages were filtered out
                        if (filteredMessages.length === 0)
                            return;
                        totalConversations_1++;
                        grandTotal_1 += conv.totalSize;
                        // Sort messages by byte length in descending order
                        var sortedMessages = filteredMessages.sort(function (a, b) { return b.byteLength - a.byteLength; });
                        // Print conversation line
                        console.log("".concat(conv.conversationId, " - ").concat(conv.totalSize
                            .toLocaleString()
                            .padStart(bytesLength_1), " - ").concat(conv.conversationName));
                        // Print each message that passed the filter
                        sortedMessages.forEach(function (msg) {
                            var _a;
                            var message = (_a = conv.conversations
                                .find(function (c) { return c.messages.find(function (m) { return m.id === msg.messageId; }); })) === null || _a === void 0 ? void 0 : _a.messages.find(function (m) { return m.id === msg.messageId; });
                            if (message) {
                                var truncatedContent = message.content.length > 80
                                    ? message.content.substring(0, 77) + "..."
                                    : message.content;
                                var contentLine = truncatedContent
                                    .replace(/\\n/g, " ")
                                    .replace(/\\s+/g, " ");
                                console.log("".concat(padSpaces_1(2)).concat(msg.messageId, " - ").concat(msg.byteLength
                                    .toLocaleString()
                                    .padStart(bytesLength_1), " - ").concat(contentLine));
                            }
                        });
                        console.log(""); // Empty line between conversations
                    });
                    // Print grand total
                    console.log("Total: ".concat(totalConversations_1, " conversation").concat(totalConversations_1 === 1 ? "" : "s", ", ").concat(grandTotal_1.toLocaleString(), " bytes"));
                    return [3 /*break*/, 3];
                case 2:
                    error_1 = _a.sent();
                    console.error("Error analyzing file:", error_1);
                    process.exit(1);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
}
// Parse command line arguments
var args = process.argv.slice(2);
var filePath;
var options = {};
// Parse arguments
for (var i = 0; i < args.length; i++) {
    if (args[i] === "--message" || args[i] === "-m") {
        options.messageId = args[i + 1];
        i++; // Skip next argument since we used it
    }
    else if (args[i] === "--min") {
        var minBytes = parseInt(args[i + 1], 10);
        if (isNaN(minBytes)) {
            console.error("Error: --min value must be a number");
            process.exit(1);
        }
        options.minBytes = minBytes;
        i++; // Skip next argument since we used it
    }
    else {
        filePath = args[i];
    }
}
if (!filePath) {
    console.error("Usage: node analyzeConversations.js <file_path> [--message|-m message_id] [--min minimum_bytes]");
    process.exit(1);
}
analyzeFile(filePath, options);

```

## dist/background.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/background.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

(() => { // webpackBootstrap
/*!***************************!*\
  !*** ./src/background.js ***!
  \***************************/
// src/background.js
const API_URL = "https://api.anthropic.com/v1/messages";

// Debug logging helper
function debugLog(message, data) {
  console.log(`[Background] ${message}`, data || "");
}

// Common headers for all Anthropic API requests
function getAnthropicHeaders(apiKey) {
  return {
    "Content-Type": "application/json",
    "x-api-key": apiKey,
    "anthropic-version": "2023-06-01",
    "anthropic-dangerous-direct-browser-access": "true",
  };
}

chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  debugLog("Received message:", request);

  if (request.type === "download") {
    chrome.downloads.download(
      {
        url: request.url,
        filename: request.filename,
        saveAs: true,
      },
      (downloadId) => {
        if (chrome.runtime.lastError) {
          const response = {
            success: false,
            error: chrome.runtime.lastError.message,
          };
          debugLog("Download failed:", response);
          sendResponse(response);
        } else {
          const response = { success: true, downloadId };
          debugLog("Download succeeded:", response);
          sendResponse(response);
        }
      }
    );
    return true; // Keep the message channel open for async response
  }

  if (request.type === "anthropic_test") {
    debugLog("Testing Anthropic API key");

    // Get settings to use the configured model for testing
    chrome.storage.sync.get("anthropic_api_settings", (result) => {
      const settings = result.anthropic_api_settings || {};
      const model = settings.model || "claude-3-5-sonnet-20241022";

      // Make a minimal request to test the API key
      fetch(API_URL, {
        method: "POST",
        headers: getAnthropicHeaders(request.apiKey),
        body: JSON.stringify({
          model: model,
          messages: [{ role: "user", content: "Hi" }],
          max_tokens: 1,
        }),
      })
        .then(async (response) => {
          if (!response.ok) {
            const text = await response.text();
            let errorMessage;
            try {
              const errorJson = JSON.parse(text);
              errorMessage =
                errorJson.error?.message ||
                `API request failed with status ${response.status}`;
            } catch {
              errorMessage = `API request failed with status ${response.status}`;
            }
            debugLog("Anthropic API test error response:", {
              status: response.status,
              text: text,
              errorMessage,
            });

            // For 401, likely an invalid API key
            if (response.status === 401) {
              return sendResponse({
                error:
                  "Invalid API key. Please check your API key in the extension settings.",
              });
            }

            return sendResponse({
              error: errorMessage,
            });
          }
          return response.json();
        })
        .then((data) => {
          if (data && !data.error) {
            debugLog("Anthropic API test succeeded:", data);
            sendResponse({
              model: data.model,
              success: true,
            });
          }
        })
        .catch((error) => {
          debugLog("Anthropic API test error:", error);
          sendResponse({
            error: "Failed to test API key. Please try again.",
          });
        });
    });

    return true; // Keep the message channel open for async response
  }

  if (request.type === "anthropic_complete") {
    debugLog("Making Anthropic API request:", request.body);

    fetch(API_URL, {
      method: "POST",
      headers: getAnthropicHeaders(request.apiKey),
      body: JSON.stringify(request.body),
    })
      .then(async (response) => {
        if (!response.ok) {
          const text = await response.text();
          let errorMessage;
          try {
            const errorJson = JSON.parse(text);
            errorMessage =
              errorJson.error?.message ||
              `API request failed with status ${response.status}`;
          } catch {
            errorMessage = `API request failed with status ${response.status}`;
          }
          debugLog("Anthropic API error response:", {
            status: response.status,
            text: text,
            errorMessage,
          });

          // For 401, likely an invalid API key
          if (response.status === 401) {
            return sendResponse({
              error:
                "Invalid API key. Please check your API key in the extension settings.",
            });
          }

          return sendResponse({
            error: errorMessage,
          });
        }
        return response.json();
      })
      .then((data) => {
        if (data && !data.error) {
          debugLog("Anthropic API success response:", data);
          sendResponse(data);
        }
      })
      .catch((error) => {
        debugLog("Anthropic API error:", error);
        sendResponse({
          error: "Failed to complete the request. Please try again.",
        });
      });

    return true; // Keep the message channel open for async response
  }
});

chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {
  if (changeInfo.status === "complete") {
    chrome.storage.sync.get("urlPatterns", (data) => {
      const urlPatterns = data.urlPatterns || [];
      const urlMatches = urlPatterns.some((pattern) =>
        tab.url.includes(pattern)
      );

      if (urlMatches) {
        debugLog("Injecting content script for tab:", tabId);
        chrome.scripting.executeScript({
          target: { tabId: tabId },
          files: ["content.js"],
        });
      }
    });
  }
});

// Log when the background script is loaded
debugLog("Background script loaded");

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2dyb3VuZC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkJBQTZCO0FBQ3BEO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdCQUFnQjtBQUNsRSxjQUFjO0FBQ2QsK0RBQStELGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULEtBQUs7O0FBRUwsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEUsWUFBWTtBQUNaLDZEQUE2RCxnQkFBZ0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQLGlCQUFpQjtBQUNqQjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL2JhY2tncm91bmQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2JhY2tncm91bmQuanNcbmNvbnN0IEFQSV9VUkwgPSBcImh0dHBzOi8vYXBpLmFudGhyb3BpYy5jb20vdjEvbWVzc2FnZXNcIjtcblxuLy8gRGVidWcgbG9nZ2luZyBoZWxwZXJcbmZ1bmN0aW9uIGRlYnVnTG9nKG1lc3NhZ2UsIGRhdGEpIHtcbiAgY29uc29sZS5sb2coYFtCYWNrZ3JvdW5kXSAke21lc3NhZ2V9YCwgZGF0YSB8fCBcIlwiKTtcbn1cblxuLy8gQ29tbW9uIGhlYWRlcnMgZm9yIGFsbCBBbnRocm9waWMgQVBJIHJlcXVlc3RzXG5mdW5jdGlvbiBnZXRBbnRocm9waWNIZWFkZXJzKGFwaUtleSkge1xuICByZXR1cm4ge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIFwieC1hcGkta2V5XCI6IGFwaUtleSxcbiAgICBcImFudGhyb3BpYy12ZXJzaW9uXCI6IFwiMjAyMy0wNi0wMVwiLFxuICAgIFwiYW50aHJvcGljLWRhbmdlcm91cy1kaXJlY3QtYnJvd3Nlci1hY2Nlc3NcIjogXCJ0cnVlXCIsXG4gIH07XG59XG5cbmNocm9tZS5ydW50aW1lLm9uTWVzc2FnZS5hZGRMaXN0ZW5lcigocmVxdWVzdCwgc2VuZGVyLCBzZW5kUmVzcG9uc2UpID0+IHtcbiAgZGVidWdMb2coXCJSZWNlaXZlZCBtZXNzYWdlOlwiLCByZXF1ZXN0KTtcblxuICBpZiAocmVxdWVzdC50eXBlID09PSBcImRvd25sb2FkXCIpIHtcbiAgICBjaHJvbWUuZG93bmxvYWRzLmRvd25sb2FkKFxuICAgICAge1xuICAgICAgICB1cmw6IHJlcXVlc3QudXJsLFxuICAgICAgICBmaWxlbmFtZTogcmVxdWVzdC5maWxlbmFtZSxcbiAgICAgICAgc2F2ZUFzOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIChkb3dubG9hZElkKSA9PiB7XG4gICAgICAgIGlmIChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IpIHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGNocm9tZS5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlLFxuICAgICAgICAgIH07XG4gICAgICAgICAgZGVidWdMb2coXCJEb3dubG9hZCBmYWlsZWQ6XCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICBzZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geyBzdWNjZXNzOiB0cnVlLCBkb3dubG9hZElkIH07XG4gICAgICAgICAgZGVidWdMb2coXCJEb3dubG9hZCBzdWNjZWVkZWQ6XCIsIHJlc3BvbnNlKTtcbiAgICAgICAgICBzZW5kUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gdHJ1ZTsgLy8gS2VlcCB0aGUgbWVzc2FnZSBjaGFubmVsIG9wZW4gZm9yIGFzeW5jIHJlc3BvbnNlXG4gIH1cblxuICBpZiAocmVxdWVzdC50eXBlID09PSBcImFudGhyb3BpY190ZXN0XCIpIHtcbiAgICBkZWJ1Z0xvZyhcIlRlc3RpbmcgQW50aHJvcGljIEFQSSBrZXlcIik7XG5cbiAgICAvLyBHZXQgc2V0dGluZ3MgdG8gdXNlIHRoZSBjb25maWd1cmVkIG1vZGVsIGZvciB0ZXN0aW5nXG4gICAgY2hyb21lLnN0b3JhZ2Uuc3luYy5nZXQoXCJhbnRocm9waWNfYXBpX3NldHRpbmdzXCIsIChyZXN1bHQpID0+IHtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gcmVzdWx0LmFudGhyb3BpY19hcGlfc2V0dGluZ3MgfHwge307XG4gICAgICBjb25zdCBtb2RlbCA9IHNldHRpbmdzLm1vZGVsIHx8IFwiY2xhdWRlLTMtNS1zb25uZXQtMjAyNDEwMjJcIjtcblxuICAgICAgLy8gTWFrZSBhIG1pbmltYWwgcmVxdWVzdCB0byB0ZXN0IHRoZSBBUEkga2V5XG4gICAgICBmZXRjaChBUElfVVJMLCB7XG4gICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgIGhlYWRlcnM6IGdldEFudGhyb3BpY0hlYWRlcnMocmVxdWVzdC5hcGlLZXkpLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgIG1lc3NhZ2VzOiBbeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogXCJIaVwiIH1dLFxuICAgICAgICAgIG1heF90b2tlbnM6IDEsXG4gICAgICAgIH0pLFxuICAgICAgfSlcbiAgICAgICAgLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBlcnJvckpzb24gPSBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgIGVycm9ySnNvbi5lcnJvcj8ubWVzc2FnZSB8fFxuICAgICAgICAgICAgICAgIGBBUEkgcmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YDtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgQVBJIHJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1Z0xvZyhcIkFudGhyb3BpYyBBUEkgdGVzdCBlcnJvciByZXNwb25zZTpcIiwge1xuICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEZvciA0MDEsIGxpa2VseSBhbiBpbnZhbGlkIEFQSSBrZXlcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2VuZFJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBlcnJvcjpcbiAgICAgICAgICAgICAgICAgIFwiSW52YWxpZCBBUEkga2V5LiBQbGVhc2UgY2hlY2sgeW91ciBBUEkga2V5IGluIHRoZSBleHRlbnNpb24gc2V0dGluZ3MuXCIsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2VuZFJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9KVxuICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgIGlmIChkYXRhICYmICFkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICBkZWJ1Z0xvZyhcIkFudGhyb3BpYyBBUEkgdGVzdCBzdWNjZWVkZWQ6XCIsIGRhdGEpO1xuICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgbW9kZWw6IGRhdGEubW9kZWwsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICBkZWJ1Z0xvZyhcIkFudGhyb3BpYyBBUEkgdGVzdCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICAgIHNlbmRSZXNwb25zZSh7XG4gICAgICAgICAgICBlcnJvcjogXCJGYWlsZWQgdG8gdGVzdCBBUEkga2V5LiBQbGVhc2UgdHJ5IGFnYWluLlwiLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSBtZXNzYWdlIGNoYW5uZWwgb3BlbiBmb3IgYXN5bmMgcmVzcG9uc2VcbiAgfVxuXG4gIGlmIChyZXF1ZXN0LnR5cGUgPT09IFwiYW50aHJvcGljX2NvbXBsZXRlXCIpIHtcbiAgICBkZWJ1Z0xvZyhcIk1ha2luZyBBbnRocm9waWMgQVBJIHJlcXVlc3Q6XCIsIHJlcXVlc3QuYm9keSk7XG5cbiAgICBmZXRjaChBUElfVVJMLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogZ2V0QW50aHJvcGljSGVhZGVycyhyZXF1ZXN0LmFwaUtleSksXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LmJvZHkpLFxuICAgIH0pXG4gICAgICAudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgbGV0IGVycm9yTWVzc2FnZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JKc29uID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9XG4gICAgICAgICAgICAgIGVycm9ySnNvbi5lcnJvcj8ubWVzc2FnZSB8fFxuICAgICAgICAgICAgICBgQVBJIHJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfWA7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgQVBJIHJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzICR7cmVzcG9uc2Uuc3RhdHVzfWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlYnVnTG9nKFwiQW50aHJvcGljIEFQSSBlcnJvciByZXNwb25zZTpcIiwge1xuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gRm9yIDQwMSwgbGlrZWx5IGFuIGludmFsaWQgQVBJIGtleVxuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbmRSZXNwb25zZSh7XG4gICAgICAgICAgICAgIGVycm9yOlxuICAgICAgICAgICAgICAgIFwiSW52YWxpZCBBUEkga2V5LiBQbGVhc2UgY2hlY2sgeW91ciBBUEkga2V5IGluIHRoZSBleHRlbnNpb24gc2V0dGluZ3MuXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VuZFJlc3BvbnNlKHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBpZiAoZGF0YSAmJiAhZGF0YS5lcnJvcikge1xuICAgICAgICAgIGRlYnVnTG9nKFwiQW50aHJvcGljIEFQSSBzdWNjZXNzIHJlc3BvbnNlOlwiLCBkYXRhKTtcbiAgICAgICAgICBzZW5kUmVzcG9uc2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGRlYnVnTG9nKFwiQW50aHJvcGljIEFQSSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICBzZW5kUmVzcG9uc2Uoe1xuICAgICAgICAgIGVycm9yOiBcIkZhaWxlZCB0byBjb21wbGV0ZSB0aGUgcmVxdWVzdC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIixcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIHJldHVybiB0cnVlOyAvLyBLZWVwIHRoZSBtZXNzYWdlIGNoYW5uZWwgb3BlbiBmb3IgYXN5bmMgcmVzcG9uc2VcbiAgfVxufSk7XG5cbmNocm9tZS50YWJzLm9uVXBkYXRlZC5hZGRMaXN0ZW5lcigodGFiSWQsIGNoYW5nZUluZm8sIHRhYikgPT4ge1xuICBpZiAoY2hhbmdlSW5mby5zdGF0dXMgPT09IFwiY29tcGxldGVcIikge1xuICAgIGNocm9tZS5zdG9yYWdlLnN5bmMuZ2V0KFwidXJsUGF0dGVybnNcIiwgKGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IHVybFBhdHRlcm5zID0gZGF0YS51cmxQYXR0ZXJucyB8fCBbXTtcbiAgICAgIGNvbnN0IHVybE1hdGNoZXMgPSB1cmxQYXR0ZXJucy5zb21lKChwYXR0ZXJuKSA9PlxuICAgICAgICB0YWIudXJsLmluY2x1ZGVzKHBhdHRlcm4pXG4gICAgICApO1xuXG4gICAgICBpZiAodXJsTWF0Y2hlcykge1xuICAgICAgICBkZWJ1Z0xvZyhcIkluamVjdGluZyBjb250ZW50IHNjcmlwdCBmb3IgdGFiOlwiLCB0YWJJZCk7XG4gICAgICAgIGNocm9tZS5zY3JpcHRpbmcuZXhlY3V0ZVNjcmlwdCh7XG4gICAgICAgICAgdGFyZ2V0OiB7IHRhYklkOiB0YWJJZCB9LFxuICAgICAgICAgIGZpbGVzOiBbXCJjb250ZW50LmpzXCJdLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSk7XG5cbi8vIExvZyB3aGVuIHRoZSBiYWNrZ3JvdW5kIHNjcmlwdCBpcyBsb2FkZWRcbmRlYnVnTG9nKFwiQmFja2dyb3VuZCBzY3JpcHQgbG9hZGVkXCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9
```

## dist/ClaudeExtension.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/ClaudeExtension.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ClaudeExtension.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Main extension class that handles UI and script execution after required elements exist.
 * Note: This class assumes elements are already present - initialization happens in content.ts
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClaudeExtension = void 0;
const FloatingWindow_1 = require("./ui/components/FloatingWindow");
const DraggableManager_1 = require("./ui/components/DraggableManager");
const StatusManager_1 = require("./ui/components/StatusManager");
const ScriptRunner_1 = require("./services/ScriptRunner");
const ScriptParser_1 = require("./utils/ScriptParser");
const DocumentRetrieval_1 = require("./services/DocumentRetrieval");
const HelpManager_1 = require("./ui/components/HelpManager");
class ClaudeExtension {
    /**
     * Initialize UI components and bind event listeners.
     * Should only be called after required elements exist in the DOM.
     */
    async initializeUI() {
        console.log("Initializing UI components...");
        try {
            // Create UI components
            this.floatingWindow = new FloatingWindow_1.FloatingWindow();
            this.scriptRunner = new ScriptRunner_1.ScriptRunner(this.handleLog.bind(this));
            const windowElement = await this.floatingWindow.create();
            const elements = this.floatingWindow.getElements();
            // Set up status elements
            const statusElements = {
                statusElement: elements.status,
                statusText: elements.statusText,
                statusDetails: elements.statusDetails,
                scriptInput: elements.scriptText,
                runButton: elements.runButton,
            };
            // Initialize managers
            this.statusManager = new StatusManager_1.StatusManager(statusElements);
            this.draggableManager = new DraggableManager_1.DraggableManager(windowElement, elements.status);
            this.helpManager = new HelpManager_1.HelpManager(elements.output);
            // Bind event listeners
            this.bindEventListeners(elements);
            console.log("UI initialization complete");
        }
        catch (error) {
            console.error("UI initialization failed:", error);
            throw error;
        }
    }
    /**
     * Binds event listeners to UI elements
     */
    bindEventListeners(elements) {
        elements.runButton.addEventListener("click", () => this.handleRunScript(elements.scriptText));
        elements.scriptText.addEventListener("keydown", (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
                this.handleRunScript(elements.scriptText);
                e.preventDefault();
            }
        });
        elements.helpButton.addEventListener("click", () => this.helpManager?.show());
        elements.minimizeButton.addEventListener("click", () => this.floatingWindow?.toggleMinimize());
        elements.collapseButton.addEventListener("click", () => this.floatingWindow?.toggleCollapse());
    }
    /**
     * Handles script execution from the UI
     */
    async handleRunScript(scriptText) {
        const text = scriptText.value.trim();
        if (!text) {
            this.handleLog("Please enter a script", "error");
            return;
        }
        try {
            const script = ScriptParser_1.ScriptParser.parse(text);
            await this.statusManager?.setStatus("working", "Running script...");
            if (script.isCommand && script.command === "docs") {
                await this.handleDocsCommand();
                return;
            }
            await this.scriptRunner?.runScript(script);
            await this.statusManager?.setStatus("ready", "Complete");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Script error: ${message}`, "error");
            await this.statusManager?.setStatus("error", message);
            setTimeout(() => this.statusManager?.setStatus("ready"), 2000);
        }
    }
    /**
     * Handles the /docs command execution
     */
    async handleDocsCommand() {
        try {
            if (this.floatingWindow) {
                this.floatingWindow.clearOutput(); // NEW
            }
            this.handleLog("Fetching documents...");
            const docs = await DocumentRetrieval_1.DocumentRetrieval.fetchDocuments();
            if (this.floatingWindow) {
                // Display documents using new service
                await DocumentRetrieval_1.DocumentRetrieval.displayDocuments(docs, this.floatingWindow.getOutputElement());
            }
            await this.statusManager?.setStatus("ready", "Complete");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Error fetching documents: ${message}`, "error");
            await this.statusManager?.setStatus("ready", "");
        }
    }
    /**
     * Handles logging output to the UI
     */
    handleLog(message, type = "info") {
        console.log(message);
        this.floatingWindow?.log(message, type);
    }
}
exports.ClaudeExtension = ClaudeExtension;
//# sourceMappingURL=ClaudeExtension.js.map
```

## dist/content.js

```js
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ClaudeExtension.ts":
/*!********************************!*\
  !*** ./src/ClaudeExtension.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/content.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Main extension class that handles UI and script execution after required elements exist.
 * Note: This class assumes elements are already present - initialization happens in content.ts
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClaudeExtension = void 0;
const FloatingWindow_1 = __webpack_require__(/*! ./ui/components/FloatingWindow */ "./src/ui/components/FloatingWindow.ts");
const DraggableManager_1 = __webpack_require__(/*! ./ui/components/DraggableManager */ "./src/ui/components/DraggableManager.ts");
const StatusManager_1 = __webpack_require__(/*! ./ui/components/StatusManager */ "./src/ui/components/StatusManager.ts");
const UIStateManager_1 = __webpack_require__(/*! ./ui/components/UIStateManager */ "./src/ui/components/UIStateManager.ts");
const ScriptExecutionManager_1 = __webpack_require__(/*! ./services/ScriptExecutionManager */ "./src/services/ScriptExecutionManager.ts");
const HelpManager_1 = __webpack_require__(/*! ./ui/components/HelpManager */ "./src/ui/components/HelpManager.ts");
const AliasService_1 = __webpack_require__(/*! ./services/AliasService */ "./src/services/AliasService.ts");
class ClaudeExtension {
    /**
     * Initialize UI components and bind event listeners.
     * Should only be called after required elements exist in the DOM.
     */
    async initializeUI() {
        console.log("Initializing UI components...");
        try {
            // Initialize AliasService first
            AliasService_1.AliasService.initialize();
            // Create UI components
            this.floatingWindow = new FloatingWindow_1.FloatingWindow();
            const windowElement = await this.floatingWindow.create();
            const elements = this.floatingWindow.getElements();
            // Create status elements mapping
            const statusElements = {
                statusElement: elements.status,
                statusText: elements.statusText,
                statusDetails: elements.statusDetails,
                scriptInput: elements.scriptText,
                runButton: elements.runButton,
            };
            // Set up managers
            this.statusManager = new StatusManager_1.StatusManager(statusElements);
            this.draggableManager = new DraggableManager_1.DraggableManager(windowElement, elements.status);
            this.uiStateManager = new UIStateManager_1.UIStateManager(elements, this.statusManager);
            this.scriptExecutionManager = new ScriptExecutionManager_1.ScriptExecutionManager(this.statusManager, this.handleLog.bind(this), elements.output);
            this.helpManager = new HelpManager_1.HelpManager(elements.output);
            // Bind event listeners
            this.bindEventListeners(elements);
            console.log("UI initialization complete");
        }
        catch (error) {
            console.error("UI initialization failed:", error);
            throw error;
        }
    }
    /**
     * Binds event listeners to UI elements
     */
    bindEventListeners(elements) {
        // Run button triggers script execution
        elements.runButton.addEventListener("click", () => this.handleRunScript(elements.scriptText));
        // Help button shows help text
        elements.helpButton.addEventListener("click", () => this.helpManager?.show());
        // Minimize and collapse buttons control window state
        elements.minimizeButton.addEventListener("click", () => this.uiStateManager?.toggleMinimize());
        elements.collapseButton.addEventListener("click", () => this.uiStateManager?.toggleCollapse());
    }
    /**
     * Handles script execution from the UI
     */
    async handleRunScript(scriptText) {
        if (!this.scriptExecutionManager) {
            this.handleLog("Script execution manager not initialized", "error");
            return;
        }
        if (this.statusManager?.getCurrentState() === "working") {
            this.scriptExecutionManager.cancel();
        }
        else {
            await this.scriptExecutionManager.executeScript(scriptText.value);
        }
    }
    /**
     * Handles logging output to the UI
     */
    handleLog(message, type = "info") {
        console.log(message);
        this.uiStateManager?.log(message, type);
    }
    /**
     * Cleans up the component
     */
    destroy() {
        this.floatingWindow?.destroy();
        this.draggableManager?.destroy();
    }
}
exports.ClaudeExtension = ClaudeExtension;


/***/ }),

/***/ "./src/services/AliasService.ts":
/*!**************************************!*\
  !*** ./src/services/AliasService.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/services/AliasService.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AliasService = void 0;
const storage_1 = __webpack_require__(/*! ../types/storage */ "./src/types/storage.ts");
/**
 * Service for managing aliases stored in storage
 */
class AliasService {
    /**
     * Initialize the storage system
     */
    static initialize(storage) {
        if (storage) {
            this.storage = storage;
        }
        else {
            try {
                // Test if we're in a browser environment
                if (typeof window !== "undefined" && window.localStorage) {
                    this.storage = new storage_1.BrowserStorage();
                }
                else {
                    this.storage = new storage_1.MemoryStorage();
                }
            }
            catch (error) {
                this.storage = new storage_1.MemoryStorage();
            }
        }
    }
    /**
     * Ensures storage is initialized
     */
    static ensureStorage() {
        if (!this.storage) {
            this.initialize();
        }
    }
    /**
     * Retrieves all stored aliases
     */
    static getAliases() {
        this.ensureStorage();
        try {
            const data = this.storage.getItem(this.STORAGE_KEY);
            return data ? JSON.parse(data) : {};
        }
        catch (error) {
            console.error("Error retrieving aliases:", error);
            return {};
        }
    }
    /**
     * Gets a specific alias by name
     */
    static getAlias(name) {
        this.ensureStorage();
        const aliases = this.getAliases();
        return aliases[name];
    }
    /**
     * Creates or updates an alias
     */
    static setAlias(name, text) {
        this.ensureStorage();
        if (!this.isValidAliasName(name)) {
            throw new Error("Invalid alias name. Use only letters, numbers, and underscores.");
        }
        try {
            const aliases = this.getAliases();
            aliases[name] = text;
            this.storage.setItem(this.STORAGE_KEY, JSON.stringify(aliases));
        }
        catch (error) {
            throw new Error(`Failed to save alias: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Deletes an alias
     */
    static deleteAlias(name) {
        this.ensureStorage();
        const aliases = this.getAliases();
        if (!(name in aliases)) {
            return false;
        }
        delete aliases[name];
        this.storage.setItem(this.STORAGE_KEY, JSON.stringify(aliases));
        return true;
    }
    /**
     * Validates an alias name
     */
    static isValidAliasName(name) {
        return /^[a-zA-Z0-9_]+$/.test(name);
    }
    /**
     * Processes text to replace all aliases with their values
     */
    static processText(text) {
        this.ensureStorage();
        const aliases = this.getAliases();
        let processedText = text;
        // Sort aliases by length (longest first) to handle nested aliases correctly
        const sortedAliases = Object.entries(aliases).sort((a, b) => b[0].length - a[0].length);
        for (const [name, value] of sortedAliases) {
            // Use lookbehind to ensure @ is not preceded by non-whitespace characters
            const regex = new RegExp(`(?<!\\S)@${name}\\b`, "g");
            processedText = processedText.replace(regex, value);
        }
        return processedText;
    }
    /**
     * Clears all aliases from storage
     */
    static clearAllAliases() {
        this.ensureStorage();
        this.storage.removeItem(this.STORAGE_KEY);
    }
    /**
     * Gets a formatted list of all aliases
     */
    static getAliasList() {
        this.ensureStorage();
        const aliases = this.getAliases();
        return Object.entries(aliases).map(([name, value]) => `@${name}: ${value}`);
    }
}
exports.AliasService = AliasService;
AliasService.STORAGE_KEY = "claude_extension_aliases";


/***/ }),

/***/ "./src/services/AnthropicService.ts":
/*!******************************************!*\
  !*** ./src/services/AnthropicService.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/services/AnthropicService.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for making requests to the Anthropic API
 * Note: Your friendly neighborhood AI API whisperer!
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnthropicService = void 0;
const SettingsService_1 = __webpack_require__(/*! ./SettingsService */ "./src/services/SettingsService.ts");
class AnthropicService {
    /**
     * Makes a request to the Anthropic API through the background script
     */
    static async complete(messages, options = {}) {
        console.log("[AnthropicService] Starting API request");
        try {
            const settings = await SettingsService_1.SettingsService.validateSettings();
            if (!settings.valid) {
                console.log("[AnthropicService] Invalid settings:", settings.message);
                return {
                    success: false,
                    error: settings.message,
                };
            }
            const apiKey = await SettingsService_1.SettingsService.getSetting("anthropicApiKey");
            if (!apiKey) {
                console.log("[AnthropicService] No API key found");
                return {
                    success: false,
                    error: "API key not found in settings",
                };
            }
            const model = await SettingsService_1.SettingsService.getSetting("model");
            console.log("[AnthropicService] Using model:", model);
            const requestBody = {
                model,
                messages,
                max_tokens: options.maxTokens || 1024,
                temperature: options.temperature,
                top_p: options.topP,
                top_k: options.topK,
            };
            return new Promise((resolve, reject) => {
                console.log("[AnthropicService] Sending message to background script");
                // Set up abort handler if signal is provided
                if (options.signal) {
                    options.signal.addEventListener("abort", () => {
                        console.log("[AnthropicService] Request cancelled");
                        resolve({
                            success: false,
                            cancelled: true,
                            error: "Request cancelled",
                        });
                    });
                    // If signal is already aborted, resolve immediately
                    if (options.signal.aborted) {
                        console.log("[AnthropicService] Signal already aborted");
                        resolve({
                            success: false,
                            cancelled: true,
                            error: "Request cancelled",
                        });
                        return;
                    }
                }
                chrome.runtime.sendMessage({
                    type: "anthropic_complete",
                    apiKey,
                    body: requestBody,
                }, (response) => {
                    // Check if request was cancelled
                    if (options.signal?.aborted) {
                        console.log("[AnthropicService] Request was cancelled");
                        resolve({
                            success: false,
                            cancelled: true,
                            error: "Request cancelled",
                        });
                        return;
                    }
                    if (chrome.runtime.lastError) {
                        console.error("[AnthropicService] Runtime error:", chrome.runtime.lastError);
                        resolve({
                            success: false,
                            error: chrome.runtime.lastError.message,
                        });
                        return;
                    }
                    if (response.error) {
                        console.error("[AnthropicService] API error:", response.error);
                        resolve({
                            success: false,
                            error: response.error,
                        });
                        return;
                    }
                    console.log("[AnthropicService] Received successful response");
                    resolve({
                        success: true,
                        text: response.content[0]?.text || "",
                    });
                });
            });
        }
        catch (error) {
            console.error("[AnthropicService] Unexpected error:", error);
            return {
                success: false,
                error: "An unexpected error occurred",
            };
        }
    }
}
exports.AnthropicService = AnthropicService;


/***/ }),

/***/ "./src/services/ClaudeCache.ts":
/*!*************************************!*\
  !*** ./src/services/ClaudeCache.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
// This software is licensed under the MIT License.
// File: src/services/ClaudeCache.ts
// Simple caching utility for Claude API responses
// The cache that remembers so you don't have to!
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClaudeCache = void 0;
const getHeaders_1 = __webpack_require__(/*! ../utils/getHeaders */ "./src/utils/getHeaders.ts");
class ClaudeCache {
    /**
     * Clears all entries from the cache
     */
    static clearCache() {
        ClaudeCache.cache.clear();
    }
    /**
     * Fetches data with caching support
     * @param url The URL to fetch from
     * @param options Optional fetch configuration
     * @returns Promise resolving to the fetched data
     */
    static async fetchWithCache(url, options = {}) {
        const { timeoutMs = ClaudeCache.DEFAULT_TIMEOUT_MS, forceRefresh = false } = options;
        // Always use fresh data if requested
        if (forceRefresh) {
            ClaudeCache.cache.delete(url);
        }
        // Check cache first
        const cachedEntry = ClaudeCache.cache.get(url);
        if (cachedEntry) {
            const now = Date.now();
            if (now - cachedEntry.timestamp < timeoutMs) {
                return cachedEntry.data;
            }
            // Remove expired entry
            ClaudeCache.cache.delete(url);
        }
        // If not in cache or expired, fetch new data
        const response = await fetch(url, {
            headers: options.headers || (0, getHeaders_1.getHeaders)(),
            credentials: "include",
        });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        // Cache the new data
        ClaudeCache.cache.set(url, {
            data,
            timestamp: Date.now(),
        });
        return data;
    }
    /**
     * Gets a cached entry directly
     * @param key Cache key to retrieve
     * @returns Cached data if found and not expired
     */
    static getCached(key) {
        const entry = ClaudeCache.cache.get(key);
        if (!entry)
            return null;
        const now = Date.now();
        if (now - entry.timestamp < ClaudeCache.DEFAULT_TIMEOUT_MS) {
            return entry.data;
        }
        // Remove expired entry
        ClaudeCache.cache.delete(key);
        return null;
    }
    /**
     * Sets a cache entry directly
     * @param key Cache key
     * @param data Data to cache
     */
    static setCached(key, data) {
        ClaudeCache.cache.set(key, {
            data,
            timestamp: Date.now(),
        });
    }
    /**
     * Removes a specific entry from the cache
     * @param key Cache key to remove
     */
    static removeCached(key) {
        ClaudeCache.cache.delete(key);
    }
}
exports.ClaudeCache = ClaudeCache;
ClaudeCache.cache = new Map();
ClaudeCache.DEFAULT_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes


/***/ }),

/***/ "./src/services/CommandExecutor.ts":
/*!*****************************************!*\
  !*** ./src/services/CommandExecutor.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/services/CommandExecutor.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Handles execution of Claude extension commands
 * Note: One command handler to rule them all!
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandExecutor = void 0;
const DocumentRetrieval_1 = __webpack_require__(/*! ./DocumentRetrieval */ "./src/services/DocumentRetrieval.ts");
const ProjectRetrieval_1 = __webpack_require__(/*! ./ProjectRetrieval */ "./src/services/ProjectRetrieval.ts");
const ProjectSearchService_1 = __webpack_require__(/*! ./ProjectSearchService */ "./src/services/ProjectSearchService.ts");
const ConversationRetrieval_1 = __webpack_require__(/*! ./ConversationRetrieval */ "./src/services/ConversationRetrieval.ts");
const PromptAll_1 = __webpack_require__(/*! ./PromptAll */ "./src/services/PromptAll.ts");
const AliasService_1 = __webpack_require__(/*! ./AliasService */ "./src/services/AliasService.ts");
const SettingsService_1 = __webpack_require__(/*! ./SettingsService */ "./src/services/SettingsService.ts");
class CommandExecutor {
    constructor(statusManager, handleLog, outputElement) {
        this.statusManager = statusManager;
        this.handleLog = handleLog;
        this.outputElement = outputElement;
        // Hook up the script's Cancel button to abort functionality
        this.statusManager.onCancel = () => {
            ProjectSearchService_1.ProjectSearchService.abortSearch();
        };
    }
    /**
     * Handles the /docs command execution
     */
    async handleDocsCommand() {
        try {
            this.outputElement.innerHTML = "";
            this.handleLog("Fetching documents...");
            const docs = await DocumentRetrieval_1.DocumentRetrieval.fetchDocuments();
            await DocumentRetrieval_1.DocumentRetrieval.displayDocuments(docs, this.outputElement);
            await this.statusManager.setStatus("ready", "Complete");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Error fetching documents: ${message}`, "error");
            await this.statusManager.setStatus("ready", "");
        }
    }
    /**
     * Handles the /project command execution
     */
    async handleProjectCommand() {
        try {
            this.outputElement.innerHTML = "";
            this.handleLog("Fetching project conversations...");
            await ProjectRetrieval_1.ProjectRetrieval.displayCurrentProject(this.outputElement);
            await this.statusManager.setStatus("ready", "Complete");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Error fetching project conversations: ${message}`, "error");
            await this.statusManager.setStatus("error", message);
            setTimeout(() => this.statusManager.setStatus("ready"), 2000);
        }
    }
    /**
     * Handles the /search_project command execution
     */
    async handleSearchProjectCommand(script) {
        try {
            this.outputElement.innerHTML = "";
            this.handleLog(script.searchText
                ? `Searching projects for: ${script.searchText}`
                : "Retrieving project conversations...");
            await ProjectSearchService_1.ProjectSearchService.searchAndDisplayResults(script.searchText, this.outputElement);
            await this.statusManager.setStatus("ready", script.searchText
                ? "Search completed successfully"
                : "Projects retrieved successfully");
            this.handleLog(script.searchText
                ? "Search completed successfully"
                : "Projects retrieved successfully", "success");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Error during project search: ${message}`, "error");
            await this.statusManager.setStatus("error", message);
            setTimeout(() => this.statusManager.setStatus("ready"), 2000);
        }
    }
    async handleSettingsCommand(script) {
        try {
            // Format: /settings api_key YOUR_KEY
            const parts = script.prompt ? script.prompt.trim().split(/\s+/) : [];
            if (parts.length < 2) {
                throw new Error("Missing setting name. Format: /settings [setting_name] [value]");
            }
            const settingName = parts[0];
            const value = parts.slice(1).join(" ");
            switch (settingName) {
                case "api_key":
                    const error = SettingsService_1.SettingsService.validateApiKey(value);
                    if (error) {
                        throw new Error(`Invalid API key: ${error}`);
                    }
                    SettingsService_1.SettingsService.setSetting("anthropicApiKey", value);
                    this.handleLog("API key updated successfully", "success");
                    break;
                default:
                    throw new Error(`Unknown setting: ${settingName}`);
            }
            await this.statusManager.setStatus("ready", "Settings updated");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Settings error: ${message}`, "error");
            await this.statusManager.setStatus("error", message);
            setTimeout(() => this.statusManager.setStatus("ready"), 2000);
        }
    }
    /**
     * Handles the /query_project command execution
     */
    async handleQueryProjectCommand(script) {
        try {
            this.outputElement.innerHTML = "";
            const prompt = script.prompt;
            if (!prompt || prompt.trim().length === 0) {
                throw new Error("No prompt provided for query_project command");
            }
            this.handleLog("Querying all conversations...");
            await PromptAll_1.PromptAll.queryAndDisplayResults(prompt, this.outputElement, async (status) => {
                await this.statusManager.setStatus("working", status);
                this.handleLog(status);
            });
            await this.statusManager.setStatus("ready", "Query completed successfully");
            this.handleLog("Query completed successfully", "success");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Error during project query: ${message}`, "error");
            await this.statusManager.setStatus("error", message);
            setTimeout(() => this.statusManager.setStatus("ready"), 2000);
        }
    }
    /**
     * Handles conversation-related commands execution
     */
    async handleConversationCommand(options) {
        try {
            this.outputElement.innerHTML = "";
            this.handleLog("Retrieving conversation...");
            await ConversationRetrieval_1.ConversationRetrieval.displayCurrentConversation(options, this.outputElement);
            await this.statusManager.setStatus("ready", "Conversation retrieved successfully");
            this.handleLog("Conversation retrieved successfully", "success");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Error retrieving conversation: ${message}`, "error");
            await this.statusManager.setStatus("error", message);
            setTimeout(() => this.statusManager.setStatus("ready"), 2000);
        }
    }
    /**
     * Handles alias command execution
     */
    async handleAliasCommand(script) {
        if (!script.aliasCommand) {
            throw new Error("No alias command specified");
        }
        try {
            switch (script.aliasCommand.type) {
                case "alias":
                    if (!script.aliasCommand.name || !script.aliasCommand.text) {
                        throw new Error("Invalid alias command: missing name or text");
                    }
                    AliasService_1.AliasService.setAlias(script.aliasCommand.name, script.aliasCommand.text);
                    this.handleLog(`Alias @${script.aliasCommand.name} created`, "success");
                    break;
                case "delete_alias":
                    if (!script.aliasCommand.name) {
                        throw new Error("Invalid delete alias command: missing name");
                    }
                    if (AliasService_1.AliasService.deleteAlias(script.aliasCommand.name)) {
                        this.handleLog(`Alias @${script.aliasCommand.name} deleted`, "success");
                    }
                    else {
                        this.handleLog(`Alias @${script.aliasCommand.name} not found`, "error");
                    }
                    break;
                case "list_alias":
                    const aliases = AliasService_1.AliasService.getAliasList();
                    if (aliases.length === 0) {
                        this.handleLog("No aliases defined", "info");
                    }
                    else {
                        this.outputElement.innerHTML = "";
                        aliases.forEach((alias) => {
                            const div = document.createElement("div");
                            div.textContent = alias;
                            this.outputElement.appendChild(div);
                        });
                    }
                    break;
                default:
                    throw new Error("Unknown alias command type");
            }
            await this.statusManager.setStatus("ready", "Complete");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Alias command failed: ${message}`, "error");
            await this.statusManager.setStatus("error", message);
            setTimeout(() => this.statusManager.setStatus("ready"), 2000);
        }
    }
}
exports.CommandExecutor = CommandExecutor;


/***/ }),

/***/ "./src/services/ConversationRetrieval.ts":
/*!***********************************************!*\
  !*** ./src/services/ConversationRetrieval.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /src/services/ConversationRetrieval.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for managing Claude conversations and artifacts
 * Note: Making conversation history easier to browse and analyze!
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConversationRetrieval = void 0;
const ClaudeCache_1 = __webpack_require__(/*! ./ClaudeCache */ "./src/services/ClaudeCache.ts");
const DownloadTable_1 = __webpack_require__(/*! ../ui/components/DownloadTable */ "./src/ui/components/DownloadTable.ts");
const getClaudeIds_1 = __webpack_require__(/*! ../utils/getClaudeIds */ "./src/utils/getClaudeIds.ts");
const PathExtractor_1 = __webpack_require__(/*! @/utils/PathExtractor */ "./src/utils/PathExtractor.ts");
/**
 * Service for managing Claude conversations and artifacts
 */
class ConversationRetrieval {
    /**
     * Gets the conversation ID from the current URL
     * @returns Conversation ID if found
     * @throws Error if not on a conversation page
     */
    static getConversationIdFromUrl() {
        const match = window.location.pathname.match(/\/chat\/([^\/]+)/);
        if (!match) {
            throw new Error("Please navigate to a Claude chat page before using conversation commands");
        }
        return match[1];
    }
    /**
     * Retrieves a conversation by ID with caching
     * @param orgId - Organization ID
     * @param conversationId - Conversation ID to retrieve
     * @param forceRefresh - Force refresh from API instead of cache
     * @returns Promise resolving to conversation data
     * @throws Error if retrieval fails
     */
    static async getConversation(orgId, conversationId, forceRefresh = false) {
        const url = `${this.API_URL}/${orgId}/chat_conversations/${conversationId}?tree=True&rendering_mode=messages&render_all_tools=true`;
        try {
            return await ClaudeCache_1.ClaudeCache.fetchWithCache(url, {
                forceRefresh,
                timeoutMs: 60000, // Cache for 1 minute since conversations can update frequently
            });
        }
        catch (error) {
            throw new Error(`Error retrieving conversation: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Gets appropriate file extension based on language
     * @param language - Programming language or file type
     * @returns File extension including dot
     */
    static getFileExtension(language) {
        if (!language)
            return ".txt";
        const extensionMap = {
            typescript: ".ts",
            javascript: ".js",
            python: ".py",
            java: ".java",
            "text/markdown": ".md",
            "application/json": ".json",
            html: ".html",
            css: ".css",
            "text/html": ".html",
            "application/vnd.ant.code": ".txt",
            "application/vnd.ant.react": ".tsx",
            "application/vnd.ant.mermaid": ".mmd",
            "image/svg+xml": ".svg",
        };
        return extensionMap[language.toLowerCase()] || ".txt";
    }
    /**
     * Extracts artifacts from a conversation
     * @param conversation - Conversation to extract artifacts from
     * @returns Array of artifacts
     */
    // In ConversationRetrieval.ts, update the extractArtifacts method:
    static extractArtifacts(conversation) {
        const artifacts = [];
        conversation.chat_messages.forEach((message) => {
            message.content.forEach((item) => {
                if (item.type === "tool_use" && item.input) {
                    const content = item.input.content;
                    // Extract path from content
                    let filePath = content ? (0, PathExtractor_1.extractRelPath)(content) : "";
                    // If no path found, use title as filename without forcing extension
                    if (!filePath && item.input.title) {
                        filePath = item.input.title;
                    }
                    // Process directory names to kabob case but keep filename as is
                    const processedPath = !filePath
                        ? ""
                        : filePath
                            .split("/")
                            .map((part, index, arr) => {
                            // Keep filename (last part) as is
                            if (index === arr.length - 1)
                                return part;
                            // Transform directory names to kabob case
                            return part.replace(/\s+/g, "-").toLowerCase();
                        })
                            .join("/");
                    artifacts.push({
                        id: item.input.id,
                        title: filePath?.split("/")?.pop() || item.input.title || "Untitled",
                        language: item.input.language,
                        content: content,
                        delta: item.input.new_str || item.input.old_str
                            ? {
                                old: item.input.old_str || "",
                                new: item.input.new_str || "",
                            }
                            : undefined,
                        filePath: processedPath,
                        // Add the dates from the containing message
                        created_at: message.created_at,
                        updated_at: message.updated_at,
                    });
                }
            });
        });
        return artifacts;
    }
    /**
     * Extracts file path from artifact content if present
     * @param content - Artifact content to search
     * @returns File path if found, undefined otherwise
     */
    static extractFilePath(content) {
        const filePathMatch = (0, PathExtractor_1.extractRelPath)(content);
        return filePathMatch;
    }
    /**
     * Converts artifacts to DocumentInfo format for DownloadTable
     * @param artifacts - Array of conversation artifacts
     * @returns Array of DocumentInfo objects
     */
    static convertArtifactsToDocumentInfo(artifacts) {
        const unique = new Map();
        // Keep only the latest version of each artifact
        artifacts.forEach((artifact) => {
            if (artifact.content) {
                unique.set(artifact.id, artifact);
            }
        });
        return Array.from(unique.values()).map((artifact) => ({
            fileName: artifact.title,
            filePath: artifact.filePath || artifact.title,
            content: artifact.content || "",
            isSelected: true,
            metadata: {
                language: artifact.language,
                id: artifact.id,
                // Pass through the dates from the artifact
                created_at: artifact.created_at,
                updated_at: artifact.updated_at,
            },
        }));
    }
    /**
     * Displays conversation elements in the output element
     * @param docs - Documents to display
     * @param outputElement - Element to display documents in
     */
    static async displayConversation(docs, outputElement) {
        outputElement.innerHTML = "";
        const table = new DownloadTable_1.DownloadTable(outputElement, docs);
        table.render();
    }
    /**
     * Retrieves and displays the current conversation based on command options
     * @param options - Command options for the export
     * @param outputElement - Element to display the conversation in
     * @returns Promise that resolves when display is complete
     */
    static async displayCurrentConversation(options, outputElement) {
        try {
            const orgId = (0, getClaudeIds_1.getOrganizationId)();
            const conversationId = this.getConversationIdFromUrl();
            const conversation = await this.getConversation(orgId, conversationId, true);
            // Extract and process artifacts if requested
            if (options?.includeArtifacts) {
                const artifacts = this.extractArtifacts(conversation);
                const docs = this.convertArtifactsToDocumentInfo(artifacts);
                if (docs.length === 0) {
                    throw new Error("No artifacts found in conversation");
                }
                await this.displayConversation(docs, outputElement);
            }
            else {
                // Display conversation with metadata for preview
                const docs = [
                    {
                        fileName: conversation.name,
                        filePath: `conversations/${conversation.name}.md`,
                        content: "", // Empty initial content, will be loaded by callback
                        isSelected: true,
                        metadata: {
                            conversationId: conversation.uuid,
                            url: `https://claude.ai/chat/${conversation.uuid}`,
                            created_at: conversation.created_at,
                            updated_at: conversation.updated_at,
                        },
                        contentCallback: async () => {
                            const conv = await this.getConversation(orgId, conversationId, true);
                            return this.conversationToMarkdown(conv);
                        },
                    },
                ];
                await this.displayConversation(docs, outputElement);
            }
        }
        catch (error) {
            throw new Error(`Failed to display conversation: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Gets the organization ID from cookies
     * @throws Error if organization ID is not found or invalid
     */
    static getOrganizationId() {
        const cookie = document.cookie
            .split("; ")
            .find((row) => row.startsWith("lastActiveOrg="));
        if (!cookie) {
            throw new Error("Organization ID not found in cookies");
        }
        try {
            const value = decodeURIComponent(cookie.split("=")[1]);
            return value.replace(/^"|"$/g, "");
        }
        catch (error) {
            throw new Error("Invalid organization ID format in cookie");
        }
    }
    /**
     * Converts a conversation to markdown format
     * @param conversation - Conversation to convert
     * @param filterCallback - Optional callback to filter messages
     * @returns Markdown string of the conversation
     */
    static conversationToMarkdown(conversation, filterCallback) {
        const sections = [];
        sections.push(`# ${conversation.name}\n`);
        // Add conversation metadata
        const createdDate = new Date(conversation.created_at);
        const updatedDate = new Date(conversation.updated_at);
        sections.push("## Conversation Details");
        sections.push(`- Created: ${createdDate.toLocaleString(undefined, {
            year: "numeric",
            month: "long",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit",
            timeZoneName: "short",
        })}`);
        sections.push(`- Last Updated: ${updatedDate.toLocaleString(undefined, {
            year: "numeric",
            month: "long",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit",
            timeZoneName: "short",
        })}`);
        sections.push("\n---\n");
        const filteredMessages = filterCallback
            ? conversation.chat_messages.filter(filterCallback)
            : conversation.chat_messages;
        filteredMessages.forEach((message, index) => {
            // Add message header with timestamp
            const messageDate = new Date(message.created_at);
            const formattedDate = messageDate.toLocaleString(undefined, {
                year: "numeric",
                month: "long",
                day: "numeric",
                hour: "2-digit",
                minute: "2-digit",
                timeZoneName: "short",
            });
            sections.push(`## ${message.sender === "human" ? "Human" : "Assistant"} _(${formattedDate})_\n`);
            message.content.forEach((item) => {
                if (item.type === "text") {
                    sections.push(item.text || "");
                }
                else if (item.type === "tool_use" && item.input) {
                    // Handle artifacts
                    const artifact = this.extractSingleArtifact(item.input);
                    if (artifact) {
                        sections.push(`\n**Artifact: ${artifact.title}**`);
                        if (artifact.content) {
                            sections.push("\n```" + (artifact.language || ""));
                            sections.push(artifact.content);
                            sections.push("```\n");
                        }
                    }
                }
            });
            if (index < filteredMessages.length - 1) {
                sections.push("\n---\n");
            }
        });
        return sections.join("\n");
    }
    /**
     * Extracts a single artifact from message input
     * @param input - Message input containing artifact data
     * @returns Artifact information for markdown or null if invalid
     */
    static extractSingleArtifact(input) {
        if (!input.title)
            return null;
        return {
            title: input.title,
            language: input.language,
            content: input.content,
        };
    }
    /**
     * Gets current conversation details including latest message ID
     * @returns Promise resolving to { conversationId, parentMessageUuid }
     * @throws Error if conversation details cannot be retrieved
     */
    static async getCurrentConversationDetails() {
        // Get conversation ID from URL
        const conversationId = this.getConversationIdFromUrl();
        const orgId = (0, getClaudeIds_1.getOrganizationId)();
        try {
            // Get conversation details
            const conversation = await this.getConversation(orgId, conversationId, true);
            return {
                conversationId,
                parentMessageUuid: conversation.current_leaf_message_uuid,
            };
        }
        catch (error) {
            throw new Error(`Failed to get conversation details: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
}
exports.ConversationRetrieval = ConversationRetrieval;
ConversationRetrieval.API_URL = "https://api.claude.ai/api/organizations";


/***/ }),

/***/ "./src/services/DocumentDownload.ts":
/*!******************************************!*\
  !*** ./src/services/DocumentDownload.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/services/DocumentDownload.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for handling document downloads with support for dynamic content retrieval
 * Note: Your friendly neighborhood file downloader!
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentDownload = void 0;
class DocumentDownload {
    /**
     * Creates markdown content from multiple documents
     * @param docs - Array of documents to combine
     * @returns Promise resolving to markdown string
     */
    static async createMarkdownContent(docs) {
        const sections = [];
        const groupedDocs = this.groupDocumentsByDirectory(docs);
        const singleFile = Object.keys(groupedDocs).length > 1;
        sections.push("# src\n");
        for (const [directory, dirDocs] of Object.entries(groupedDocs)) {
            if (directory !== "" && !singleFile) {
                sections.push(`## ${directory}\n`);
            }
            for (const doc of dirDocs) {
                const extension = doc.filePath.split(".").pop() || "";
                const language = this.getLanguageFromExtension(extension);
                sections.push(`## ${doc.filePath}\n`);
                if (!singleFile) {
                    sections.push("```" + language);
                }
                // Use contentCallback if available, otherwise use static content
                const content = doc.contentCallback
                    ? await doc.contentCallback(doc)
                    : doc.content;
                sections.push(content);
                if (!singleFile) {
                    sections.push("```\n");
                }
            }
        }
        return sections.join("\n");
    }
    /**
     * Groups documents by their directory path
     * @param docs - Documents to group
     * @returns Record of directory paths to document arrays
     */
    static groupDocumentsByDirectory(docs) {
        const groups = {};
        docs.forEach((doc) => {
            const path = doc.filePath;
            const lastSlash = path.lastIndexOf("/");
            const directory = lastSlash > 0 ? path.substring(0, lastSlash) : "";
            if (!groups[directory]) {
                groups[directory] = [];
            }
            groups[directory].push(doc);
        });
        return Object.keys(groups)
            .sort()
            .reduce((obj, key) => {
            obj[key] = groups[key].sort((a, b) => a.fileName.localeCompare(b.fileName));
            return obj;
        }, {});
    }
    /**
     * Maps file extensions to language identifiers for syntax highlighting
     * @param extension - File extension without dot
     * @returns Language identifier string
     */
    static getLanguageFromExtension(extension) {
        const languageMap = {
            ts: "typescript",
            js: "javascript",
            jsx: "jsx",
            tsx: "tsx",
            css: "css",
            scss: "scss",
            html: "html",
            json: "json",
            md: "markdown",
            py: "python",
            rb: "ruby",
            java: "java",
            cpp: "cpp",
            c: "c",
            cs: "csharp",
            go: "go",
            rs: "rust",
            php: "php",
            sql: "sql",
            yaml: "yaml",
            yml: "yaml",
            xml: "xml",
            sh: "bash",
            bash: "bash",
            zsh: "bash",
            swift: "swift",
        };
        return languageMap[extension.toLowerCase()] || "";
    }
    /**
     * Initiates file download through Chrome extension
     * @param content - Content to download
     * @param filePath - Name for downloaded file
     * @param isBundled - Whether the content is a markdown bundle
     */
    static downloadContent(content, filePath, isBundled = false) {
        const extension = filePath.split(".").pop() || "";
        const language = isBundled
            ? ""
            : this.getLanguageFromExtension(extension) || "plain";
        const mimeType = isBundled ? "text/markdown" : `text/${language}`;
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        try {
            chrome.runtime.sendMessage({
                type: "download",
                url: url,
                filename: filePath,
            }, (response) => {
                if (!response.success) {
                    console.error("Download failed:", response.error);
                    alert("Failed to start download. Please try again.");
                }
            });
        }
        finally {
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }
    }
    /**
     * Downloads selected documents as a single markdown file
     * @param selectedDocs - Array of documents to download
     * @throws Error if no documents selected or download fails
     */
    static async handleSingleDownload(selectedDocs) {
        if (selectedDocs.length === 0) {
            throw new Error("No documents selected for export");
        }
        try {
            const markdownContent = await this.createMarkdownContent(selectedDocs);
            const timestamp = new Date()
                .toISOString()
                .replace(/[:]/g, "-")
                .split(".")[0];
            const filename = `claude-export-${timestamp}.md`;
            this.downloadContent(markdownContent, filename, true);
        }
        catch (error) {
            throw new Error(`Failed to export document bundle: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Downloads each selected document as a separate file
     * @param selectedDocs - Array of documents to download
     * @throws Error if no documents selected or download fails
     */
    // In DocumentDownload.ts, update the handleMultipleDownload method:
    static async handleMultipleDownload(selectedDocs) {
        if (selectedDocs.length === 0) {
            throw new Error("No documents selected for export");
        }
        try {
            for (const doc of selectedDocs) {
                const content = doc.contentCallback
                    ? await doc.contentCallback(doc)
                    : doc.content;
                // Use the full path if available, otherwise fallback to filename
                const filePath = doc.filePath || doc.fileName;
                this.downloadContent(content, filePath, false);
            }
        }
        catch (error) {
            throw new Error(`Failed to export individual documents: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
}
exports.DocumentDownload = DocumentDownload;


/***/ }),

/***/ "./src/services/DocumentRetrieval.ts":
/*!*******************************************!*\
  !*** ./src/services/DocumentRetrieval.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
// This software is licensed under the MIT License.
// File: src/services/DocumentRetrieval.ts
// Service for retrieving Claude-generated documents
// Note: Like a librarian for your AI's creative works!
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentRetrieval = void 0;
const DownloadTable_1 = __webpack_require__(/*! ../ui/components/DownloadTable */ "./src/ui/components/DownloadTable.ts");
const getClaudeIds_1 = __webpack_require__(/*! ../utils/getClaudeIds */ "./src/utils/getClaudeIds.ts");
const ClaudeCache_1 = __webpack_require__(/*! ./ClaudeCache */ "./src/services/ClaudeCache.ts");
const PathExtractor_1 = __webpack_require__(/*! @/utils/PathExtractor */ "./src/utils/PathExtractor.ts");
class DocumentRetrieval {
    /**
     * Fetches available documents from the API with caching
     * @param forceRefresh Force refresh from API instead of cache
     * @throws Error if documents cannot be retrieved
     */
    static async fetchDocuments(forceRefresh = false) {
        try {
            const organizationId = (0, getClaudeIds_1.getOrganizationId)();
            const projectUuid = await (0, getClaudeIds_1.getProjectUuid)(organizationId);
            const url = `${this.API_URL}/${organizationId}/projects/${projectUuid}/docs`;
            const data = await ClaudeCache_1.ClaudeCache.fetchWithCache(url, {
                timeoutMs: 300000, // Cache documents for 5 minutes
                forceRefresh,
            });
            return this.processDocuments(data);
        }
        catch (error) {
            throw new Error(`Error fetching documents: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Displays documents in the provided output element
     * @param docs - Documents to display
     * @param outputElement - Element to display documents in
     */
    static async displayDocuments(docs, outputElement) {
        outputElement.innerHTML = "";
        const table = new DownloadTable_1.DownloadTable(outputElement, docs);
        table.render();
    }
    /**
     * Processes raw document data into DocumentInfo objects
     * @param data - Raw document data from API
     * @returns Processed document information
     */
    static processDocuments(data) {
        return data.map((doc) => {
            // Extract path from content, without forcing an extension
            const filePathMatch = (0, PathExtractor_1.extractRelPath)(doc.content);
            const filePath = filePathMatch || doc.file_name;
            // Convert directory separators to kabob case but keep filename as is
            const processedPath = filePath
                .split("/")
                .map((part, index, arr) => {
                // Don't transform the filename (last part)
                if (index === arr.length - 1)
                    return part;
                // Transform directory names to kabob case
                return part.replace(/\s+/g, "-").toLowerCase();
            })
                .join("/");
            return {
                fileName: doc.file_name,
                filePath: processedPath,
                content: doc.content || "",
                isSelected: doc.content?.includes("This was generated by Claude Sonnet"),
                metadata: {
                    created_at: doc.created_at,
                    updated_at: doc.updated_at || doc.created_at, // Fallback to created_at if updated_at not available
                },
            };
        });
    }
}
exports.DocumentRetrieval = DocumentRetrieval;
DocumentRetrieval.API_URL = "https://api.claude.ai/api/organizations";


/***/ }),

/***/ "./src/services/ProjectRetrieval.ts":
/*!******************************************!*\
  !*** ./src/services/ProjectRetrieval.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


// Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
// This software is licensed under the MIT License.
// File: src/services/ProjectRetrieval.ts
// Service for retrieving and managing Claude project data
// Note: The project manager that keeps your conversations organized!
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProjectRetrieval = void 0;
const getClaudeIds_1 = __webpack_require__(/*! ../utils/getClaudeIds */ "./src/utils/getClaudeIds.ts");
const DownloadTable_1 = __webpack_require__(/*! ../ui/components/DownloadTable */ "./src/ui/components/DownloadTable.ts");
const ConversationRetrieval_1 = __webpack_require__(/*! ./ConversationRetrieval */ "./src/services/ConversationRetrieval.ts");
const ClaudeCache_1 = __webpack_require__(/*! ./ClaudeCache */ "./src/services/ClaudeCache.ts");
/**
 * Service for managing Claude projects and their conversations
 */
class ProjectRetrieval {
    /**
     * Retrieves all conversations in the current project with caching
     * @param forceRefresh Force refresh from API instead of cache
     * @returns Promise resolving to array of project conversations
     * @throws Error if retrieval fails
     */
    static async getProjectConversations(forceRefresh = false) {
        try {
            const orgId = (0, getClaudeIds_1.getOrganizationId)();
            const projectId = await (0, getClaudeIds_1.getProjectUuid)(orgId);
            const url = `${this.API_URL}/${orgId}/projects/${projectId}/conversations`;
            return await ClaudeCache_1.ClaudeCache.fetchWithCache(url, {
                timeoutMs: 120000, // Cache project conversations for 2 minutes
                forceRefresh,
            });
        }
        catch (error) {
            throw new Error(`Error retrieving project conversations: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Converts conversations to DocumentInfo format for DownloadTable
     * @param conversations - Array of project conversations
     * @returns Array of DocumentInfo objects
     */
    static convertConversationsToDocumentInfo(conversations) {
        return conversations.map((conversation) => ({
            fileName: conversation.name,
            filePath: `${conversation.name.replace(/\s+/g, "-")}.md`,
            content: this.createConversationSummary(conversation),
            isSelected: false,
            metadata: {
                conversationId: conversation.uuid,
                url: `https://claude.ai/chat/${conversation.uuid}`,
                created_at: conversation.created_at,
                updated_at: conversation.updated_at,
            },
            contentCallback: async (doc) => {
                const orgId = (0, getClaudeIds_1.getOrganizationId)();
                try {
                    const conv = await ConversationRetrieval_1.ConversationRetrieval.getConversation(orgId, conversation.uuid, true);
                    return ConversationRetrieval_1.ConversationRetrieval.conversationToMarkdown(conv);
                }
                catch (error) {
                    console.error("Failed to get conversation:", error);
                    throw error;
                }
            },
        }));
    }
    /**
     * Creates a markdown summary of a conversation
     * @param conversation - Conversation to summarize
     * @returns Markdown formatted summary
     */
    static createConversationSummary(conversation) {
        const sections = [];
        sections.push(`# ${conversation.name}\n`);
        sections.push(`UUID: ${conversation.uuid}`);
        sections.push(`Created: ${new Date(conversation.created_at).toLocaleString()}`);
        sections.push(`Updated: ${new Date(conversation.updated_at).toLocaleString()}`);
        sections.push(`\nMessage Count: ${conversation.message_count}`);
        if (conversation.summary) {
            sections.push(`\n## Summary\n${conversation.summary}`);
        }
        return sections.join("\n");
    }
    /**
     * Displays project conversations in the output element
     * @param docs - Documents to display
     * @param outputElement - Element to display documents in
     */
    static async displayConversations(docs, outputElement) {
        outputElement.innerHTML = "";
        const table = new DownloadTable_1.DownloadTable(outputElement, docs);
        table.render();
    }
    /**
     * Retrieves and displays conversations in the current project
     * @param outputElement - Element to display the conversations in
     * @param forceRefresh Force refresh from API instead of cache
     * @returns Promise that resolves when display is complete
     */
    static async displayCurrentProject(outputElement, forceRefresh = false) {
        try {
            const conversations = await this.getProjectConversations(forceRefresh);
            const docs = this.convertConversationsToDocumentInfo(conversations);
            if (docs.length === 0) {
                throw new Error("No conversations found in project");
            }
            await this.displayConversations(docs, outputElement);
        }
        catch (error) {
            throw new Error(`Failed to display project conversations: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
}
exports.ProjectRetrieval = ProjectRetrieval;
ProjectRetrieval.API_URL = "https://api.claude.ai/api/organizations";


/***/ }),

/***/ "./src/services/ProjectSearchService.ts":
/*!**********************************************!*\
  !*** ./src/services/ProjectSearchService.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/services/ProjectSearchService.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for searching through project conversations using semantic search with batching
 * Note: Finding needles in conversational haystacks, one batch at a time!
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProjectSearchService = void 0;
const ProjectRetrieval_1 = __webpack_require__(/*! ./ProjectRetrieval */ "./src/services/ProjectRetrieval.ts");
const ConversationRetrieval_1 = __webpack_require__(/*! ./ConversationRetrieval */ "./src/services/ConversationRetrieval.ts");
const getClaudeIds_1 = __webpack_require__(/*! ../utils/getClaudeIds */ "./src/utils/getClaudeIds.ts");
const DownloadTable_1 = __webpack_require__(/*! ../ui/components/DownloadTable */ "./src/ui/components/DownloadTable.ts");
const AnthropicService_1 = __webpack_require__(/*! ./AnthropicService */ "./src/services/AnthropicService.ts");
class ProjectSearchService {
    /**
     * Makes a completion request to Anthropic
     */
    static async makeCompletionRequest(prompt, signal) {
        console.log("[ProjectSearchService] Making completion request with prompt:", prompt);
        const messages = [
            {
                role: "user",
                content: prompt,
            },
        ];
        const result = await AnthropicService_1.AnthropicService.complete(messages, {
            temperature: 0.7,
            maxTokens: 2000,
            signal,
        });
        if (!result.success) {
            if (result.cancelled) {
                console.log("[ProjectSearchService] Request cancelled");
                return null;
            }
            console.error("[ProjectSearchService] Completion request failed:", result.error);
            throw new Error(result.error);
        }
        return result.text || null;
    }
    /**
     * Creates a DocumentInfo object for a conversation
     */
    static createDocumentInfo(conversation) {
        return {
            fileName: conversation.name,
            filePath: `${conversation.name.replace(/\s+/g, "-")}.md`,
            content: conversation.summary || "",
            isSelected: false,
            metadata: {
                conversationId: conversation.uuid,
                url: `https://claude.ai/chat/${conversation.uuid}`,
                created_at: conversation.created_at,
                updated_at: conversation.updated_at,
            },
            contentCallback: async (doc) => {
                const orgId = (0, getClaudeIds_1.getOrganizationId)();
                try {
                    const conv = await ConversationRetrieval_1.ConversationRetrieval.getConversation(orgId, conversation.uuid, true);
                    // Define message filter callback
                    const filterLongMessages = (message) => {
                        const content = this.formatMessageContent(message);
                        return content.length <= this.MAX_MESSAGE_LENGTH;
                    };
                    return ConversationRetrieval_1.ConversationRetrieval.conversationToMarkdown(conv, filterLongMessages);
                }
                catch (error) {
                    console.error("[ProjectSearchService] Failed to get conversation:", error);
                    throw error;
                }
            },
        };
    }
    /**
     * Aborts the current search operation if one is in progress
     */
    static abortSearch() {
        if (this.currentAbortController &&
            !this.currentAbortController.signal.aborted) {
            console.log("[ProjectSearchService] Aborting search...");
            this.isCancelling = true;
            this.currentAbortController.abort();
            // Update UI to show cancelling state for unprocessed rows
            if (this.currentTable) {
                const rows = document.querySelectorAll("tr[data-conversation-id]");
                rows.forEach((row) => {
                    const id = row.getAttribute("data-conversation-id");
                    if (id &&
                        this.currentTable &&
                        !this.currentTable.isRowProcessed(id)) {
                        this.currentTable.updateSearchResult(id, undefined, "Search cancelled");
                    }
                });
            }
        }
    }
    /**
     * Searches project conversations and displays results progressively
     */
    static async searchAndDisplayResults(searchText, outputElement, conversations) {
        let table = null;
        try {
            // Reset cancelling state and create new abort controller
            this.isCancelling = false;
            this.currentAbortController = new AbortController();
            const signal = this.currentAbortController.signal;
            console.log("[ProjectSearchService] Starting search with text:", searchText);
            // Get project conversations if not provided
            if (!conversations) {
                console.log("[ProjectSearchService] Fetching project conversations...");
                conversations = await ProjectRetrieval_1.ProjectRetrieval.getProjectConversations(true);
            }
            // Initialize table with just headers, passing false to disable Cancel button
            table = new DownloadTable_1.DownloadTable(outputElement, true, false);
            this.currentTable = table;
            // Add each conversation as a row
            for (const conv of conversations) {
                const docInfo = this.createDocumentInfo(conv);
                table.addRow(docInfo);
            }
            // If search text provided, process each conversation
            if (searchText) {
                console.log("[ProjectSearchService] Starting conversation processing...");
                const orgId = (0, getClaudeIds_1.getOrganizationId)();
                for (const conv of conversations) {
                    try {
                        // Check if search was aborted
                        if (signal.aborted) {
                            console.log("[ProjectSearchService] Search aborted");
                            break;
                        }
                        // Set working status
                        table.updateSearchResult(conv.uuid, undefined, "Working...");
                        // Get detailed conversation
                        const conversation = await ConversationRetrieval_1.ConversationRetrieval.getConversation(orgId, conv.uuid, true);
                        // Check again for abort after conversation retrieval
                        if (signal.aborted) {
                            console.log("[ProjectSearchService] Search aborted after conversation retrieval");
                            break;
                        }
                        // Process messages
                        const messages = conversation.chat_messages
                            .filter((msg) => {
                            const content = this.formatMessageContent(msg);
                            return (content.trim().length > 0 &&
                                content.length <= this.MAX_MESSAGE_LENGTH);
                        })
                            .map((msg) => ({
                            id: msg.uuid,
                            sender: msg.sender,
                            content: this.formatMessageContent(msg),
                        }));
                        // Create search prompt for this conversation
                        const prompt = `Here is a conversation. Please find if it contains information satisfying this search criteria and output a SearchResultInfo object: 
            <Criteria>${searchText}</Criteria>

${JSON.stringify({
                            id: conversation.uuid,
                            name: conversation.name,
                            messages: messages,
                        }, null, 2)}

If the conversation matches, return a SearchResultInfo object with this TypeScript type:
interface SearchResultInfo {
  conversationId: string;     // ID of the matching conversation
  messageId: string;          // UUID of the specific message that matches
  matchReason: string;        // Clear explanation of why this conversation matches
  relevantSnippet: string;    // The specific text snippet that matches (max 200 chars)
}

If the conversation does not match, return null. Return ONLY the JSON object or null, with no additional text or explanation.`;
                        // Check for abort before making completion request
                        if (signal.aborted) {
                            console.log("[ProjectSearchService] Search aborted before completion request");
                            break;
                        }
                        try {
                            // Make request and process response
                            const responseText = await this.makeCompletionRequest(prompt, signal);
                            // If request was cancelled
                            if (signal.aborted) {
                                console.log("[ProjectSearchService] Search aborted during completion request");
                                break;
                            }
                            if (!responseText) {
                                if (this.isCancelling) {
                                    break;
                                }
                                table.updateSearchResult(conv.uuid, undefined, "Failed to get response from API");
                                continue;
                            }
                            console.log(`[ProjectSearchService] Processing response for conversation ${conv.uuid}`);
                            try {
                                const result = JSON.parse(responseText);
                                if (result && result.conversationId) {
                                    // Valid result found, update the table and select the row
                                    table.updateSearchResult(conv.uuid, result, undefined, true);
                                }
                                else {
                                    // No match, clear any existing result and don't select
                                    table.updateSearchResult(conv.uuid, undefined, "No match found");
                                }
                            }
                            catch (error) {
                                const errorMessage = `Failed to parse search results: ${error instanceof Error ? error.message : "Unknown error"}`;
                                console.error(`[ProjectSearchService] ${errorMessage} for conversation ${conv.uuid}`);
                                table.updateSearchResult(conv.uuid, undefined, errorMessage);
                                continue;
                            }
                        }
                        catch (error) {
                            const errorMessage = error instanceof Error
                                ? error.message
                                : "Failed to get response from API";
                            console.error(`[ProjectSearchService] API request failed for conversation ${conv.uuid}:`, error);
                            table.updateSearchResult(conv.uuid, undefined, errorMessage);
                            continue;
                        }
                    }
                    catch (error) {
                        const errorMessage = `Failed to process conversation: ${error instanceof Error ? error.message : "Unknown error"}`;
                        console.error(`[ProjectSearchService] ${errorMessage} for conversation ${conv.uuid}:`, error);
                        table.updateSearchResult(conv.uuid, undefined, errorMessage);
                        continue;
                    }
                }
                // If search was cancelled, update any remaining unprocessed rows
                if (signal.aborted) {
                    for (const conv of conversations) {
                        if (!table.isRowProcessed(conv.uuid)) {
                            table.updateSearchResult(conv.uuid, undefined, "Search cancelled");
                        }
                    }
                }
            }
        }
        catch (error) {
            console.error("[ProjectSearchService] Search failed:", error);
            const errorMessage = error instanceof Error ? error.message : "Search failed";
            // Update all conversations with error status
            if (conversations && table) {
                for (const conv of conversations) {
                    table.updateSearchResult(conv.uuid, undefined, errorMessage);
                }
            }
        }
        finally {
            this.currentAbortController = null;
            this.isCancelling = false;
            this.currentTable = null;
        }
    }
    /**
     * Filters and formats message content
     */
    static formatMessageContent(message) {
        return message.content
            .filter((content) => {
            // Only include text content, exclude tools and artifacts
            return (content.type === "text" &&
                content.text &&
                !content.text.includes("antml:function_calls") &&
                !content.text.includes("antArtifact"));
        })
            .map((content) => content.text)
            .join("\n");
    }
}
exports.ProjectSearchService = ProjectSearchService;
ProjectSearchService.API_URL = "https://api.claude.ai/api/organizations";
ProjectSearchService.MAX_MESSAGE_LENGTH = 5000;
ProjectSearchService.currentAbortController = null;
ProjectSearchService.isCancelling = false;
ProjectSearchService.currentTable = null;


/***/ }),

/***/ "./src/services/PromptAll.ts":
/*!***********************************!*\
  !*** ./src/services/PromptAll.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/services/PromptAll.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for submitting prompts to multiple conversations sequentially
 * Note: Like a patient teacher - asking the same question to each student one at a time!
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromptAll = void 0;
const ProjectRetrieval_1 = __webpack_require__(/*! ./ProjectRetrieval */ "./src/services/ProjectRetrieval.ts");
const DownloadTable_1 = __webpack_require__(/*! ../ui/components/DownloadTable */ "./src/ui/components/DownloadTable.ts");
const requestCompletion_1 = __webpack_require__(/*! ../utils/requestCompletion */ "./src/utils/requestCompletion.ts");
/**
 * Service for managing prompts across multiple conversations
 */
class PromptAll {
    /**
     * Submits a prompt to a specific conversation
     * @param conversationId - ID of conversation to query
     * @param prompt - Prompt to submit
     * @returns Promise resolving to completion response
     */
    static async submitPrompt(conversationId, prompt) {
        try {
            const response = await (0, requestCompletion_1.requestCompletion)({
                prompt,
                conversationId,
                renderingMode: "json",
                stream: true,
            });
            return response.completion;
        }
        catch (error) {
            throw new Error(`Failed to submit prompt to conversation ${conversationId}: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Creates document info objects for display
     * @param conversations - Original conversations
     * @param results - Prompt results
     * @returns Array of document info objects
     */
    static createDocumentInfo(conversations, results) {
        // Create a map for quick result lookup
        const resultMap = new Map(results.map((result) => [result.conversationId, result]));
        return conversations.map((conv) => {
            const result = resultMap.get(conv.uuid);
            return {
                fileName: conv.name,
                filePath: `${conv.name.replace(/\s+/g, "-")}.md`,
                content: conv.summary || "",
                isSelected: false,
                metadata: {
                    conversationId: conv.uuid,
                    url: `https://claude.ai/chat/${conv.uuid}`,
                },
                searchResult: result
                    ? {
                        conversationId: conv.uuid,
                        messageId: "", // No specific message ID for prompt responses
                        matchReason: result.error || result.status || "Prompt response received",
                        relevantSnippet: result.response,
                    }
                    : {
                        conversationId: conv.uuid,
                        messageId: "",
                        matchReason: "Pending...",
                        relevantSnippet: "Waiting to process this conversation",
                    },
            };
        });
    }
    /**
     * Queries all conversations with a prompt and displays results progressively
     * @param prompt - Prompt to submit to all conversations
     * @param outputElement - Element to display results in
     * @param statusCallback - Optional callback for status updates
     */
    static async queryAndDisplayResults(prompt, outputElement, statusCallback) {
        try {
            console.log("Fetching project conversations...");
            const conversations = await ProjectRetrieval_1.ProjectRetrieval.getProjectConversations(true);
            if (conversations.length === 0) {
                throw new Error("No conversations found in project");
            }
            // Initialize results array
            const allResults = conversations.map((conv) => ({
                conversationId: conv.uuid,
                prompt,
                response: "",
                status: "Pending",
            }));
            // Initialize table with pending status for all conversations
            const docs = this.createDocumentInfo(conversations, allResults);
            const table = new DownloadTable_1.DownloadTable(outputElement, docs, true);
            table.render();
            // Process each conversation sequentially
            for (let i = 0; i < conversations.length; i++) {
                const conv = conversations[i];
                const progressMsg = `Processing conversation ${i + 1}/${conversations.length}: ${conv.name}`;
                if (statusCallback) {
                    statusCallback(progressMsg);
                }
                console.log(progressMsg);
                try {
                    const response = await this.submitPrompt(conv.uuid, prompt);
                    allResults[i] = {
                        conversationId: conv.uuid,
                        prompt,
                        response,
                        status: "Completed",
                    };
                }
                catch (error) {
                    allResults[i] = {
                        conversationId: conv.uuid,
                        prompt,
                        response: "",
                        error: error instanceof Error ? error.message : "Unknown error",
                        status: "Error",
                    };
                    console.error(`Error processing conversation ${conv.uuid}:`, error);
                }
                // Update UI after each conversation
                const updatedDocs = this.createDocumentInfo(conversations, allResults);
                table.updateItems(updatedDocs);
            }
            if (statusCallback) {
                statusCallback("All conversations processed");
            }
        }
        catch (error) {
            throw new Error(`Query failed: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
}
exports.PromptAll = PromptAll;


/***/ }),

/***/ "./src/services/ScriptExecutionManager.ts":
/*!************************************************!*\
  !*** ./src/services/ScriptExecutionManager.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/services/ScriptExecutionManager.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Manages script execution and state
 * Note: Keeping your scripts running smoothly since 2024!
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScriptExecutionManager = void 0;
const ScriptParser_1 = __webpack_require__(/*! ../utils/ScriptParser */ "./src/utils/ScriptParser.ts");
const ScriptRunner_1 = __webpack_require__(/*! ./ScriptRunner */ "./src/services/ScriptRunner.ts");
const CommandExecutor_1 = __webpack_require__(/*! ./CommandExecutor */ "./src/services/CommandExecutor.ts");
const ClaudeCache_1 = __webpack_require__(/*! ./ClaudeCache */ "./src/services/ClaudeCache.ts");
class ScriptExecutionManager {
    constructor(statusManager, handleLog, outputElement) {
        this.isExecuting = false;
        this.statusManager = statusManager;
        this.handleLog = handleLog;
        this.scriptRunner = new ScriptRunner_1.ScriptRunner(handleLog, new CommandExecutor_1.CommandExecutor(statusManager, handleLog, outputElement));
    }
    /**
     * Executes a script from raw text input
     * @param scriptText - Raw script text to execute
     * @throws Error if script execution fails
     */
    async executeScript(scriptText) {
        if (this.isExecuting) {
            this.handleLog("Cancelling current execution...", "info");
            this.cancel();
            return;
        }
        const text = scriptText.trim();
        if (!text) {
            this.handleLog("Please enter a script", "error");
            return;
        }
        try {
            this.isExecuting = true;
            // Clear cache at start of any new execution
            ClaudeCache_1.ClaudeCache.clearCache();
            this.handleLog("Cache cleared", "info");
            const script = ScriptParser_1.ScriptParser.parse(text);
            await this.statusManager.setStatus("working", "Running script...");
            await this.scriptRunner.runScript(script);
            await this.statusManager.setStatus("ready", "Complete");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Script error: ${message}`, "error");
            await this.statusManager.setStatus("error", message);
            setTimeout(() => this.statusManager.setStatus("ready"), 2000);
        }
        finally {
            this.isExecuting = false;
        }
    }
    /**
     * Cancels the current script execution
     */
    cancel() {
        if (this.isExecuting) {
            this.scriptRunner.cancel();
            this.isExecuting = false;
        }
    }
    /**
     * Checks if a script is currently executing
     * @returns True if script is executing
     */
    isScriptExecuting() {
        return this.isExecuting;
    }
}
exports.ScriptExecutionManager = ScriptExecutionManager;


/***/ }),

/***/ "./src/services/ScriptRunner.ts":
/*!**************************************!*\
  !*** ./src/services/ScriptRunner.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/services/ScriptRunner.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScriptRunner = void 0;
/**
 * Manages script execution and streaming state.
 */
class ScriptRunner {
    constructor(logCallback, commandExecutor) {
        this.isRunning = false;
        this.MAX_ATTEMPTS_WAIT_RESPONSE = 300;
        this.CHECK_INTERVAL = 100;
        this.logCallback = logCallback;
        this.commandExecutor = commandExecutor;
    }
    /**
     * Executes a command script
     * @param script - Parsed command script to execute
     * @throws Error if command execution fails
     */
    async executeCommand(script) {
        // Handle alias commands first
        if (script.aliasCommand) {
            await this.commandExecutor.handleAliasCommand(script);
            return;
        }
        // Handle other commands
        if (!script.command) {
            throw new Error("No command specified");
        }
        switch (script.command) {
            case "docs":
                await this.commandExecutor.handleDocsCommand();
                break;
            case "project":
                await this.commandExecutor.handleProjectCommand();
                break;
            case "search_project":
                await this.commandExecutor.handleSearchProjectCommand(script);
                break;
            case "query_project":
                await this.commandExecutor.handleQueryProjectCommand(script);
                break;
            case "conversation":
            case "artifacts":
                await this.commandExecutor.handleConversationCommand(script.options || {});
                break;
            default:
                throw new Error(`Unknown command: ${script.command}`);
        }
    }
    /**
     * Executes a script with the provided configuration.
     * @param script - Script configuration to execute
     * @throws Error if script execution fails
     */
    async runScript(script) {
        if (this.isRunning) {
            throw new Error("Script is already running");
        }
        try {
            this.isRunning = true;
            // Execute each statement in sequence
            let shouldContinue = true;
            for (const statement of script.statements) {
                if (!shouldContinue || !this.isRunning)
                    break;
                try {
                    if (statement.isCommand) {
                        await this.executeCommand(statement);
                        continue;
                    }
                    if (!statement.prompt) {
                        continue;
                    }
                    const response = await this.executePrompt(statement.prompt);
                    // Check all stop conditions
                    if (statement.options?.stopConditions?.length) {
                        const stopReason = this.checkStopConditions(response, statement.options?.stopConditions);
                        if (stopReason) {
                            this.logCallback(`Stop condition met: ${stopReason}`, "info");
                            shouldContinue = false;
                            break;
                        }
                    }
                }
                catch (error) {
                    this.logCallback(`Statement execution failed: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
                    return;
                }
            }
            // If all statements executed and no stop conditions met, we're done
            if (shouldContinue) {
                this.logCallback("Script completed successfully", "success");
                return;
            }
        }
        catch (error) {
            this.logCallback(`Script execution failed: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
            throw error;
        }
        finally {
            this.isRunning = false;
        }
    }
    /**
     * Executes a single statement and waits for response
     * @param prompt - Prompt text to execute
     * @returns The response text
     * @throws Error if execution fails
     */
    async executePrompt(prompt) {
        const targetDiv = await this.findInputElement();
        await this.insertPrompt(prompt);
        await this.simulateEnterKey(targetDiv);
        return await this.checkStreaming();
    }
    /**
     * Checks stop conditions against a response
     * @param response - Response text to check
     * @param stopConditions - Array of conditions to check
     * @returns The matching condition or null if none match
     */
    checkStopConditions(response, stopConditions) {
        for (const condition of stopConditions) {
            const contained = response.includes(condition.target);
            if ((condition.type === "if" && contained) ||
                (condition.type === "if_not" && !contained)) {
                return `${condition.type} ${condition.target}`;
            }
        }
        return null;
    }
    /**
     * Monitors the streaming state of Claude's response.
     * @returns The final response text
     * @throws Error if monitoring times out
     */
    async checkStreaming() {
        let stableCount = 0;
        let attempts = 0;
        let lastContent = "";
        let lastStreamingDiv = null;
        while (attempts < this.MAX_ATTEMPTS_WAIT_RESPONSE && this.isRunning) {
            const streamingDiv = document.querySelector('div[data-is-streaming="true"]');
            if (streamingDiv) {
                if (streamingDiv.textContent !== lastContent) {
                    stableCount = 0;
                    lastContent = streamingDiv.textContent || "";
                    lastStreamingDiv = streamingDiv;
                }
                else {
                    stableCount++;
                }
            }
            else if (lastStreamingDiv) {
                return lastStreamingDiv.textContent || "";
            }
            else {
                stableCount++;
            }
            if (stableCount >= 20) {
                return lastContent;
            }
            await new Promise((resolve) => setTimeout(resolve, this.CHECK_INTERVAL));
            attempts++;
        }
        if (!this.isRunning) {
            throw new Error("Operation cancelled");
        }
        throw new Error("Response timeout");
    }
    /**
     * Finds the input element for script execution.
     * @returns Promise resolving to the input element
     * @throws Error if element not found
     */
    async findInputElement() {
        const targetDiv = document.querySelector('div[enterkeyhint="enter"]');
        if (!targetDiv) {
            throw new Error("Input element not found");
        }
        return targetDiv;
    }
    /**
     * Inserts or updates prompt text in the input element
     * @param text - Text to insert
     */
    async insertPrompt(text) {
        const targetDiv = await this.findInputElement();
        const paragraphs = targetDiv.querySelectorAll("p");
        if (paragraphs.length === 1 &&
            paragraphs[0].hasAttribute("data-placeholder")) {
            // Empty state - replace content
            paragraphs[0].innerHTML = text;
        }
        else {
            // Has content - append new paragraph
            const newP = document.createElement("p");
            newP.innerHTML = text;
            targetDiv.appendChild(newP);
        }
        targetDiv.focus();
        await new Promise((resolve) => setTimeout(resolve, 100));
    }
    /**
     * Simulates pressing the Enter key.
     * @param element - Element to receive the key event
     */
    simulateEnterKey(element) {
        const events = [
            new KeyboardEvent("keydown", {
                key: "Enter",
                code: "Enter",
                keyCode: 13,
                which: 13,
                bubbles: true,
            }),
            new KeyboardEvent("keypress", {
                key: "Enter",
                code: "Enter",
                keyCode: 13,
                which: 13,
                bubbles: true,
            }),
            new KeyboardEvent("keyup", {
                key: "Enter",
                code: "Enter",
                keyCode: 13,
                which: 13,
                bubbles: true,
            }),
        ];
        events.forEach((event) => element.dispatchEvent(event));
    }
    /**
     * Cancels the currently running script.
     */
    cancel() {
        this.isRunning = false;
    }
}
exports.ScriptRunner = ScriptRunner;


/***/ }),

/***/ "./src/services/SettingsService.ts":
/*!*****************************************!*\
  !*** ./src/services/SettingsService.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/services/SettingsService.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingsService = void 0;
/**
 * Service for managing extension settings using Chrome's storage sync API
 * with local storage fallback in development mode
 */
class SettingsService {
    /**
     * Gets settings from local storage (dev mode only)
     */
    static getLocalSettings() {
        if (!this.IS_DEV_MODE)
            return {};
        try {
            const stored = localStorage.getItem(this.STORAGE_KEY);
            if (!stored)
                return {};
            return JSON.parse(stored);
        }
        catch (e) {
            console.error("Failed to parse local settings:", e);
            return {};
        }
    }
    /**
     * Saves settings to local storage (dev mode only)
     */
    static setLocalSettings(settings) {
        if (!this.IS_DEV_MODE)
            return;
        try {
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(settings));
            console.log("[Dev Mode] Saved settings to localStorage:", settings);
        }
        catch (e) {
            console.error("Failed to save local settings:", e);
        }
    }
    /**
     * Gets all settings from Chrome sync storage
     * Falls back to local storage in dev mode if Chrome storage is empty
     */
    static async getSettings() {
        return new Promise((resolve) => {
            chrome.storage.sync.get([this.STORAGE_KEY], (result) => {
                const settings = result[this.STORAGE_KEY] || {};
                // In dev mode, merge with local storage settings
                if (this.IS_DEV_MODE) {
                    const localSettings = this.getLocalSettings();
                    const mergedSettings = { ...settings, ...localSettings };
                    console.log("[Dev Mode] Using merged settings:", mergedSettings);
                    resolve(mergedSettings);
                }
                else {
                    resolve(settings);
                }
            });
        });
    }
    /**
     * Sets a setting value in Chrome sync storage
     * Also saves to local storage in dev mode
     */
    static async setSetting(key, value) {
        const settings = await this.getSettings();
        settings[key] = value;
        // In dev mode, also save to local storage
        if (this.IS_DEV_MODE) {
            this.setLocalSettings(settings);
        }
        // Always save to chrome.storage.sync
        return new Promise((resolve) => {
            chrome.storage.sync.set({ [this.STORAGE_KEY]: settings }, () => {
                if (this.IS_DEV_MODE) {
                    console.log("[Dev Mode] Saved settings to chrome.storage:", settings);
                }
                resolve();
            });
        });
    }
    /**
     * Gets a single setting value
     */
    static async getSetting(key) {
        const settings = await this.getSettings();
        return settings[key] || (key === "model" ? this.DEFAULT_MODEL : undefined);
    }
    /**
     * Validates an Anthropic API key format
     * @returns Error message if invalid, null if valid
     */
    static validateApiKey(key) {
        if (!key) {
            return "API key is required";
        }
        if (!key.startsWith("sk-ant-")) {
            return 'Invalid API key format. Must start with "sk-ant-"';
        }
        if (key.length < 32) {
            return "API key appears too short";
        }
        return null;
    }
    /**
     * Validates a model name format
     * @returns Error message if invalid, null if valid
     */
    static validateModel(model) {
        if (!model) {
            return "Model is required";
        }
        if (!model.startsWith("claude-")) {
            return 'Invalid model format. Must start with "claude-"';
        }
        return null;
    }
    /**
     * Validates that required settings are configured
     */
    static async validateSettings() {
        const settings = await this.getSettings();
        if (!settings.anthropicApiKey) {
            return {
                valid: false,
                message: "Please configure your Anthropic API key in the extension settings",
            };
        }
        const keyError = this.validateApiKey(settings.anthropicApiKey);
        if (keyError) {
            return {
                valid: false,
                message: `Invalid API key: ${keyError}`,
            };
        }
        return { valid: true };
    }
}
exports.SettingsService = SettingsService;
SettingsService.STORAGE_KEY = "anthropic_api_settings";
SettingsService.IS_DEV_MODE = "development" === "development";
SettingsService.DEFAULT_MODEL = "claude-3-5-sonnet-20241022";


/***/ }),

/***/ "./src/services/WindowStateService.ts":
/*!********************************************!*\
  !*** ./src/services/WindowStateService.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/services/WindowStateService.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for managing and persisting window state
 * Note: Remembering your window preferences, so you don't have to!
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WindowStateService = void 0;
class WindowStateService {
    /**
     * Loads the saved window state from storage
     */
    static loadState() {
        try {
            const savedState = localStorage.getItem(this.STORAGE_KEY);
            if (savedState) {
                return JSON.parse(savedState);
            }
        }
        catch (error) {
            console.error("Failed to load window state:", error);
        }
        return { ...this.DEFAULT_STATE };
    }
    /**
     * Saves the current window state to storage
     */
    static saveState(state) {
        try {
            const currentState = this.loadState();
            const newState = { ...currentState, ...state };
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(newState));
        }
        catch (error) {
            console.error("Failed to save window state:", error);
        }
    }
    static saveMode(isScriptMode) {
        this.saveState({ isScriptMode });
    }
    /**
     * Updates window position
     */
    static savePosition(x, y) {
        this.saveState({ x, y });
    }
    /**
     * Updates window dimensions
     */
    static saveGeometry(width, height) {
        this.saveState({ width, height });
    }
    /**
     * Updates script textarea height
     */
    static saveScriptHeight(height) {
        this.saveState({ scriptHeight: height });
    }
    /**
     * Updates window state flags
     */
    static saveWindowState(isMinimized, isCollapsed) {
        this.saveState({ isMinimized, isCollapsed });
    }
    /**
     * Applies saved state to window element
     */
    static applyState(windowElement, scriptElement) {
        const state = this.loadState();
        // Set absolute positioning
        windowElement.style.position = "absolute";
        windowElement.style.right = "auto"; // Clear any right positioning
        // Always apply position, even when minimized
        windowElement.style.left = `${state.x}px`;
        windowElement.style.top = `${state.y}px`;
        // Apply dimensions if not minimized
        if (!state.isMinimized) {
            windowElement.style.width = state.width;
            windowElement.style.height = state.height;
        }
        else {
            // Clear dimensions but maintain position when minimized
            windowElement.style.width = "";
            windowElement.style.height = "";
            windowElement.classList.add("minimized");
        }
        // Apply script height if element provided
        if (scriptElement && state.scriptHeight) {
            scriptElement.style.height = state.scriptHeight;
        }
        // Handle collapse state
        if (state.isCollapsed) {
            const outputDiv = windowElement.querySelector("#scriptOutput");
            if (outputDiv) {
                outputDiv.style.maxHeight = "3em";
                outputDiv.style.overflowY = "hidden";
            }
        }
    }
}
exports.WindowStateService = WindowStateService;
WindowStateService.STORAGE_KEY = "claude_extension_window_state";
WindowStateService.DEFAULT_STATE = {
    x: 20,
    y: 20,
    width: "400px",
    height: "500px",
    isMinimized: false,
    isCollapsed: false,
    scriptHeight: "100px",
    isScriptMode: false,
};


/***/ }),

/***/ "./src/types/index.ts":
/*!****************************!*\
  !*** ./src/types/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/types/index.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScriptStatement = void 0;
class ScriptStatement {
    constructor(props) {
        this.prompt = props.prompt;
        this.isCommand = props.isCommand;
        this.command = props.command;
        this.options = props.options || {};
        this.searchText = props.searchText;
        this.aliasCommand = props.aliasCommand;
    }
    addStopCondition(stopCondition) {
        let conditions = this.options["stopConditions"];
        if (!conditions) {
            this.options["stopConditions"] = conditions = [];
        }
        conditions.push(stopCondition);
    }
}
exports.ScriptStatement = ScriptStatement;


/***/ }),

/***/ "./src/types/storage.ts":
/*!******************************!*\
  !*** ./src/types/storage.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/types/storage.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemoryStorage = exports.BrowserStorage = void 0;
/**
 * Browser localStorage implementation of IStorage
 */
class BrowserStorage {
    getItem(key) {
        return localStorage.getItem(key);
    }
    setItem(key, value) {
        localStorage.setItem(key, value);
    }
    removeItem(key) {
        localStorage.removeItem(key);
    }
}
exports.BrowserStorage = BrowserStorage;
/**
 * In-memory storage implementation for testing
 */
class MemoryStorage {
    constructor() {
        this.storage = new Map();
    }
    getItem(key) {
        return this.storage.get(key) || null;
    }
    setItem(key, value) {
        this.storage.set(key, value);
    }
    removeItem(key) {
        this.storage.delete(key);
    }
}
exports.MemoryStorage = MemoryStorage;


/***/ }),

/***/ "./src/ui/components/ContentPreview.ts":
/*!*********************************************!*\
  !*** ./src/ui/components/ContentPreview.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/ContentPreview.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContentPreview = void 0;
const styles = {
    colors: {
        primary: "#0066cc",
        border: "#ccc",
        text: "#333",
        background: "#fff",
        overlay: "rgba(0, 0, 0, 0.5)",
        codeBg: "#f5f5f5",
    },
    spacing: {
        sm: "8px",
        md: "16px",
        lg: "24px",
    },
    borderRadius: "8px",
    fontSize: {
        sm: "14px",
        md: "16px",
        lg: "18px",
    },
};
class ContentPreview {
    constructor() {
        this.isOpen = false;
        // Initialize elements in constructor
        this.dialog = document.createElement("div");
        this.content = document.createElement("div");
        this.createDialog();
    }
    createDialog() {
        // Create overlay container
        this.dialog.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: ${styles.colors.overlay};
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000000;
      `;
        // Create content container
        this.content.style.cssText = `
        background: ${styles.colors.background};
        border-radius: ${styles.borderRadius};
        width: 800px;
        max-width: 90%;
        max-height: 80vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        position: relative;
      `;
        this.dialog.appendChild(this.content);
        document.body.appendChild(this.dialog);
        // Close on background click
        this.dialog.addEventListener("click", (e) => {
            if (e.target === this.dialog) {
                this.close();
            }
        });
        // Close on escape key
        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && this.isOpen) {
                this.close();
            }
        });
    }
    getLanguageFromFileName(fileName) {
        const ext = fileName.split(".").pop()?.toLowerCase() || "";
        const languageMap = {
            js: "javascript",
            ts: "typescript",
            jsx: "javascript",
            tsx: "typescript",
            py: "python",
            java: "java",
            rb: "ruby",
            go: "go",
            rs: "rust",
            cpp: "cpp",
            c: "c",
            cs: "csharp",
            php: "php",
            html: "html",
            css: "css",
            json: "json",
            md: "markdown",
            yml: "yaml",
            yaml: "yaml",
            xml: "xml",
            sql: "sql",
            sh: "bash",
            bash: "bash",
        };
        return languageMap[ext] || "plaintext";
    }
    createCloseButton() {
        const button = document.createElement("button");
        button.innerHTML = "";
        button.style.cssText = `
        position: absolute;
        top: ${styles.spacing.sm};
        right: ${styles.spacing.sm};
        font-size: ${styles.fontSize.lg};
        border: none;
        background: none;
        color: ${styles.colors.text};
        cursor: pointer;
        padding: ${styles.spacing.sm};
        border-radius: 4px;
        z-index: 1;
      `;
        button.addEventListener("mouseover", () => {
            button.style.backgroundColor = styles.colors.codeBg;
        });
        button.addEventListener("mouseout", () => {
            button.style.backgroundColor = "transparent";
        });
        button.addEventListener("click", () => this.close());
        return button;
    }
    show(title, content, fileName) {
        // Reset content
        this.content.innerHTML = "";
        // Create header
        const header = document.createElement("div");
        header.style.cssText = `
        padding: ${styles.spacing.md} ${styles.spacing.lg};
        border-bottom: 1px solid ${styles.colors.border};
      `;
        const titleElement = document.createElement("h2");
        titleElement.style.cssText = `
        margin: 0;
        font-size: ${styles.fontSize.lg};
        font-weight: 600;
        color: ${styles.colors.text};
      `;
        titleElement.textContent = title;
        header.appendChild(titleElement);
        // Create content container
        const contentContainer = document.createElement("div");
        contentContainer.style.cssText = `
        padding: ${styles.spacing.md};
        overflow-y: auto;
        flex: 1;
        min-height: 200px;
        max-height: calc(80vh - 100px);
        background: ${styles.colors.codeBg};
        font-family: monospace;
        white-space: pre;
        font-size: ${styles.fontSize.sm};
        line-height: 1.5;
      `;
        // Add content as code block if applicable
        const language = this.getLanguageFromFileName(fileName);
        if (language !== "plaintext") {
            contentContainer.className = `language-${language}`;
            // Apply syntax highlighting if Prism is available
            if (window.Prism && window.Prism.languages[language]) {
                contentContainer.innerHTML = window.Prism.highlight(content, window.Prism.languages[language], language);
            }
            else {
                contentContainer.textContent = content;
            }
        }
        else {
            contentContainer.textContent = content;
        }
        // Add close button
        const closeButton = this.createCloseButton();
        // Assemble dialog
        this.content.appendChild(closeButton);
        this.content.appendChild(header);
        this.content.appendChild(contentContainer);
        // Show dialog with animation
        this.dialog.style.display = "flex";
        this.dialog.style.opacity = "0";
        setTimeout(() => {
            this.dialog.style.transition = "opacity 0.2s ease-out";
            this.dialog.style.opacity = "1";
        }, 0);
        this.isOpen = true;
    }
    close() {
        if (!this.isOpen)
            return;
        this.dialog.style.opacity = "0";
        setTimeout(() => {
            this.dialog.style.display = "none";
            this.content.innerHTML = "";
        }, 200);
        this.isOpen = false;
    }
    destroy() {
        this.dialog.remove();
    }
}
exports.ContentPreview = ContentPreview;


/***/ }),

/***/ "./src/ui/components/ConversationPreview.ts":
/*!**************************************************!*\
  !*** ./src/ui/components/ConversationPreview.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/ConversationPreview.ts
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConversationPreview = void 0;
const ContentPreview_1 = __webpack_require__(/*! ./ContentPreview */ "./src/ui/components/ContentPreview.ts");
class ConversationPreview {
    constructor() {
        this.dialog = document.createElement("div");
        this.content = document.createElement("div");
        this.messagesContainer = null;
        this.isOpen = false;
        this.createDialog();
        this.contentPreview = new ContentPreview_1.ContentPreview();
    }
    /**
     * Creates the dialog structure
     */
    createDialog() {
        // Create floating container
        this.dialog.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 1000003;
      pointer-events: auto;
    `;
        // Create dialog content container
        this.content.style.cssText = `
      background: white;
      border-radius: 8px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      position: relative;
      margin: 20px;
      pointer-events: auto;
    `;
        this.dialog.appendChild(this.content);
        document.body.appendChild(this.dialog);
        // Close on escape key
        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && this.isOpen) {
                this.close();
            }
        });
    }
    /**
     * Shows the preview dialog with conversation content
     */
    show(title, messages, conversationUrl, scrollToMessageId) {
        // Reset content
        this.content.innerHTML = "";
        // Create header
        const header = document.createElement("div");
        header.style.cssText = `
      padding: 16px 20px;
      border-bottom: 1px solid #e5e5e5;
    `;
        const titleElement = document.createElement("h2");
        titleElement.style.cssText = `
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: #333;
    `;
        // Make title a link if URL is provided
        if (conversationUrl) {
            const titleLink = document.createElement("a");
            titleLink.href = conversationUrl;
            titleLink.target = "_blank";
            titleLink.textContent = title;
            titleLink.style.cssText = `
        color: inherit;
        text-decoration: none;
        transition: color 0.2s ease;
      `;
            titleLink.addEventListener("mouseover", () => {
                titleLink.style.color = "#0066cc";
            });
            titleLink.addEventListener("mouseout", () => {
                titleLink.style.color = "#333";
            });
            titleElement.appendChild(titleLink);
        }
        else {
            titleElement.textContent = title;
        }
        // Count artifacts
        let artifactCount = 0;
        messages.forEach((message) => {
            message.content.forEach((item) => {
                if (item.type === "tool_use" && item.input) {
                    artifactCount++;
                }
            });
        });
        const subtitle = document.createElement("div");
        subtitle.style.cssText = `
      font-size: 14px;
      color: #666;
      margin-top: 4px;
    `;
        subtitle.textContent = `${messages.length} messages, ${artifactCount} artifacts in conversation`;
        header.appendChild(titleElement);
        header.appendChild(subtitle);
        // Create close button
        const closeButton = document.createElement("button");
        closeButton.innerHTML = "";
        closeButton.style.cssText = `
      position: absolute;
      top: 12px;
      right: 12px;
      font-size: 24px;
      border: none;
      background: none;
      color: #666;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
    `;
        closeButton.addEventListener("mouseover", () => {
            closeButton.style.backgroundColor = "#f0f0f0";
        });
        closeButton.addEventListener("mouseout", () => {
            closeButton.style.backgroundColor = "transparent";
        });
        closeButton.addEventListener("click", () => this.close());
        // Create messages container
        this.messagesContainer = document.createElement("div");
        this.messagesContainer.style.cssText = `
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      min-height: 200px;
      max-height: calc(80vh - 100px);
      scroll-behavior: smooth;
    `;
        // Add messages
        messages.forEach((message) => {
            if (this.messagesContainer) {
                this.messagesContainer.appendChild(this.createMessageBubble(message));
            }
        });
        // Assemble dialog
        this.content.appendChild(closeButton);
        this.content.appendChild(header);
        if (this.messagesContainer) {
            this.content.appendChild(this.messagesContainer);
        }
        // Show dialog with animation
        this.dialog.style.display = "flex";
        this.dialog.style.opacity = "0";
        setTimeout(() => {
            this.dialog.style.transition = "opacity 0.2s ease-out";
            this.dialog.style.opacity = "1";
            // Scroll to message if ID is provided
            if (scrollToMessageId && this.messagesContainer) {
                const messageElement = this.messagesContainer.querySelector(`#message-${scrollToMessageId}`);
                if (messageElement) {
                    const htmlMessageElement = messageElement;
                    htmlMessageElement.scrollIntoView({
                        behavior: "smooth",
                        block: "center",
                    });
                    // Highlight the message briefly
                    htmlMessageElement.style.transition = "background-color 0.5s ease";
                    htmlMessageElement.style.backgroundColor = "rgba(0, 102, 204, 0.1)";
                    setTimeout(() => {
                        htmlMessageElement.style.backgroundColor = "transparent";
                    }, 1500);
                }
            }
            else {
                // Default: scroll to bottom of messages
                if (this.messagesContainer) {
                    this.messagesContainer.scrollTop =
                        this.messagesContainer.scrollHeight;
                }
            }
        }, 0);
        this.isOpen = true;
    }
    /**
     * Creates a message bubble element
     */
    createMessageBubble(message) {
        const isHuman = message.sender === "human";
        const container = document.createElement("div");
        container.style.cssText = `
      display: flex;
      flex-direction: column;
      align-items: ${isHuman ? "flex-end" : "flex-start"};
      margin-bottom: 16px;
    `;
        container.id = `message-${message.uuid}`; // Add message ID
        const bubble = document.createElement("div");
        bubble.style.cssText = `
      max-width: 80%;
      padding: 8px 16px;
      border-radius: 12px;
      ${isHuman
            ? `
        background: #0066cc;
        color: white;
        border-bottom-right-radius: 4px;
      `
            : `
        background: #f0f0f0;
        color: #333;
        border-bottom-left-radius: 4px;
      `}
    `;
        // Add message content
        message.content.forEach((item) => {
            if (item.type === "text" && item.text) {
                const textDiv = document.createElement("div");
                textDiv.style.whiteSpace = "pre-wrap";
                textDiv.textContent = item.text;
                bubble.appendChild(textDiv);
            }
            else if (item.type === "tool_use" && item.input) {
                const artifactBubble = this.createArtifactBubble(item.input);
                bubble.appendChild(artifactBubble);
            }
        });
        container.appendChild(bubble);
        // Add timestamp
        const timestamp = document.createElement("div");
        timestamp.style.cssText = `
      font-size: 0.8em;
      color: #666;
      margin-top: 4px;
      ${isHuman ? "text-align: right;" : "text-align: left;"}
    `;
        const date = new Date(message.created_at);
        timestamp.textContent = date.toLocaleString(undefined, {
            year: "numeric",
            month: "short",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit",
        });
        container.appendChild(timestamp);
        return container;
    }
    /**
     * Creates a summary of changes for update artifacts
     */
    createChangesSummary(oldStr, newStr) {
        const container = document.createElement("div");
        container.style.cssText = `
      margin-top: 8px;
      font-size: 0.9em;
      color: #666;
    `;
        const oldLines = oldStr.split("\n");
        const newLines = newStr.split("\n");
        const removed = oldLines.filter((line) => !newLines.includes(line)).length;
        const added = newLines.filter((line) => !oldLines.includes(line)).length;
        const summary = document.createElement("div");
        summary.style.cssText = `
      display: flex;
      gap: 16px;
      margin-top: 8px;
    `;
        if (added > 0) {
            const addedDiv = document.createElement("div");
            addedDiv.style.cssText = "color: #28a745;";
            addedDiv.textContent = `+${added} added`;
            summary.appendChild(addedDiv);
        }
        if (removed > 0) {
            const removedDiv = document.createElement("div");
            removedDiv.style.cssText = "color: #dc3545;";
            removedDiv.textContent = `${removed} removed`;
            summary.appendChild(removedDiv);
        }
        container.appendChild(summary);
        return container;
    }
    /**
     * Shows artifact content in a separate preview window
     */
    showArtifactContent(input) {
        const isUpdate = input.command === "update";
        if (isUpdate) {
            // For updates, show a diff view
            const diffContent = this.createDiffDisplay(input.old_str || "", input.new_str || "");
            const fileName = input.title
                ? input.title + " (Update)"
                : "artifact-update";
            this.contentPreview.show(fileName, diffContent, fileName + ".diff");
        }
        else if (input.content) {
            // For regular artifacts, show the content
            const extension = input.language
                ? this.getFileExtension(input.language)
                : ".txt";
            const fileName = input.title
                ? input.title.endsWith(extension)
                    ? input.title
                    : input.title + extension
                : "artifact" + extension;
            this.contentPreview.show(fileName, input.content, fileName);
        }
    }
    /**
     * Creates a diff display for update artifacts
     */
    createDiffDisplay(oldStr, newStr) {
        const oldLines = oldStr.split("\n");
        const newLines = newStr.split("\n");
        const diff = [];
        // Simple diff display
        diff.push("--- Previous version");
        diff.push("+++ New version");
        diff.push("");
        // Show removed lines
        oldLines.forEach((line) => {
            if (!newLines.includes(line)) {
                diff.push("- " + line);
            }
        });
        // Show added lines
        newLines.forEach((line) => {
            if (!oldLines.includes(line)) {
                diff.push("+ " + line);
            }
        });
        return diff.join("\n");
    }
    /**
     * Gets appropriate file extension based on language
     */
    getFileExtension(language) {
        const extensionMap = {
            typescript: ".ts",
            javascript: ".js",
            python: ".py",
            java: ".java",
            "text/markdown": ".md",
            "application/json": ".json",
            html: ".html",
            css: ".css",
            "text/html": ".html",
            "application/vnd.ant.code": ".txt",
            "application/vnd.ant.react": ".tsx",
            "application/vnd.ant.mermaid": ".mmd",
            "image/svg+xml": ".svg",
        };
        return extensionMap[language.toLowerCase()] || ".txt";
    }
    /**
     * Creates an artifact bubble for messages
     */
    createArtifactBubble(input) {
        const artifactContainer = document.createElement("div");
        artifactContainer.style.cssText = `
      background: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 12px;
      margin: 8px 0;
    `;
        const title = document.createElement("div");
        title.style.cssText = `
      font-weight: bold;
      color: #333;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
    `;
        const isUpdate = input.command === "update";
        const titleText = document.createElement("span");
        titleText.textContent = `Artifact: ${input.title || "Untitled"}`;
        title.appendChild(titleText);
        if (isUpdate) {
            const updateBadge = document.createElement("span");
            updateBadge.style.cssText = `
        background: #0066cc;
        color: white;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 0.8em;
      `;
            updateBadge.textContent = "UPDATE";
            title.appendChild(updateBadge);
        }
        artifactContainer.appendChild(title);
        if (input.language) {
            const language = document.createElement("div");
            language.style.cssText = `
        color: #666;
        font-size: 0.9em;
        margin-bottom: 8px;
      `;
            language.textContent = `Language: ${input.language}`;
            artifactContainer.appendChild(language);
        }
        // Create a button-like container for the artifact preview
        const previewButton = document.createElement("div");
        previewButton.style.cssText = `
      background: #eee;
      padding: 12px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.9em;
      color: #666;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      border: 1px solid #ddd;
    `;
        // Add an icon
        const icon = document.createElement("span");
        icon.textContent = isUpdate ? "" : ""; // Update or eye icon
        icon.style.fontSize = "1.1em";
        previewButton.appendChild(icon);
        const text = document.createElement("span");
        text.textContent = isUpdate
            ? "Click to view changes"
            : "Click to view artifact content";
        previewButton.appendChild(text);
        // Add hover effect
        previewButton.addEventListener("mouseover", () => {
            previewButton.style.backgroundColor = "#e0e0e0";
            previewButton.style.transform = "translateY(-1px)";
        });
        previewButton.addEventListener("mouseout", () => {
            previewButton.style.backgroundColor = "#eee";
            previewButton.style.transform = "translateY(0)";
        });
        // Add click handler
        previewButton.addEventListener("click", (e) => {
            e.stopPropagation(); // Prevent event bubbling
            this.showArtifactContent(input);
        });
        artifactContainer.appendChild(previewButton);
        // For updates, show a summary of changes
        if (isUpdate && input.old_str && input.new_str) {
            const changesSummary = this.createChangesSummary(input.old_str, input.new_str);
            artifactContainer.appendChild(changesSummary);
        }
        return artifactContainer;
    }
    /**
     * Closes the preview dialog
     */
    close() {
        if (!this.isOpen)
            return;
        this.dialog.style.opacity = "0";
        setTimeout(() => {
            this.dialog.style.display = "none";
            this.content.innerHTML = "";
            this.messagesContainer = null;
        }, 200);
        this.isOpen = false;
    }
    /**
     * Cleans up the component
     */
    destroy() {
        this.dialog.remove();
    }
}
exports.ConversationPreview = ConversationPreview;


/***/ }),

/***/ "./src/ui/components/DownloadTable.ts":
/*!********************************************!*\
  !*** ./src/ui/components/DownloadTable.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/DownloadTable.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * A reusable component for displaying and managing downloadable documents with path editing
 * Note: Making document management a breeze since 2024!
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DownloadTable = void 0;
const DocumentDownload_1 = __webpack_require__(/*! ../../services/DocumentDownload */ "./src/services/DocumentDownload.ts");
const ConversationPreview_1 = __webpack_require__(/*! ./ConversationPreview */ "./src/ui/components/ConversationPreview.ts");
const ContentPreview_1 = __webpack_require__(/*! ./ContentPreview */ "./src/ui/components/ContentPreview.ts");
const ConversationRetrieval_1 = __webpack_require__(/*! ../../services/ConversationRetrieval */ "./src/services/ConversationRetrieval.ts");
const getClaudeIds_1 = __webpack_require__(/*! ../../utils/getClaudeIds */ "./src/utils/getClaudeIds.ts");
const ProjectSearchService_1 = __webpack_require__(/*! ../../services/ProjectSearchService */ "./src/services/ProjectSearchService.ts");
const SearchResultPreview_1 = __webpack_require__(/*! ./SearchResultPreview */ "./src/ui/components/SearchResultPreview.ts");
const DownloadWidgets_1 = __webpack_require__(/*! ./DownloadWidgets */ "./src/ui/components/DownloadWidgets.ts");
/**
 * Component for displaying and managing downloadable documents in a table format
 */
class DownloadTable {
    constructor(container, itemsOrShowResults = false, showCancelButton = true) {
        this.currentTable = null;
        this.currentSortColumn = null;
        this.currentSortDirection = null;
        this.tbody = null;
        this.processedRows = new Set();
        this.container = container;
        // Handle backward compatibility
        if (Array.isArray(itemsOrShowResults)) {
            this.items = itemsOrShowResults;
            this.showResults = false;
        }
        else {
            this.items = [];
            this.showResults = itemsOrShowResults;
        }
        this.showCancelButton = showCancelButton;
        this.previewDialog = new ConversationPreview_1.ConversationPreview();
        this.contentPreview = new ContentPreview_1.ContentPreview();
        // Initialize SearchResultPreview with conversation preview callback
        this.searchResultPreview = new SearchResultPreview_1.SearchResultPreview(async (conversationId, messageId) => {
            try {
                const orgId = (0, getClaudeIds_1.getOrganizationId)();
                if (!orgId) {
                    throw new Error("Unable to get organization ID");
                }
                const conversation = await ConversationRetrieval_1.ConversationRetrieval.getConversation(orgId, conversationId, true // Force refresh
                );
                this.previewDialog.show(conversation.name || "Conversation Preview", conversation.chat_messages, undefined, messageId);
            }
            catch (error) {
                console.error("Failed to load conversation:", error);
                throw error;
            }
        });
        this.initializeTable();
        // If items were provided, add them all at once
        if (Array.isArray(itemsOrShowResults)) {
            this.items.forEach((item, index) => {
                const row = this.createItemRow(item, index);
                this.tbody?.appendChild(row);
            });
        }
    }
    /**
     * Checks if a row has been processed
     */
    isRowProcessed(conversationId) {
        return this.processedRows.has(conversationId);
    }
    /**
     * Initializes the table with just the headers
     */
    initializeTable() {
        this.container.innerHTML = "";
        // Add cancel button before the table if showing results and cancel button is enabled
        if (this.showResults && this.showCancelButton) {
            const cancelButton = (0, DownloadWidgets_1.createButton)("Cancel", () => {
                ProjectSearchService_1.ProjectSearchService.abortSearch();
            }, { variant: "danger" });
            cancelButton.style.marginBottom = "10px";
            this.container.appendChild(cancelButton);
        }
        const table = this.createTable();
        const headerRow = this.createTableHeader(table);
        table.appendChild(headerRow);
        this.tbody = table.createTBody();
        table.appendChild(this.tbody);
        this.container.appendChild(table);
        this.currentTable = table;
        this.addDownloadButtons();
    }
    /**
     * Adds a new row to the table
     */
    addRow(item) {
        if (!this.tbody)
            return;
        this.items.push(item);
        const row = this.createItemRow(item, this.items.length - 1);
        this.tbody.appendChild(row);
    }
    /**
     * Updates a single row's search result cell
     */
    updateSearchResult(conversationId, searchResult, error, select = false) {
        if (!this.currentTable)
            return;
        // Mark row as processed unless it's in "Working..." state
        if (error !== "Working...") {
            this.processedRows.add(conversationId);
        }
        const row = this.currentTable.querySelector(`tr[data-conversation-id="${conversationId}"]`);
        if (!row)
            return;
        // Find the search result cell (third cell, index 2)
        const oldCell = row.children[2];
        if (!oldCell)
            return;
        // Create new cell with error if provided
        const newCell = error
            ? (0, DownloadWidgets_1.createSearchResultCell)(undefined, error, this.searchResultPreview)
            : (0, DownloadWidgets_1.createSearchResultCell)(searchResult, undefined, this.searchResultPreview);
        oldCell.replaceWith(newCell);
        // Update the item in our items array
        const itemIndex = this.items.findIndex((item) => item.metadata?.conversationId === conversationId);
        if (itemIndex !== -1) {
            this.items[itemIndex] = {
                ...this.items[itemIndex],
                searchResult,
                isSelected: select && !!searchResult,
            };
            // Update checkbox if there's a result
            const checkbox = row.querySelector('input[type="checkbox"]');
            if (checkbox) {
                checkbox.checked = select && !!searchResult;
            }
        }
    }
    /**
     * Gets configuration for table headers
     */
    getTableHeaders() {
        const baseHeaders = [
            { id: "checkbox", label: "", width: "40px", sortable: false },
            { id: "fileName", label: "Name", width: "25%", sortable: true },
        ];
        if (this.showResults) {
            baseHeaders.push({
                id: "searchResult",
                label: "Results",
                sortable: false,
            });
        }
        baseHeaders.push({ id: "created", label: "Created", width: "180px", sortable: true }, { id: "updated", label: "Updated", width: "180px", sortable: true }, { id: "filePath", label: "Path", sortable: true });
        return baseHeaders;
    }
    /**
     * Creates a new table element
     */
    createTable() {
        const table = document.createElement("table");
        table.style.width = "100%";
        table.style.borderCollapse = "collapse";
        table.style.marginTop = "10px";
        return table;
    }
    /**
     * Creates the table header section with sorting
     */
    createTableHeader(table) {
        const header = document.createElement("thead");
        const headerRow = document.createElement("tr");
        this.getTableHeaders().forEach((config) => {
            const th = (0, DownloadWidgets_1.createTableCell)(true);
            if (config.width) {
                th.style.width = config.width;
            }
            if (config.id === "checkbox") {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.addEventListener("change", (e) => this.handleHeaderCheckbox(e, table));
                th.appendChild(checkbox);
            }
            else {
                // Create header content container
                const headerContent = document.createElement("div");
                headerContent.style.cssText = `
          display: flex;
          align-items: center;
          gap: 4px;
          ${config.sortable ? "cursor: pointer;" : ""}
          padding: 4px;
          border-radius: 4px;
          transition: background-color 0.2s ease;
        `;
                // Add label
                const label = document.createElement("span");
                label.textContent = config.label;
                headerContent.appendChild(label);
                // Add sort indicator if sortable
                if (config.sortable) {
                    const sortIndicator = document.createElement("span");
                    sortIndicator.style.cssText = `
            font-size: 0.8em;
            opacity: ${this.currentSortColumn === config.id ? "1" : "0.3"};
            transition: opacity 0.2s ease;
          `;
                    sortIndicator.textContent = this.getSortIndicator(config.id);
                    headerContent.appendChild(sortIndicator);
                    // Add click handler for sorting
                    headerContent.addEventListener("click", () => this.handleSort(config.id));
                    // Add hover effect
                    headerContent.addEventListener("mouseover", () => {
                        headerContent.style.backgroundColor = "#f0f0f0";
                    });
                    headerContent.addEventListener("mouseout", () => {
                        headerContent.style.backgroundColor = "transparent";
                    });
                }
                th.appendChild(headerContent);
            }
            headerRow.appendChild(th);
        });
        header.appendChild(headerRow);
        return header;
    }
    /**
     * Gets the sort indicator symbol based on current sort state
     */
    getSortIndicator(columnId) {
        if (this.currentSortColumn !== columnId)
            return "";
        return this.currentSortDirection === "asc" ? "" : "";
    }
    /**
     * Handles sorting when a header is clicked
     */
    handleSort(columnId) {
        // If clicking a different column, reset sort direction
        if (this.currentSortColumn !== columnId) {
            this.currentSortDirection = null;
        }
        // Update sort state
        this.currentSortColumn = columnId;
        this.currentSortDirection = this.getNextSortDirection(this.currentSortDirection);
        // Sort items
        if (this.currentSortDirection) {
            this.items.sort((a, b) => {
                const comparison = this.compareItems(a, b, columnId);
                return this.currentSortDirection === "asc" ? comparison : -comparison;
            });
        }
        // Re-render table
        this.render();
    }
    /**
     * Gets the next sort direction in the cycle
     */
    getNextSortDirection(current) {
        if (current === null)
            return "asc";
        if (current === "asc")
            return "desc";
        return null;
    }
    /**
     * Compares two items for sorting
     */
    compareItems(a, b, columnId) {
        switch (columnId) {
            case "fileName":
                return a.fileName.localeCompare(b.fileName);
            case "filePath":
                return a.filePath.localeCompare(b.filePath);
            case "created":
                return this.compareDates(a.metadata?.created_at, b.metadata?.created_at);
            case "updated":
                return this.compareDates(a.metadata?.updated_at, b.metadata?.updated_at);
            default:
                return 0;
        }
    }
    /**
     * Compares two date strings
     */
    compareDates(a, b) {
        // Handle undefined dates
        if (!a && !b)
            return 0;
        if (!a)
            return -1;
        if (!b)
            return 1;
        // Compare dates
        return new Date(a).getTime() - new Date(b).getTime();
    }
    /**
     * Handles header checkbox changes
     */
    handleHeaderCheckbox(e, table) {
        const target = e.target;
        const checkboxes = table.querySelectorAll('tbody input[type="checkbox"]');
        checkboxes.forEach((cb) => (cb.checked = target.checked));
        // Update item selection state
        this.items.forEach((item) => {
            item.isSelected = target.checked;
        });
    }
    /**
     * Handles preview requests for files and conversations
     */
    async handlePreview(item) {
        // If it's a conversation, use conversation preview
        if (item.metadata?.conversationId) {
            try {
                const orgId = (0, getClaudeIds_1.getOrganizationId)();
                const conversation = await ConversationRetrieval_1.ConversationRetrieval.getConversation(orgId, item.metadata.conversationId);
                this.previewDialog.show(item.fileName, conversation.chat_messages, item.metadata.url);
            }
            catch (error) {
                console.error("Failed to load conversation preview:", error);
                alert("Failed to load conversation preview");
            }
            return;
        }
        // Otherwise show content preview
        try {
            const content = item.contentCallback
                ? await item.contentCallback(item)
                : item.content;
            this.contentPreview.show(item.fileName, content, item.fileName);
        }
        catch (error) {
            console.error("Failed to load content preview:", error);
            alert("Failed to load content preview");
        }
    }
    /**
     * Handles updating a file path
     */
    handlePathUpdate(index, newPath) {
        this.items[index] = {
            ...this.items[index],
            filePath: newPath,
        };
        // Re-render table
        this.render();
    }
    /**
     * Creates a table row for an item
     */
    createItemRow(item, index) {
        const row = document.createElement("tr");
        row.style.borderBottom = "1px solid #ccc";
        row.dataset.conversationId = item.metadata?.conversationId;
        // Checkbox cell
        const checkboxCell = (0, DownloadWidgets_1.createCheckboxCell)(item.isSelected);
        checkboxCell.querySelector("input")?.addEventListener("change", (e) => {
            const checkbox = e.target;
            this.items[index].isSelected = checkbox.checked;
        });
        row.appendChild(checkboxCell);
        // Name cell with preview for both conversations and content
        const onPreview = () => this.handlePreview(item);
        row.appendChild((0, DownloadWidgets_1.createNameCell)(item.fileName, item.metadata?.url, onPreview));
        // Results cell (if enabled)
        if (this.showResults) {
            row.appendChild((0, DownloadWidgets_1.createSearchResultCell)(item.searchResult, undefined, this.searchResultPreview));
        }
        // Created date cell
        row.appendChild((0, DownloadWidgets_1.createDateCell)(item.metadata?.created_at));
        // Updated date cell
        row.appendChild((0, DownloadWidgets_1.createDateCell)(item.metadata?.updated_at));
        // Path cell with edit functionality
        const onPathUpdate = (newPath) => this.handlePathUpdate(index, newPath);
        row.appendChild((0, DownloadWidgets_1.createNameCell)(item.filePath, undefined, undefined, onPathUpdate));
        return row;
    }
    /**
     * Creates and adds download buttons
     */
    addDownloadButtons() {
        // Remove any existing button container
        const existingContainer = this.container.querySelector(".download-buttons");
        if (existingContainer) {
            existingContainer.remove();
        }
        const buttonContainer = (0, DownloadWidgets_1.createButtonContainer)();
        buttonContainer.classList.add("download-buttons");
        const downloadSelectedButton = (0, DownloadWidgets_1.createButton)("Download Selected", () => this.handleDownload(false));
        const downloadBundleButton = (0, DownloadWidgets_1.createButton)("Download as Bundle", () => this.handleDownload(true));
        buttonContainer.appendChild(downloadSelectedButton);
        buttonContainer.appendChild(downloadBundleButton);
        this.container.appendChild(buttonContainer);
    }
    /**
     * Handles download requests
     */
    async handleDownload(asBundle) {
        const selectedItems = this.items.filter((item) => item.isSelected);
        if (selectedItems.length === 0) {
            alert("Please select items to download");
            return;
        }
        try {
            if (asBundle) {
                await DocumentDownload_1.DocumentDownload.handleSingleDownload(selectedItems);
            }
            else {
                await DocumentDownload_1.DocumentDownload.handleMultipleDownload(selectedItems);
            }
        }
        catch (error) {
            console.error("Download failed:", error);
            alert("Download failed: " +
                (error instanceof Error ? error.message : "Unknown error"));
        }
    }
    /**
     * Updates the table with new items while preserving selection state
     */
    updateItems(newItems) {
        // Store current selection state
        const selectionMap = new Map();
        this.items.forEach((item) => {
            if (item.metadata?.conversationId) {
                selectionMap.set(item.metadata.conversationId, item.isSelected || false);
            }
        });
        // Update items while preserving selection
        this.items = newItems.map((item) => {
            if (item.metadata?.conversationId) {
                const wasSelected = selectionMap.get(item.metadata.conversationId);
                if (wasSelected !== undefined) {
                    return { ...item, isSelected: wasSelected };
                }
            }
            return item;
        });
        // Re-render table
        this.render();
    }
    /**
     * Renders the table with current items
     */
    render() {
        this.container.innerHTML = "";
        if (this.items.length === 0) {
            this.container.appendChild((0, DownloadWidgets_1.createEmptyState)("No documents found"));
            return;
        }
        // Add cancel button before the table if showing results and cancel button is enabled
        if (this.showResults && this.showCancelButton) {
            const cancelButton = (0, DownloadWidgets_1.createButton)("Cancel", () => {
                ProjectSearchService_1.ProjectSearchService.abortSearch();
            }, { variant: "danger" });
            cancelButton.style.marginBottom = "10px";
            this.container.appendChild(cancelButton);
        }
        const table = this.createTable();
        const headerRow = this.createTableHeader(table);
        table.appendChild(headerRow);
        const tbody = table.createTBody();
        this.items.forEach((item, index) => {
            const row = this.createItemRow(item, index);
            tbody.appendChild(row);
        });
        this.container.appendChild(table);
        this.currentTable = table;
        this.addDownloadButtons();
    }
    /**
     * Cleans up the component
     */
    destroy() {
        this.container.innerHTML = "";
        this.previewDialog.destroy();
        this.contentPreview.destroy();
        this.searchResultPreview.destroy();
        this.currentTable = null;
    }
}
exports.DownloadTable = DownloadTable;


/***/ }),

/***/ "./src/ui/components/DownloadWidgets.ts":
/*!**********************************************!*\
  !*** ./src/ui/components/DownloadWidgets.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/DownloadWidgets.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * UI widget utilities for the download table components
 * Note: Making UI elements as reusable as Lego blocks!
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createTableCell = createTableCell;
exports.createCheckboxCell = createCheckboxCell;
exports.createEmptyState = createEmptyState;
exports.createLink = createLink;
exports.createButton = createButton;
exports.createButtonContainer = createButtonContainer;
exports.createDateCell = createDateCell;
exports.createPreviewIcon = createPreviewIcon;
exports.createPreviewButton = createPreviewButton;
exports.createNameCell = createNameCell;
exports.createSearchResultCell = createSearchResultCell;
const EditableCell_1 = __webpack_require__(/*! ./EditableCell */ "./src/ui/components/EditableCell.ts");
// Base styles that can be used across components
const styles = {
    colors: {
        primary: "#0066cc",
        primaryHover: "#0052a3",
        border: "#ccc",
        text: "#333",
        textMuted: "#666",
        background: "#f8f9fa",
        backgroundMuted: "#dee2e6",
        error: "#dc3545",
        errorBackground: "#f8d7da",
        warning: "#ffc107",
        warningBackground: "#fff3cd",
        working: "#6c757d",
        workingBackground: "#e9ecef",
        cancelling: "#fd7e14",
        cancellingBackground: "#fff3e6",
    },
    spacing: {
        sm: "4px",
        md: "8px",
        lg: "12px",
        xl: "16px",
    },
    borderRadius: "4px",
    fontSize: {
        sm: "12px",
        md: "14px",
        lg: "16px",
    },
};
/**
 * Creates a styled table cell
 */
function createTableCell(isHeader = false) {
    const cell = document.createElement(isHeader ? "th" : "td");
    cell.style.cssText = `
    padding: ${styles.spacing.md};
    border: 1px solid ${styles.colors.border};
    font-size: ${styles.fontSize.sm};
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    ${isHeader
        ? `
        background-color: ${styles.colors.background};
        font-weight: 600;
      `
        : ""}
  `;
    return cell;
}
/**
 * Creates a checkbox cell with consistent styling
 */
function createCheckboxCell(isSelected = false) {
    const cell = createTableCell();
    cell.style.textAlign = "center";
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = isSelected || false; // Ensure boolean value
    cell.appendChild(checkbox);
    return cell;
}
/**
 * Creates a styled empty state message
 */
function createEmptyState(message) {
    const container = document.createElement("div");
    container.style.cssText = `
    text-align: center;
    padding: ${styles.spacing.xl};
    color: ${styles.colors.textMuted};
    background-color: ${styles.colors.background};
    border: 1px solid ${styles.colors.backgroundMuted};
    border-radius: ${styles.borderRadius};
    margin-top: ${styles.spacing.lg};
  `;
    container.textContent = message;
    return container;
}
/**
 * Creates a styled link element
 */
function createLink(text, url) {
    const link = document.createElement("a");
    link.href = url;
    link.textContent = text;
    link.target = "_blank";
    link.style.cssText = `
    color: ${styles.colors.primary};
    text-decoration: none;
    margin-right: ${styles.spacing.md};
    font-size: ${styles.fontSize.md};
  `;
    link.addEventListener("mouseover", () => {
        link.style.textDecoration = "underline";
    });
    link.addEventListener("mouseout", () => {
        link.style.textDecoration = "none";
    });
    return link;
}
/**
 * Creates a styled button element
 */
function createButton(text, onClick, options = {}) {
    const button = document.createElement("button");
    button.textContent = text;
    const baseStyles = `
    cursor: pointer;
    border: none;
    font-size: ${styles.fontSize.md};
    transition: all 0.2s ease;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  `;
    let variantStyles = "";
    switch (options.variant) {
        case "secondary":
            variantStyles = `
        background: ${styles.colors.background};
        color: ${styles.colors.text};
        padding: ${styles.spacing.md} ${styles.spacing.xl};
        border-radius: ${styles.borderRadius};
        border: 1px solid ${styles.colors.border};
      `;
            break;
        case "icon":
            variantStyles = `
        background: none;
        color: ${styles.colors.textMuted};
        padding: ${styles.spacing.sm};
      `;
            break;
        case "danger":
            variantStyles = `
        background: ${styles.colors.error};
        color: white;
        padding: ${styles.spacing.md} ${styles.spacing.xl};
        border-radius: ${styles.borderRadius};
      `;
            break;
        default: // primary
            variantStyles = `
        background: ${styles.colors.primary};
        color: white;
        padding: ${styles.spacing.md} ${styles.spacing.xl};
        border-radius: ${styles.borderRadius};
      `;
    }
    button.style.cssText = baseStyles + variantStyles;
    // Add hover effects
    button.addEventListener("mouseover", () => {
        if (options.variant === "icon") {
            button.style.color = styles.colors.primary;
        }
        else if (options.variant === "secondary") {
            button.style.backgroundColor = styles.colors.backgroundMuted;
        }
        else if (options.variant === "danger") {
            button.style.backgroundColor = styles.colors.errorBackground;
        }
        else {
            button.style.backgroundColor = styles.colors.primaryHover;
        }
    });
    button.addEventListener("mouseout", () => {
        if (options.variant === "icon") {
            button.style.color = styles.colors.textMuted;
        }
        else if (options.variant === "secondary") {
            button.style.backgroundColor = styles.colors.background;
        }
        else if (options.variant === "danger") {
            button.style.backgroundColor = styles.colors.error;
        }
        else {
            button.style.backgroundColor = styles.colors.primary;
        }
    });
    button.addEventListener("click", onClick);
    return button;
}
/**
 * Creates a container for buttons with consistent styling
 */
function createButtonContainer() {
    const container = document.createElement("div");
    container.style.cssText = `
    display: flex;
    gap: ${styles.spacing.md};
    margin-top: ${styles.spacing.lg};
  `;
    return container;
}
/**
 * Creates a date cell with consistent formatting
 */
function createDateCell(date) {
    const cell = createTableCell();
    if (date) {
        const formattedDate = new Date(date).toLocaleString(undefined, {
            year: "numeric",
            month: "short",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
        });
        cell.textContent = formattedDate;
        cell.title = new Date(date).toLocaleString(undefined, {
            year: "numeric",
            month: "long",
            day: "numeric",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit",
            timeZoneName: "short",
        });
    }
    cell.style.cssText += `
    color: ${styles.colors.textMuted};
    font-size: ${styles.fontSize.sm};
    text-align: center;
  `;
    return cell;
}
/**
 * Creates a preview (eye) icon SVG element
 */
function createPreviewIcon({ size = 16, color = styles.colors.textMuted, } = {}) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", size.toString());
    svg.setAttribute("height", size.toString());
    svg.setAttribute("viewBox", "0 0 24 24");
    svg.setAttribute("fill", "none");
    svg.setAttribute("stroke", color);
    svg.setAttribute("stroke-width", "2");
    svg.innerHTML = `
    <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
    <circle cx="12" cy="12" r="3"></circle>
  `;
    return svg;
}
/**
 * Creates an error icon SVG element
 */
function createErrorIcon({ size = 16, color = styles.colors.error, } = {}) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", size.toString());
    svg.setAttribute("height", size.toString());
    svg.setAttribute("viewBox", "0 0 24 24");
    svg.setAttribute("fill", "none");
    svg.setAttribute("stroke", color);
    svg.setAttribute("stroke-width", "2");
    svg.innerHTML = `
    <circle cx="12" cy="12" r="10"></circle>
    <line x1="12" y1="8" x2="12" y2="12"></line>
    <line x1="12" y1="16" x2="12.01" y2="16"></line>
  `;
    return svg;
}
/**
 * Creates a preview button with icon
 */
function createPreviewButton(onClick) {
    const button = createButton("", onClick, { variant: "icon" });
    button.title = "Preview conversation";
    button.appendChild(createPreviewIcon());
    return button;
}
/**
 * Creates a name cell with preview and edit functionality
 */
function createNameCell(name, url, onPreview, onRename) {
    const cell = createTableCell();
    let currentContent;
    function createNormalView() {
        const container = document.createElement("div");
        container.style.cssText = `
      display: flex;
      align-items: center;
      gap: ${styles.spacing.md};
    `;
        if (url) {
            container.appendChild(createLink(name, url));
        }
        else {
            const text = document.createElement("span");
            text.textContent = name;
            container.appendChild(text);
        }
        if (onPreview) {
            container.appendChild(createPreviewButton(onPreview));
        }
        if (onRename) {
            container.appendChild(createEditButton(() => switchToEditMode()));
        }
        return container;
    }
    function switchToEditMode() {
        const editableCell = new EditableCell_1.EditableCell({
            initialValue: name,
            validator: validateFilePath,
            onSave: (newValue) => {
                onRename?.(newValue);
                switchToNormalMode();
            },
            onCancel: () => switchToNormalMode(),
        });
        currentContent.replaceWith(editableCell.getElement());
        currentContent = editableCell.getElement();
        editableCell.focus();
    }
    function switchToNormalMode() {
        const normalView = createNormalView();
        currentContent.replaceWith(normalView);
        currentContent = normalView;
    }
    // Start with normal view
    currentContent = createNormalView();
    cell.appendChild(currentContent);
    return cell;
}
/**
 * Creates a cell displaying search result information with expandable content
 */
function createSearchResultCell(searchResult, error, preview) {
    const cell = createTableCell();
    // Handle working state
    if (error === "Working..." || error === "Cancelling...") {
        const workingContainer = document.createElement("div");
        const isWorking = error === "Working...";
        workingContainer.style.cssText = `
      padding: ${styles.spacing.md};
      color: ${isWorking ? styles.colors.working : styles.colors.cancelling};
      font-size: ${styles.fontSize.sm};
      background: ${isWorking
            ? styles.colors.workingBackground
            : styles.colors.cancellingBackground};
      border-radius: ${styles.borderRadius};
      border-left: 3px solid ${isWorking ? styles.colors.working : styles.colors.cancelling};
      display: flex;
      align-items: center;
      gap: ${styles.spacing.md};
    `;
        const statusContainer = document.createElement("div");
        statusContainer.style.cssText = `
      display: flex;
      align-items: center;
      gap: ${styles.spacing.md};
    `;
        // Add loading spinner
        const spinner = document.createElement("div");
        spinner.style.cssText = `
      width: 12px;
      height: 12px;
      border: 2px solid ${isWorking ? styles.colors.working : styles.colors.cancelling};
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    `;
        const style = document.createElement("style");
        style.textContent = `
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    `;
        document.head.appendChild(style);
        statusContainer.appendChild(spinner);
        statusContainer.appendChild(document.createTextNode(error));
        workingContainer.appendChild(statusContainer);
        cell.appendChild(workingContainer);
        return cell;
    }
    // Handle error state
    if (error && error !== "No match found") {
        const errorContainer = document.createElement("div");
        errorContainer.style.cssText = `
      padding: ${styles.spacing.md};
      color: ${styles.colors.error};
      font-size: ${styles.fontSize.sm};
      background: ${styles.colors.errorBackground};
      border-radius: ${styles.borderRadius};
      border-left: 3px solid ${styles.colors.error};
      display: flex;
      align-items: center;
      gap: ${styles.spacing.md};
      cursor: pointer;
    `;
        // Add error icon that shows details on click
        const errorButton = createButton("", () => {
            preview?.show(error);
        }, { variant: "icon" });
        errorButton.title = "View error details";
        errorButton.appendChild(createErrorIcon());
        errorContainer.appendChild(errorButton);
        errorContainer.appendChild(document.createTextNode(error));
        cell.appendChild(errorContainer);
        return cell;
    }
    // Handle "No match found" state
    if (error === "No match found") {
        const noMatchContainer = document.createElement("div");
        noMatchContainer.style.cssText = `
      padding: ${styles.spacing.md};
      color: ${styles.colors.warning};
      font-size: ${styles.fontSize.sm};
      background: ${styles.colors.warningBackground};
      border-radius: ${styles.borderRadius};
      border-left: 3px solid ${styles.colors.warning};
    `;
        noMatchContainer.textContent = "No match found";
        cell.appendChild(noMatchContainer);
        return cell;
    }
    if (!searchResult) {
        return cell;
    }
    // Create clickable container for search result
    const container = document.createElement("div");
    container.style.cssText = `
    display: flex;
    flex-direction: column;
    gap: ${styles.spacing.sm};
    max-width: 400px;
    min-width: 200px;
    cursor: pointer;
    padding: ${styles.spacing.md};
    border-radius: ${styles.borderRadius};
    transition: background-color 0.2s ease;
  `;
    // Add hover effect
    container.addEventListener("mouseover", () => {
        container.style.backgroundColor = styles.colors.background;
    });
    container.addEventListener("mouseout", () => {
        container.style.backgroundColor = "transparent";
    });
    // Add click handler to show preview
    container.addEventListener("click", () => {
        preview?.show(searchResult);
    });
    // Add match reason with truncation
    const reason = document.createElement("div");
    reason.textContent = searchResult.matchReason;
    reason.style.cssText = `
    font-size: ${styles.fontSize.sm};
    color: ${styles.colors.text};
    line-height: 1.4;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
    overflow: hidden;
  `;
    container.appendChild(reason);
    // Add snippet preview with truncation
    const snippet = document.createElement("div");
    snippet.textContent = searchResult.relevantSnippet;
    snippet.style.cssText = `
    font-size: ${styles.fontSize.sm};
    color: ${styles.colors.textMuted};
    font-style: italic;
    background: ${styles.colors.background};
    padding: ${styles.spacing.md};
    border-radius: ${styles.borderRadius};
    border-left: 3px solid ${styles.colors.primary};
    line-height: 1.4;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 2;
    overflow: hidden;
  `;
    container.appendChild(snippet);
    // Add "Click to view details" hint
    const hint = document.createElement("div");
    hint.style.cssText = `
    font-size: ${styles.fontSize.sm};
    color: ${styles.colors.primary};
    display: flex;
    align-items: center;
    gap: ${styles.spacing.sm};
  `;
    hint.appendChild(createPreviewIcon({ color: styles.colors.primary }));
    hint.appendChild(document.createTextNode("Click to view details"));
    container.appendChild(hint);
    cell.appendChild(container);
    return cell;
}
/**
 * Creates an edit icon SVG element
 */
function createEditIcon({ size = 16, color = styles.colors.textMuted, } = {}) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", size.toString());
    svg.setAttribute("height", size.toString());
    svg.setAttribute("viewBox", "0 0 24 24");
    svg.setAttribute("fill", "none");
    svg.setAttribute("stroke", color);
    svg.setAttribute("stroke-width", "2");
    svg.innerHTML = `
    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
  `;
    return svg;
}
/**
 * Creates an edit button with icon
 */
function createEditButton(onClick) {
    const button = createButton("", onClick, { variant: "icon" });
    button.title = "Edit name";
    button.appendChild(createEditIcon());
    return button;
}
/**
 * Validates a file path
 */
function validateFilePath(value) {
    if (!value) {
        return "Path cannot be empty";
    }
    // Check for invalid characters
    const invalidChars = /[\x00-\x1F]/g; // Allow slashes and other path chars
    if (invalidChars.test(value)) {
        return "Path contains invalid characters";
    }
    return null;
}


/***/ }),

/***/ "./src/ui/components/DraggableManager.ts":
/*!***********************************************!*\
  !*** ./src/ui/components/DraggableManager.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/ui/components/DraggableManager.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DraggableManager = void 0;
const WindowStateService_1 = __webpack_require__(/*! ../../services/WindowStateService */ "./src/services/WindowStateService.ts");
/**
 * Manages draggable behavior for HTML elements.
 */
class DraggableManager {
    /**
     * Creates a new DraggableManager instance.
     * @param window - Element to make draggable
     * @param handle - Element that triggers dragging
     */
    constructor(window, handle) {
        this.isDragging = false;
        this.currentX = 0;
        this.currentY = 0;
        this.initialX = 0;
        this.initialY = 0;
        this.window = window;
        this.handle = handle;
        this.setupEventListeners();
    }
    /**
     * Sets up event listeners for drag behavior.
     */
    setupEventListeners() {
        this.handle.addEventListener("mousedown", this.handleMouseDown.bind(this));
        document.addEventListener("mousemove", this.handleMouseMove.bind(this));
        document.addEventListener("mouseup", this.handleMouseUp.bind(this));
    }
    /**
     * Handles the start of a drag operation.
     * @param e - Mouse event
     */
    handleMouseDown(e) {
        if (e.target === this.handle || this.handle.contains(e.target)) {
            this.isDragging = true;
            this.initialX = e.clientX - this.window.offsetLeft;
            this.initialY = e.clientY - this.window.offsetTop;
            this.window.style.position = "absolute";
            this.window.style.right = "auto";
        }
    }
    /**
     * Handles the drag movement.
     * @param e - Mouse event
     */
    handleMouseMove(e) {
        if (!this.isDragging)
            return;
        e.preventDefault();
        this.currentX = e.clientX - this.initialX;
        this.currentY = e.clientY - this.initialY;
        const bounds = this.calculateBounds();
        this.constrainToBounds(bounds);
        this.window.style.left = `${this.currentX}px`;
        this.window.style.top = `${this.currentY}px`;
    }
    /**
     * Calculates the bounds for dragging.
     * @returns Bounds object with min/max values
     */
    calculateBounds() {
        return {
            minX: 0,
            maxX: window.innerWidth - this.window.offsetWidth,
            minY: 0,
            maxY: window.innerHeight - this.window.offsetHeight,
        };
    }
    /**
     * Constrains the current position to the specified bounds.
     * @param bounds - Bounds to constrain to
     */
    constrainToBounds(bounds) {
        this.currentX = Math.max(bounds.minX, Math.min(this.currentX, bounds.maxX));
        this.currentY = Math.max(bounds.minY, Math.min(this.currentY, bounds.maxY));
    }
    /**
     * Handles the end of a drag operation.
     */
    handleMouseUp() {
        if (this.isDragging) {
            // Save position when drag ends
            WindowStateService_1.WindowStateService.savePosition(this.currentX, this.currentY);
        }
        this.isDragging = false;
    }
    /**
     * Removes all event listeners.
     */
    destroy() {
        this.handle.removeEventListener("mousedown", this.handleMouseDown.bind(this));
        document.removeEventListener("mousemove", this.handleMouseMove.bind(this));
        document.removeEventListener("mouseup", this.handleMouseUp.bind(this));
    }
}
exports.DraggableManager = DraggableManager;


/***/ }),

/***/ "./src/ui/components/EditableCell.ts":
/*!*******************************************!*\
  !*** ./src/ui/components/EditableCell.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/EditableCell.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditableCell = void 0;
// UI component for editing file names in the download table
// The cell that lets you rename without the drama!
const styles = {
    colors: {
        primary: "#0066cc",
        primaryHover: "#0052a3",
        border: "#ccc",
        text: "#333",
        textMuted: "#666",
        background: "#f8f9fa",
        error: "#dc3545",
        success: "#28a745",
    },
    spacing: {
        sm: "4px",
        md: "8px",
    },
    borderRadius: "4px",
    fontSize: {
        sm: "12px",
        md: "14px",
    },
};
class EditableCell {
    constructor(options) {
        this.isEditing = false;
        this.initialValue = options.initialValue;
        this.onSave = options.onSave;
        this.onCancel = options.onCancel;
        this.validator = options.validator || (() => null);
        this.container = document.createElement("div");
        this.container.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: ${styles.spacing.sm};
      `;
        // Create input field
        this.input = document.createElement("input");
        this.input.type = "text";
        this.input.value = this.initialValue;
        this.input.style.cssText = `
        padding: ${styles.spacing.sm} ${styles.spacing.md};
        border: 1px solid ${styles.colors.border};
        border-radius: ${styles.borderRadius};
        font-size: ${styles.fontSize.md};
        width: calc(100% - ${styles.spacing.md} * 2);
      `;
        // Create error message element
        this.error = document.createElement("div");
        this.error.style.cssText = `
        color: ${styles.colors.error};
        font-size: ${styles.fontSize.sm};
        display: none;
      `;
        // Create button container
        const buttonContainer = document.createElement("div");
        buttonContainer.style.cssText = `
        display: flex;
        gap: ${styles.spacing.sm};
        margin-top: ${styles.spacing.sm};
      `;
        // Create save button
        const saveButton = this.createButton("Save", () => this.handleSave(), "primary");
        // Create cancel button
        const cancelButton = this.createButton("Cancel", () => this.handleCancel(), "secondary");
        buttonContainer.appendChild(saveButton);
        buttonContainer.appendChild(cancelButton);
        this.container.appendChild(this.input);
        this.container.appendChild(this.error);
        this.container.appendChild(buttonContainer);
        // Add keyboard handlers
        this.input.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                this.handleSave();
            }
            else if (e.key === "Escape") {
                e.preventDefault();
                this.handleCancel();
            }
        });
    }
    createButton(text, onClick, variant) {
        const button = document.createElement("button");
        button.textContent = text;
        button.style.cssText = `
        padding: ${styles.spacing.sm} ${styles.spacing.md};
        border: none;
        border-radius: ${styles.borderRadius};
        font-size: ${styles.fontSize.sm};
        cursor: pointer;
        background: ${variant === "primary"
            ? styles.colors.primary
            : styles.colors.background};
        color: ${variant === "primary" ? "white" : styles.colors.text};
        border: 1px solid ${variant === "primary" ? "transparent" : styles.colors.border};
      `;
        button.addEventListener("mouseover", () => {
            button.style.background =
                variant === "primary"
                    ? styles.colors.primaryHover
                    : styles.colors.border;
        });
        button.addEventListener("mouseout", () => {
            button.style.background =
                variant === "primary"
                    ? styles.colors.primary
                    : styles.colors.background;
        });
        button.addEventListener("click", onClick);
        return button;
    }
    showError(message) {
        this.error.textContent = message;
        this.error.style.display = "block";
        this.input.style.borderColor = styles.colors.error;
    }
    clearError() {
        this.error.style.display = "none";
        this.input.style.borderColor = styles.colors.border;
    }
    handleSave() {
        const newValue = this.input.value.trim();
        const error = this.validator(newValue);
        if (error) {
            this.showError(error);
            return;
        }
        this.clearError();
        this.onSave(newValue);
    }
    handleCancel() {
        this.input.value = this.initialValue;
        this.clearError();
        this.onCancel();
    }
    getElement() {
        return this.container;
    }
    focus() {
        this.input.focus();
        // Select all text except extension
        const lastDot = this.input.value.lastIndexOf(".");
        if (lastDot > 0) {
            this.input.setSelectionRange(0, lastDot);
        }
        else {
            this.input.select();
        }
    }
    destroy() {
        this.container.remove();
    }
}
exports.EditableCell = EditableCell;


/***/ }),

/***/ "./src/ui/components/FloatingWindow.ts":
/*!*********************************************!*\
  !*** ./src/ui/components/FloatingWindow.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/FloatingWindow.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FloatingWindow = void 0;
const WindowStateService_1 = __webpack_require__(/*! ../../services/WindowStateService */ "./src/services/WindowStateService.ts");
const HelpManager_1 = __webpack_require__(/*! ./HelpManager */ "./src/ui/components/HelpManager.ts");
/**
 * Manages the floating window interface for the extension.
 */
class FloatingWindow {
    constructor() {
        this.element = null;
        this.outputDiv = null;
        this.uiStateManager = null;
        this.helpManager = null;
        this.template = `
    <div class="floating-window">
      <div class="status ready">
        <div style="display: flex; align-items: center; gap: 5px; flex-grow: 1;">
          <span class="status-label">ClaudePS - </span>
          <span class="status-text">READY</span>
          <span class="status-details"></span>
        </div>
        <button id="minimizeButton" style="font-size: 12px; padding: 2px 8px;">_</button>
        <button id="modeToggleButton" title="Switch to Script Mode" style="font-size: 12px; padding: 2px 8px;"></button>
        <button id="helpButton" style="font-size: 12px; padding: 2px 8px;">?</button>
      </div>
      <div class="input-container">
        <div class="script-mode" style="display: none;">
          <div class="script-container">
            <textarea id="scriptText" placeholder="Simple prompt:
Type your prompt here

-- or --

/repeat MAX 3 /stop_if success
Your prompt here

-- or -- 

/repeat MAX 3 /stop_if_not failure
Your prompt here"></textarea>
            <div class="resize-handle"></div>
          </div>
          <button id="runScript">Run Script</button>
        </div>
        <div class="simple-mode">
          <div class="simple-buttons" style="display: flex; gap: 8px; margin-bottom: 10px;">
            <button class="command-button search-button" data-command="/search_project " data-no-auto-run="true">Search</button>
            <button class="command-button project-button" data-command="/project">Project</button>
            <button class="command-button" data-command="/conversation">Conversation</button>
            <button class="command-button" data-command="/artifacts">Artifacts</button>
          </div>
          <div class="project-search-container">
            <input type="text" class="project-search-input" placeholder="Enter search criteria..." />
            <button class="project-search-glyph"></button>
            <button class="project-search-cancel">Cancel</button>
          </div>
        </div>
        <div class="output-container">
          <div id="scriptOutput"></div>
          <div id="collapseButton" style="cursor: pointer; user-select: none; padding: 5px;"></div>
        </div>
      </div>
    </div>
  `;
    }
    /**
     * Creates and injects the floating window into the DOM.
     * @returns The floating window element
     * @throws Error if window creation fails
     */
    async create() {
        const container = document.createElement("div");
        container.innerHTML = this.template.trim();
        const window = container.querySelector(".floating-window");
        if (!window) {
            throw new Error("Failed to create floating window");
        }
        document.body.appendChild(container);
        this.element = window;
        this.outputDiv = this.element.querySelector("#scriptOutput");
        // Get elements and bind event listeners
        const elements = this.getElements();
        this.bindEventListeners(elements);
        // Initialize help manager
        this.helpManager = new HelpManager_1.HelpManager(this.outputDiv);
        // Restore saved window state
        WindowStateService_1.WindowStateService.applyState(this.element);
        // Set up resize functionality
        this.setupResizeHandles();
        return this.element;
    }
    /**
     * Sets up the resize handle functionality
     */
    setupResizeHandles() {
        if (!this.element)
            return;
        const scriptContainer = this.element.querySelector(".script-container");
        const scriptText = this.element.querySelector("#scriptText");
        const resizeHandle = this.element.querySelector(".resize-handle");
        if (!scriptContainer || !scriptText || !resizeHandle)
            return;
        let startY = 0;
        let startHeight = 0;
        let isDragging = false;
        resizeHandle.addEventListener("mousedown", (e) => {
            isDragging = true;
            startY = e.clientY;
            startHeight = scriptText.offsetHeight;
            document.body.style.cursor = "row-resize";
            document.body.style.userSelect = "none";
        });
        document.addEventListener("mousemove", (e) => {
            if (!isDragging)
                return;
            const deltaY = e.clientY - startY;
            const newHeight = Math.max(100, startHeight + deltaY);
            scriptText.style.height = `${newHeight}px`;
            WindowStateService_1.WindowStateService.saveScriptHeight(`${newHeight}px`);
        });
        document.addEventListener("mouseup", () => {
            if (!isDragging)
                return;
            isDragging = false;
            document.body.style.cursor = "";
            document.body.style.userSelect = "";
        });
    }
    /**
     * Binds event listeners to UI elements
     */
    bindEventListeners(elements) {
        // Command button handlers
        elements.window.querySelectorAll(".command-button").forEach((button) => {
            button.addEventListener("click", () => {
                const command = button.getAttribute("data-command");
                if (command) {
                    if (button.classList.contains("search-button")) {
                        // Show search UI for search button
                        const searchContainer = elements.window.querySelector(".project-search-container");
                        if (searchContainer) {
                            searchContainer.style.display = "block";
                            const searchInput = searchContainer.querySelector(".project-search-input");
                            if (searchInput) {
                                searchInput.focus();
                            }
                        }
                    }
                    else {
                        // For other buttons, just execute the command
                        elements.scriptText.value = command;
                        elements.runButton.click();
                    }
                }
            });
        });
        // Project search handlers
        const searchContainer = elements.window.querySelector(".project-search-container");
        const searchInput = searchContainer?.querySelector(".project-search-input");
        const searchGlyph = searchContainer?.querySelector(".project-search-glyph");
        const searchCancel = searchContainer?.querySelector(".project-search-cancel");
        const executeProjectSearch = () => {
            if (searchInput && searchInput.value.trim()) {
                // Execute search in simple mode
                elements.scriptText.value = `/search_project ${searchInput.value.trim()}`;
                elements.runButton.click();
                // Show cancel button
                if (searchCancel) {
                    searchCancel.style.display = "block";
                    searchCancel.textContent = "Cancel";
                }
            }
        };
        const cancelSearch = () => {
            // Hide search UI and cancel button
            if (searchContainer) {
                searchContainer.style.display = "none";
            }
            if (searchInput) {
                searchInput.value = "";
            }
            if (searchCancel) {
                searchCancel.style.display = "none";
            }
            // Click the run button to trigger cancel in working state
            elements.runButton.click();
        };
        if (searchInput) {
            searchInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    executeProjectSearch();
                }
                else if (e.key === "Escape") {
                    cancelSearch();
                }
            });
        }
        if (searchGlyph) {
            searchGlyph.addEventListener("click", executeProjectSearch);
        }
        if (searchCancel) {
            searchCancel.addEventListener("click", cancelSearch);
        }
        // Mode toggle handler
        elements.modeToggleButton.addEventListener("click", () => {
            const isScriptMode = elements.scriptModeContainer.style.display !== "none";
            elements.scriptModeContainer.style.display = isScriptMode
                ? "none"
                : "block";
            elements.simpleModeContainer.style.display = isScriptMode
                ? "block"
                : "none";
            elements.modeToggleButton.title = isScriptMode
                ? "Switch to Script Mode"
                : "Switch to Command Mode";
            elements.modeToggleButton.textContent = isScriptMode ? "" : "";
        });
        elements.runButton.addEventListener("click", () => this.uiStateManager?.updateButtonStates(true));
        elements.helpButton.addEventListener("click", () => this.helpManager?.show());
        elements.minimizeButton.addEventListener("click", () => this.uiStateManager?.toggleMinimize());
        elements.collapseButton.addEventListener("click", () => this.uiStateManager?.toggleCollapse());
    }
    /**
     * Retrieves all UI elements managed by the floating window.
     * @returns Object containing all UI elements
     * @throws Error if any element is not found
     */
    getElements() {
        if (!this.element) {
            throw new Error("Floating window not initialized");
        }
        const elements = {
            window: this.element,
            status: this.element.querySelector(".status"),
            statusText: this.element.querySelector(".status-text"),
            statusDetails: this.element.querySelector(".status-details"),
            scriptText: this.element.querySelector("#scriptText"),
            runButton: this.element.querySelector("#runScript"),
            output: this.element.querySelector("#scriptOutput"),
            helpButton: this.element.querySelector("#helpButton"),
            collapseButton: this.element.querySelector("#collapseButton"),
            minimizeButton: this.element.querySelector("#minimizeButton"),
            modeToggleButton: this.element.querySelector("#modeToggleButton"),
            scriptModeContainer: this.element.querySelector(".script-mode"),
            simpleModeContainer: this.element.querySelector(".simple-mode"),
        };
        // Validate all elements exist
        for (const [key, value] of Object.entries(elements)) {
            if (!value) {
                throw new Error(`Failed to find element: ${key}`);
            }
        }
        // Type assertion is safe here because we validated all elements exist
        return elements;
    }
    /**
     * Sets the UI state manager - critical for window state management
     */
    setUIStateManager(manager) {
        this.uiStateManager = manager;
    }
    /**
     * Removes the floating window from the DOM.
     */
    destroy() {
        // Save window state before removal
        if (this.element) {
            WindowStateService_1.WindowStateService.saveGeometry(this.element.style.width, this.element.style.height);
        }
        this.element?.parentElement?.remove();
        this.element = null;
        this.outputDiv = null;
    }
}
exports.FloatingWindow = FloatingWindow;


/***/ }),

/***/ "./src/ui/components/HelpManager.ts":
/*!******************************************!*\
  !*** ./src/ui/components/HelpManager.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/HelpManager.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HelpManager = void 0;
/**
 * Manages help text display and formatting for the extension.
 */
class HelpManager {
    /**
     * Creates a new HelpManager instance.
     * @param outputElement - Element to display help text in
     */
    constructor(outputElement) {
        this.outputElement = outputElement;
    }
    /**
     * Displays the help text in the output element.
     */
    show() {
        this.outputElement.innerHTML = "";
        HelpManager.HELP_TEXT.split("\n").forEach((line) => {
            const div = document.createElement("div");
            div.textContent = line;
            div.style.whiteSpace = "pre";
            this.outputElement.appendChild(div);
        });
    }
    /**
     * Updates the help text content dynamically.
     * @param newText - New help text content
     */
    updateContent(newText) {
        this.outputElement.innerHTML = "";
        newText
            .trim()
            .split("\n")
            .forEach((line) => {
            const div = document.createElement("div");
            div.textContent = line;
            div.style.whiteSpace = "pre";
            this.outputElement.appendChild(div);
        });
    }
    /**
     * Clears the help text display.
     */
    clear() {
        this.outputElement.innerHTML = "";
    }
}
exports.HelpManager = HelpManager;
HelpManager.HELP_TEXT = `
    ClaudeScript v1.5
    
    1. Simple Prompt:
    Just type your prompt and it will be sent once.
    
    2. Commands:
    
    Basic Commands:
    /d[ocs] - List available documents
    /p[roject] - List conversations in current project
    
    Content Commands:
    /c[onversation] - Export conversation without artifacts
    /c[onversation] /a[rtifacts] - Export conversation including artifacts
    /c[onversation] /m[ultiple] - Export artifacts as separate files
    /a[rtifacts] - Export only artifacts as markdown
    /a[rtifacts] /m[ultiple] - Export artifacts as separate files
    
    Project Commands:
    /sp[search_project] [text] - Search project conversations
    /qp[query_project] prompt - Query all conversations
    
    Alias Commands:
    /al[ias] @name text - Create or update an alias
    /da[delete_alias] @name - Delete an alias
    /la[list_alias] - List all aliases
    
    3. Loop Command Format:
    /repeat [/max number] [/stop_if condition]
    or
    /repeat [/max number] [/stop_if_not condition]
    
    Examples:
    Simple prompt:
    Tell me a joke
    
    With aliases:
    /alias @joke Tell me your best joke
    @joke
    
    With repeat and max tries:
    /repeat /max 3 /stop_if success
    Tell me a joke
    
    With repeat until condition:
    /repeat /stop_if laugh
    Tell me a joke
    
    Note: All command keywords now start with / for consistency`.trim();


/***/ }),

/***/ "./src/ui/components/SearchResultPreview.ts":
/*!**************************************************!*\
  !*** ./src/ui/components/SearchResultPreview.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/SearchResultPreview.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Component for displaying detailed search results in a modal window
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchResultPreview = void 0;
const getClaudeIds_1 = __webpack_require__(/*! ../../utils/getClaudeIds */ "./src/utils/getClaudeIds.ts");
class SearchResultPreview {
    constructor(onViewConversation) {
        this.dialog = document.createElement("dialog");
        this.content = document.createElement("div");
        this.onViewConversation = onViewConversation;
        this.setupDialog();
    }
    setupDialog() {
        // Style the dialog
        this.dialog.style.cssText = `
      padding: 0;
      border: none;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      max-width: 800px;
      width: 90vw;
      max-height: 80vh;
      background: white;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000002;
    `;
        // Create header
        const header = document.createElement("div");
        header.style.cssText = `
      padding: 16px;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-radius: 8px 8px 0 0;
    `;
        const title = document.createElement("h2");
        title.style.cssText = `
      margin: 0;
      font-size: 18px;
      color: #333;
    `;
        title.textContent = "Search Result Details";
        const closeButton = document.createElement("button");
        closeButton.style.cssText = `
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #666;
      padding: 4px 8px;
    `;
        closeButton.textContent = "";
        closeButton.addEventListener("click", () => this.hide());
        header.appendChild(title);
        header.appendChild(closeButton);
        // Style the content container
        this.content.style.cssText = `
      padding: 16px;
      max-height: calc(80vh - 120px);
      overflow-y: auto;
    `;
        // Add components to dialog
        this.dialog.appendChild(header);
        this.dialog.appendChild(this.content);
        // Add dialog to document
        document.body.appendChild(this.dialog);
    }
    showError(container, message) {
        const errorDiv = document.createElement("div");
        errorDiv.style.cssText = `
      color: #dc3545;
      padding: 8px 12px;
      background: #fff5f5;
      border-radius: 4px;
      margin-top: 8px;
      font-size: 14px;
    `;
        errorDiv.textContent = message;
        // Remove any existing error messages
        const existingError = container.querySelector("[data-error]");
        if (existingError) {
            existingError.remove();
        }
        errorDiv.setAttribute("data-error", "true");
        container.appendChild(errorDiv);
    }
    /**
     * Shows the preview dialog with search result details or error information
     */
    show(result) {
        this.content.innerHTML = "";
        // If result is a string, it's an error message
        if (typeof result === "string") {
            const errorSection = {
                title: "Error Details",
                content: result,
                style: `
          font-size: 14px;
          line-height: 1.5;
          color: #dc3545;
          background: #fff5f5;
          padding: 12px;
          border-radius: 4px;
          border-left: 3px solid #dc3545;
          margin-bottom: 20px;
        `,
            };
            const section = document.createElement("div");
            section.style.marginBottom = "24px";
            const heading = document.createElement("h3");
            heading.style.cssText = `
        margin: 0 0 8px 0;
        font-size: 16px;
        color: #333;
        font-weight: 600;
      `;
            heading.textContent = errorSection.title;
            const contentDiv = document.createElement("div");
            contentDiv.style.cssText = errorSection.style;
            contentDiv.textContent = errorSection.content;
            section.appendChild(heading);
            section.appendChild(contentDiv);
            this.content.appendChild(section);
            this.dialog.showModal();
            return;
        }
        // Create sections for different parts of the result
        const sections = [
            {
                title: "Match Reason",
                content: result.matchReason,
                style: `
          font-size: 14px;
          line-height: 1.5;
          color: #333;
          margin-bottom: 20px;
        `,
            },
            {
                title: "Relevant Snippet",
                content: result.relevantSnippet,
                style: `
          font-family: monospace;
          background: #f8f9fa;
          padding: 12px;
          border-radius: 4px;
          border-left: 3px solid #0066cc;
          font-size: 14px;
          line-height: 1.5;
          overflow-x: auto;
          white-space: pre-wrap;
          color: #333;
          margin-bottom: 20px;
        `,
            },
            {
                title: "View Conversation",
                content: "Click to view conversation and jump to matching message",
                style: `
          font-size: 14px;
          color: #0066cc;
          cursor: pointer;
          margin-bottom: 20px;
          padding: 8px 12px;
          background: #f0f7ff;
          border-radius: 4px;
          display: inline-block;
          transition: all 0.2s ease;
          &:hover {
            background-color: #e0f0ff;
            transform: translateY(-1px);
          }
        `,
                isLink: true,
            },
        ];
        // Add each section
        sections.forEach(({ title, content, style, isLink }) => {
            const section = document.createElement("div");
            section.style.marginBottom = "24px";
            const heading = document.createElement("h3");
            heading.style.cssText = `
        margin: 0 0 8px 0;
        font-size: 16px;
        color: #333;
        font-weight: 600;
      `;
            heading.textContent = title;
            const contentDiv = document.createElement("div");
            contentDiv.style.cssText = style;
            contentDiv.textContent = content;
            if (isLink) {
                contentDiv.addEventListener("click", async () => {
                    try {
                        // Get organization ID
                        const orgId = (0, getClaudeIds_1.getOrganizationId)();
                        if (!orgId) {
                            this.showError(contentDiv, "Unable to get organization ID. Please ensure you're logged in to Claude.");
                            return;
                        }
                        // Notify parent to show conversation
                        this.onViewConversation(result.conversationId, result.messageId);
                    }
                    catch (error) {
                        console.error("Failed to load conversation:", error);
                        this.showError(contentDiv, "Unable to load conversation. Please try refreshing the page.");
                    }
                });
            }
            section.appendChild(heading);
            section.appendChild(contentDiv);
            this.content.appendChild(section);
        });
        this.dialog.showModal();
    }
    /**
     * Hides the preview dialog
     */
    hide() {
        this.dialog.close();
    }
    /**
     * Cleans up the component
     */
    destroy() {
        this.dialog.remove();
    }
}
exports.SearchResultPreview = SearchResultPreview;


/***/ }),

/***/ "./src/ui/components/StatusManager.ts":
/*!********************************************!*\
  !*** ./src/ui/components/StatusManager.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/StatusManager.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatusManager = void 0;
/**
 * Manages the display and updates of status information.
 */
class StatusManager {
    /**
     * Creates a new StatusManager instance.
     * @param elements - Required DOM elements for status management
     */
    constructor(elements) {
        this.currentState = "ready";
        this.onCancel = null;
        this.elements = elements;
        this.initializeStatus();
        this.setupCancelHandler();
    }
    /**
     * Sets up initial status display.
     */
    initializeStatus() {
        this.setStatus("ready");
    }
    /**
     * Sets up handler for cancel button clicks
     */
    setupCancelHandler() {
        this.elements.runButton.addEventListener("click", () => {
            if (this.currentState === "working" && this.onCancel) {
                this.onCancel();
            }
        });
    }
    /**
     * Updates the current status display.
     * @param state - New status state to display
     * @param details - Optional details message
     * @param clearInput - Whether to clear input on ready state
     */
    async setStatus(state, details = "", clearInput = true) {
        console.log("Status:", state, details);
        const config = StatusManager.STATUS_CONFIGS[state];
        this.elements.statusText.textContent = config.text;
        this.elements.statusDetails.textContent = details;
        this.elements.statusElement.className = `status ${config.class}`;
        this.currentState = state;
        this.updateInputState(state);
        this.updateButtonState(state);
        // Clear input on ready state if clearInput is true
        if (state === "ready" && clearInput) {
            this.elements.scriptInput.value = "";
        }
    }
    /**
     * Updates the input field state based on status.
     * @param state - Current status state
     */
    updateInputState(state) {
        this.elements.scriptInput.disabled = state === "working";
    }
    /**
     * Updates the run button state based on status.
     * @param state - Current status state
     */
    updateButtonState(state) {
        if (state === "working") {
            this.elements.runButton.textContent = "Cancel";
            this.elements.runButton.disabled = false;
        }
        else {
            this.elements.runButton.textContent = "Run Script";
            this.elements.runButton.disabled = false;
        }
    }
    /**
     * Gets the current status state.
     * @returns Current status state
     */
    getCurrentState() {
        return this.currentState;
    }
    /**
     * Checks if the status is in a specific state.
     * @param state - State to check
     * @returns True if current state matches
     */
    isInState(state) {
        return this.currentState === state;
    }
}
exports.StatusManager = StatusManager;
StatusManager.STATUS_CONFIGS = {
    ready: { text: "READY", class: "ready" },
    working: { text: "WORKING", class: "working" },
    error: { text: "ERROR", class: "error" },
};


/***/ }),

/***/ "./src/ui/components/UIStateManager.ts":
/*!*********************************************!*\
  !*** ./src/ui/components/UIStateManager.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/ui/components/UIStateManager.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Manages UI state and logging for the Claude extension
 * Note: Making your UI state as predictable as a well-written script!
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UIStateManager = void 0;
const WindowStateService_1 = __webpack_require__(/*! ../../services/WindowStateService */ "./src/services/WindowStateService.ts");
class UIStateManager {
    constructor(elements, statusManager) {
        this.isMinimized = false;
        this.isCollapsed = false;
        this.resizeObserver = null;
        this.elements = elements;
        this.statusManager = statusManager;
        this.bindKeyboardEvents();
        this.setupResizeObserver();
    }
    /**
     * Sets up observer for window size changes
     */
    setupResizeObserver() {
        if (typeof ResizeObserver === "undefined") {
            console.warn("ResizeObserver not supported in this browser");
            return;
        }
        this.resizeObserver = new ResizeObserver((entries) => {
            for (const entry of entries) {
                const element = entry.target;
                if (!this.isMinimized) {
                    WindowStateService_1.WindowStateService.saveGeometry(element.style.width, element.style.height);
                }
            }
        });
        this.resizeObserver.observe(this.elements.window);
        // Also observe script textarea height
        const scriptContainer = this.elements.scriptText.parentElement;
        if (scriptContainer) {
            const scriptObserver = new ResizeObserver((entries) => {
                for (const entry of entries) {
                    const element = entry.target;
                    WindowStateService_1.WindowStateService.saveScriptHeight(element.style.height);
                }
            });
            scriptObserver.observe(scriptContainer);
        }
    }
    /**
     * Binds keyboard events for the script input
     */
    bindKeyboardEvents() {
        this.elements.scriptText.addEventListener("keydown", (e) => {
            // Run script on Enter without shift
            if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                this.elements.runButton.click();
            }
            // Allow new line on Shift+Enter
            else if (e.key === "Enter" && e.shiftKey) {
                // Default behavior will add new line
                return;
            }
            // Cancel on Escape when script is running
            else if (e.key === "Escape" &&
                this.statusManager.getCurrentState() === "working") {
                e.preventDefault();
                this.elements.runButton.click(); // Will trigger cancel in working state
            }
        });
    }
    /**
     * Toggles the minimize state of the window
     */
    toggleMinimize() {
        this.isMinimized = !this.isMinimized;
        // Save current dimensions before toggling
        const currentWidth = this.elements.window.style.width;
        const currentHeight = this.elements.window.style.height;
        if (this.isMinimized) {
            // Store dimensions for restoration
            if (currentWidth && currentHeight) {
                this.elements.window.dataset.prevWidth = currentWidth;
                this.elements.window.dataset.prevHeight = currentHeight;
            }
            // Clear dimensions to allow shrinking
            this.elements.window.style.width = "";
            this.elements.window.style.height = "";
        }
        else {
            // Restore previous dimensions if they exist
            const prevWidth = this.elements.window.dataset.prevWidth;
            const prevHeight = this.elements.window.dataset.prevHeight;
            if (prevWidth && prevHeight) {
                this.elements.window.style.width = prevWidth;
                this.elements.window.style.height = prevHeight;
                // Save restored dimensions
                WindowStateService_1.WindowStateService.saveGeometry(prevWidth, prevHeight);
            }
        }
        // Toggle minimized class for CSS styling
        this.elements.window.classList.toggle("minimized", this.isMinimized);
        this.elements.minimizeButton.textContent = this.isMinimized ? "" : "_";
        this.elements.minimizeButton.title = this.isMinimized
            ? "Restore"
            : "Minimize";
        // Save window state
        WindowStateService_1.WindowStateService.saveWindowState(this.isMinimized, this.isCollapsed);
    }
    /**
     * Toggles the collapse state of the output panel
     */
    toggleCollapse() {
        this.isCollapsed = !this.isCollapsed;
        if (this.isCollapsed) {
            // Store current window height for restoration
            const currentWindowHeight = this.elements.window.style.height;
            if (currentWindowHeight) {
                this.elements.window.dataset.prevHeight = currentWindowHeight;
            }
            // Store output height for restoration
            const currentOutputHeight = this.elements.output.style.height;
            if (currentOutputHeight) {
                this.elements.output.dataset.prevHeight = currentOutputHeight;
            }
            // Collapse output area
            this.elements.output.style.maxHeight = "3em";
            this.elements.output.style.overflowY = "hidden";
            // Shrink window to fit collapsed content
            this.elements.window.style.height = "auto";
            this.elements.window.style.minHeight = "auto";
        }
        else {
            // Restore window height
            const prevWindowHeight = this.elements.window.dataset.prevHeight;
            if (prevWindowHeight) {
                this.elements.window.style.height = prevWindowHeight;
                this.elements.window.style.minHeight = "200px"; // Restore default min-height
            }
            // Restore output height
            const prevOutputHeight = this.elements.output.dataset.prevHeight;
            if (prevOutputHeight) {
                this.elements.output.style.height = prevOutputHeight;
            }
            this.elements.output.style.maxHeight = "";
            this.elements.output.style.overflowY = "auto";
        }
        this.elements.collapseButton.textContent = this.isCollapsed ? "" : "";
        this.elements.collapseButton.title = this.isCollapsed
            ? "Expand"
            : "Collapse";
        // Save window state
        WindowStateService_1.WindowStateService.saveWindowState(this.isMinimized, this.isCollapsed);
        const windowHeight = this.elements.window.style.height;
        if (windowHeight) {
            WindowStateService_1.WindowStateService.saveGeometry(this.elements.window.style.width, windowHeight);
        }
    }
    /**
     * Updates button states based on execution state
     * @param isExecuting - Whether a script is currently executing
     */
    updateButtonStates(isExecuting) {
        this.elements.runButton.textContent = isExecuting ? "Cancel" : "Run Script";
        this.elements.runButton.disabled = false;
        this.elements.scriptText.disabled = isExecuting;
    }
    setMode(scriptMode) {
        WindowStateService_1.WindowStateService.saveMode(scriptMode);
        // Update UI elements visibility
        if (this.elements.scriptModeContainer &&
            this.elements.simpleModeContainer) {
            this.elements.scriptModeContainer.style.display = scriptMode
                ? "block"
                : "none";
            this.elements.simpleModeContainer.style.display = scriptMode
                ? "none"
                : "block";
        }
    }
    /**
     * Logs a message to the output area
     * @param message - Message to log
     * @param type - Type of message for styling
     */
    log(message, type = "info") {
        const log = document.createElement("div");
        log.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        log.style.color =
            type === "error" ? "red" : type === "success" ? "green" : "black";
        this.elements.output.appendChild(log);
        this.elements.output.scrollTop = this.elements.output.scrollHeight;
    }
    /**
     * Cleans up resources
     */
    destroy() {
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
        }
    }
    /**
     * Clears the output area
     */
    clearOutput() {
        this.elements.output.innerHTML = "";
    }
}
exports.UIStateManager = UIStateManager;


/***/ }),

/***/ "./src/utils/EventStreamParser.ts":
/*!****************************************!*\
  !*** ./src/utils/EventStreamParser.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/utils/EventStreamParser.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Handles parsing of Server-Sent Events from Claude API responses
 * Note: Making event streams as smooth as a well-oiled machine!
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventStreamParser = void 0;
/**
 * Parser for Server-Sent Events from Claude's API
 */
class EventStreamParser {
    constructor() {
        this.buffer = "";
        this.currentMessage = "";
        this.isComplete = false;
    }
    /**
     * Processes a chunk of data from the event stream
     * @param chunk - Raw chunk data from stream
     * @param onEvent - Optional callback for each parsed event
     * @returns The accumulated text content
     */
    processChunk(chunk, onEvent) {
        // Add new data to buffer
        this.buffer += chunk;
        // Process complete events in buffer
        const events = this.buffer.split("\n\n");
        this.buffer = events.pop() || ""; // Keep last incomplete event
        for (const event of events) {
            if (!event.trim())
                continue;
            try {
                const parsed = this.parseEvent(event);
                if (parsed) {
                    if (onEvent) {
                        onEvent(parsed);
                    }
                    this.processEvent(parsed);
                }
            }
            catch (error) {
                console.error("Error parsing event:", error);
            }
        }
        return this.currentMessage;
    }
    /**
     * Parses a single event string into structured data
     * @param eventString - Raw event data
     * @returns Parsed event data or null if invalid
     */
    parseEvent(eventString) {
        const lines = eventString.split("\n");
        let eventType = "";
        let eventData = null;
        for (const line of lines) {
            if (!line.trim())
                continue;
            const [field, ...values] = line.split(": ");
            const value = values.join(": ").trim();
            if (field === "event") {
                eventType = value;
            }
            else if (field === "data") {
                try {
                    eventData = JSON.parse(value);
                }
                catch (error) {
                    console.error("Error parsing event data:", error);
                    return null;
                }
            }
        }
        // Require both event type and data
        if (!eventType || !eventData) {
            return null;
        }
        return {
            type: eventType,
            data: eventData,
        };
    }
    /**
     * Processes a parsed event and updates internal state
     * @param event - Parsed event data
     */
    processEvent(event) {
        // Skip ping events
        if (event.type === "ping")
            return;
        // Handle completion events
        if (event.type === "completion" && event.data) {
            if (event.data.completion) {
                this.currentMessage += event.data.completion;
            }
            // Check for completion
            if (event.data.stop_reason) {
                this.isComplete = true;
            }
        }
    }
    /**
     * Gets the entire accumulated message
     */
    getMessage() {
        return this.currentMessage;
    }
    /**
     * Checks if the message is complete
     */
    isMessageComplete() {
        return this.isComplete;
    }
    /**
     * Resets the parser state
     */
    reset() {
        this.buffer = "";
        this.currentMessage = "";
        this.isComplete = false;
    }
}
exports.EventStreamParser = EventStreamParser;


/***/ }),

/***/ "./src/utils/PathExtractor.ts":
/*!************************************!*\
  !*** ./src/utils/PathExtractor.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /src/utils/PathExtractor.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Utility functions for extracting file paths from code artifacts
 * Note: Finding needles in comment haystacks since 2024!
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractPathFromComments = extractPathFromComments;
exports.extractPathFromSpecialCases = extractPathFromSpecialCases;
exports.extractRelPath = extractRelPath;
exports.extractPath = extractPath;
exports.filterPathFromSubdirectories = filterPathFromSubdirectories;
/**
 * Extracts the file path from a code artifact's comments
 * Checks both single-line and block comments at the start of the file
 * @param content - The content to analyze
 * @returns The extracted path or undefined if not found
 */
function extractPathFromComments(content) {
    // Normalize line endings
    const normalizedContent = content.replace(/\r\n/g, "\n");
    const lines = normalizedContent.split("\n");
    let inBlockComment = false;
    let collectedLines = [];
    for (let i = 0; i < Math.min(20, lines.length); i++) {
        // Only check first 20 lines
        const line = lines[i].trim();
        // Skip empty lines
        if (!line)
            continue;
        // Check for start of block comment
        if (line.startsWith("/*")) {
            inBlockComment = true;
            collectedLines.push(line.substring(2).trim());
            continue;
        }
        // Check for end of block comment
        if (inBlockComment && line.includes("*/")) {
            inBlockComment = false;
            collectedLines.push(line.substring(0, line.indexOf("*/")).trim());
            break;
        }
        // Collect block comment lines
        if (inBlockComment) {
            // Remove leading * if present
            const cleanLine = line.startsWith("*") ? line.substring(1).trim() : line;
            collectedLines.push(cleanLine);
            continue;
        }
        // Check for single-line comments
        if (line.startsWith("//")) {
            collectedLines.push(line.substring(2).trim());
            continue;
        }
        // If we hit a non-comment line, stop processing
        if (!inBlockComment)
            break;
    }
    // Look for path in collected lines
    for (const line of collectedLines) {
        // Check for explicit path declarations
        const pathMatches = [
            /File:\s*([^*\n]+)/i, // File: path
            /Path:\s*([^*\n]+)/i, // Path: path
            /FilePath:\s*([^*\n]+)/i, // FilePath: path
            /@path\s+([^*\n]+)/i, // @path path
            /^[\\/].*\.[\w]+$/, // Absolute path with extension
        ];
        for (const pattern of pathMatches) {
            const match = line.match(pattern);
            if (match) {
                const path = match[1] || match[0];
                return path.trim();
            }
        }
    }
    return undefined;
}
/**
 * Handles special cases where the path might be in a non-standard format
 * Such as in JSON files with _path property
 * @param content - The content to analyze
 * @returns The extracted path or undefined if not found
 */
function extractPathFromSpecialCases(content) {
    try {
        // Check if it's a JSON file
        const jsonContent = JSON.parse(content);
        if (jsonContent._path || jsonContent._file) {
            return jsonContent._path || jsonContent._file;
        }
    }
    catch {
        // Not JSON, continue with normal processing
    }
    return undefined;
}
/**
 * Main function to extract a relative path to one of the main project subdirectories
 * Tries different strategies in order of reliability
 * @param content - The content to analyze
 * @param subdirectories - Optional list of subdirectories to match
 * @returns The extracted path or undefined if not found
 */
function extractRelPath(content, subdirectories) {
    return extractPath(content, subdirectories || ["src", "doc", "tests", "web", "api", "app"]);
}
/**
 * Main function to extract path from content
 * Tries different strategies in order of reliability
 * @param content - The content to analyze
 * @param subdirectories - Optional list of subdirectories to match
 * @returns The extracted path or undefined if not found
 */
function extractPath(content, subdirectories) {
    // First try special cases (like JSON)
    const specialCasePath = extractPathFromSpecialCases(content);
    if (specialCasePath) {
        return filterPathFromSubdirectories(specialCasePath, subdirectories);
    }
    // Then try extracting from comments
    const commentPath = extractPathFromComments(content);
    if (commentPath) {
        return filterPathFromSubdirectories(commentPath, subdirectories);
    }
    return undefined;
}
/**
 * Helper function to filter the path based on the provided subdirectories.
 * Keeps only the path segment from the first match of the subdirectory onwards.
 * @param path - The full path extracted from content
 * @param subdirectories - List of subdirectories to search for in the path
 * @returns The filtered path or the original path if no subdirectory match
 */
function filterPathFromSubdirectories(path, subdirectories) {
    if (!subdirectories)
        return path;
    // Join the subdirectories with | for regex OR, ensuring word boundaries
    const subdirectoryPattern = new RegExp(`\\b(${subdirectories.join("|")})\\b`, "i");
    const match = path.match(subdirectoryPattern);
    if (match && match.index !== undefined) {
        return path.slice(match.index);
    }
    return path;
}


/***/ }),

/***/ "./src/utils/ScriptParser.ts":
/*!***********************************!*\
  !*** ./src/utils/ScriptParser.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/utils/ScriptParser.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScriptParser = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./src/types/index.ts");
const parseStopConditions_1 = __webpack_require__(/*! ./commands/parseStopConditions */ "./src/utils/commands/parseStopConditions.ts");
const CommandMap_1 = __webpack_require__(/*! ./commands/CommandMap */ "./src/utils/commands/CommandMap.ts");
const parseRepeatCommand_1 = __webpack_require__(/*! ./commands/parseRepeatCommand */ "./src/utils/commands/parseRepeatCommand.ts");
const parseAliasCommand_1 = __webpack_require__(/*! ./commands/parseAliasCommand */ "./src/utils/commands/parseAliasCommand.ts");
const parseProjectCommands_1 = __webpack_require__(/*! ./commands/parseProjectCommands */ "./src/utils/commands/parseProjectCommands.ts");
const parseContentCommands_1 = __webpack_require__(/*! ./commands/parseContentCommands */ "./src/utils/commands/parseContentCommands.ts");
const splitText_1 = __webpack_require__(/*! ./splitText */ "./src/utils/splitText.ts");
const parseDocsCommand_1 = __webpack_require__(/*! ./commands/parseDocsCommand */ "./src/utils/commands/parseDocsCommand.ts");
class ScriptParser {
    /**
     * Parses text into a Script object
     */
    static parse(text) {
        const statements = this.parseStatements(text);
        return { statements };
    }
    /**
     * Splits text into statements while preserving quoted strings
     */
    static parseStatements(text) {
        const statements = [];
        let current = "";
        let inQuotes = false;
        let quoteChar = null;
        for (let i = 0; i < text.length; i++) {
            const char = text[i];
            // Handle quoted text
            if ((char === '"' || char === "'") && !inQuotes) {
                inQuotes = true;
                quoteChar = char;
                current += char;
            }
            else if (char === quoteChar && inQuotes) {
                inQuotes = false;
                quoteChar = null;
                current += char;
            }
            // Handle statement separators
            else if (char === ";" && !inQuotes) {
                if (current.trim()) {
                    statements.push(this.parseStatement(current.trim()));
                }
                current = "";
            }
            // Collect characters
            else {
                current += char;
            }
        }
        // Handle final statement
        if (current.trim()) {
            statements.push(this.parseStatement(current.trim()));
        }
        const finalStatements = [];
        statements.forEach((statement) => {
            if (statement.command === "stop_if" ||
                statement.command === "stop_if_not") {
                const last = finalStatements[0];
                if (!last) {
                    throw new Error("Stop statement without preceding prompt.");
                }
                last.addStopCondition({
                    target: statement.prompt || "",
                    type: statement.command === "stop_if" ? "if" : "if_not",
                });
            }
            else {
                finalStatements.push(statement);
            }
        });
        return finalStatements;
    }
    /**
     * Parses a single statement with stop conditions
     */
    static parseStatement(text) {
        const statementText = text.trim();
        // Parse main statement (command or prompt)
        /*let statement = statementText.startsWith(this.COMMAND_PREFIX)
          ? this.parseCommandStatement(statementText)
          : this.parsePromptStatement(statementText);
    */
        const statement = this.parseCommandStatement(statementText);
        return statement;
    }
    /**
     * Parses a prompt statement
     */
    static parsePromptStatement(text) {
        return new types_1.ScriptStatement({
            prompt: text,
            isCommand: false,
            command: null,
        });
    }
    /**
     * Parses a command statement
     */
    static parseCommandStatement(text) {
        const parsed = this.parseCommandText(text);
        switch (parsed.command) {
            case "repeat":
                return (0, parseRepeatCommand_1.parseRepeatCommand)(parsed);
            case "stop_if":
            case "stop_if_not":
                return (0, parseStopConditions_1.parseStopConditionCommand)(parsed);
            case "alias":
            case "list_alias":
            case "delete_alias":
                return (0, parseAliasCommand_1.parseAliasCommand)(parsed);
            case "project":
                return (0, parseProjectCommands_1.parseProjectCommand)(parsed);
            case "search_project":
                return (0, parseProjectCommands_1.parseSearchProjectCommand)(parsed);
            case "query_project":
                return (0, parseProjectCommands_1.parseQueryProjectCommand)(parsed);
            case "conversation":
                return (0, parseContentCommands_1.parseConversationCommand)(parsed);
            case "artifacts":
                return (0, parseContentCommands_1.parseArtifactsCommand)(parsed);
            case "docs":
                return (0, parseDocsCommand_1.parseDocsCommand)(parsed);
            case "prompt": {
                const statement = this.parsePromptStatement(parsed.prompt);
                const stopIfCondition = parsed?.options?.["stop_if"];
                const stopIfNotCondition = parsed?.options?.["stop_if_not"];
                if (stopIfCondition || stopIfNotCondition) {
                    statement.addStopCondition({
                        target: stopIfCondition || stopIfNotCondition,
                        type: stopIfCondition ? "if" : "if_not",
                    });
                }
                return statement;
            }
            default:
                throw new Error(`Unhandled command: ${parsed.command}`);
        }
    }
    /**
     * Parses a multi-line command text
     */
    static parseCommandText(text) {
        const isCommand = text.startsWith(this.COMMAND_PREFIX);
        // Extract command and remaining text
        const parts = (0, splitText_1.splitTextWithQuotes)(text);
        const rawCommand = isCommand ? parts[0] : "";
        let commandName = isCommand ? rawCommand.substring(1) : "prompt";
        if (isCommand) {
            // Resolve command
            const matches = (0, CommandMap_1.getCommandMatches)(commandName);
            if (matches.length === 0) {
                throw new Error(`Unknown command: ${rawCommand}`);
            }
            if (matches.length > 1) {
                throw new Error(`Ambiguous command '${rawCommand}'. Could be: ${matches.join(", ")}`);
            }
            commandName = matches[0].toString();
        }
        // Parse options and content
        const options = {};
        let promptParts = [];
        for (let i = isCommand ? 1 : 0; i < parts.length; i++) {
            const part = parts[i];
            if (part.startsWith(this.COMMAND_PREFIX)) {
                const definitions = (0, CommandMap_1.getCommandOptionDefinitions)(commandName);
                if (!definitions) {
                    throw new Error(`invalid option: "${part}", command "${commandName}" has no options`);
                }
                // Parse option
                const optionKey = part.substring(1);
                const option = definitions[optionKey];
                if (!option) {
                    throw new Error(`invalid option: "${part}", command "${rawCommand}" has options: ${JSON.stringify(Object.keys(definitions))}`);
                }
                if (option === "with_arg") {
                    i++;
                    if (i < parts.length) {
                        options[optionKey] = parts[i];
                    }
                    else {
                        throw new Error(`Missing value for option: "${part}", command "${rawCommand}"`);
                    }
                }
                else if (option === "with_prompt") {
                    i++;
                    let arg = "";
                    while (i < parts.length) {
                        const nextPart = parts[i];
                        if (nextPart.startsWith(this.COMMAND_PREFIX)) {
                            i--;
                            break;
                        }
                        arg = (arg ? " " + arg : "") + parts[i];
                        i++;
                    }
                    if (!arg) {
                        throw new Error(`Missing value for option: "${part}", command "${rawCommand}"`);
                    }
                    options[optionKey] = arg;
                }
                else {
                    options[optionKey] = "true";
                }
            }
            else {
                promptParts.push(part);
            }
        }
        return {
            command: commandName,
            rawCommand,
            options,
            prompt: promptParts.join(" "),
        };
    }
}
exports.ScriptParser = ScriptParser;
ScriptParser.COMMAND_PREFIX = "/";


/***/ }),

/***/ "./src/utils/commands/CommandMap.ts":
/*!******************************************!*\
  !*** ./src/utils/commands/CommandMap.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/utils/commands/CommandMap.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Defines commands and their options
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.COMMAND_MAP = void 0;
exports.getFullCommand = getFullCommand;
exports.getCommandMatches = getCommandMatches;
exports.getCommandOptionDefinitions = getCommandOptionDefinitions;
/**
 * Maps command names to their full names, abbreviations and allowed options
 */
exports.COMMAND_MAP = {
    // Basic commands
    repeat: {
        full: "repeat",
        abbreviation: "r",
        options: {
            max: "with_arg", // Requires number argument
            stop_if: "with_prompt", // Requires condition text
            stop_if_not: "with_prompt", // Requires condition text
        },
    },
    prompt: {
        full: "prompt",
        abbreviation: "",
        options: {
            stop_if: "with_prompt", // Requires condition text
            stop_if_not: "with_prompt", // Requires condition text
        },
    },
    // Content commands
    conversation: {
        full: "conversation",
        abbreviation: "c",
        options: {
            artifacts: "no_arg", // Flag only
            a: "no_arg", // Flag only
            multiple: "no_arg", // Flag only
            m: "no_arg", // Flag only
        },
    },
    stop_if: {
        full: "stop_if",
        abbreviation: "",
    },
    stop_if_not: {
        full: "stop_if_not",
        abbreviation: "",
    },
    artifacts: {
        full: "artifacts",
        abbreviation: "a",
        options: {
            multiple: "no_arg", // Flag only
        },
    },
    // Project commands with no options
    docs: { full: "docs", abbreviation: "d" },
    project: { full: "project", abbreviation: "p" },
    search_project: { full: "search_project", abbreviation: "sp" },
    query_project: { full: "query_project", abbreviation: "qp" },
    // Alias commands (with @ syntax support)
    alias: { full: "alias", abbreviation: "@+" },
    list_alias: { full: "list_alias", abbreviation: "@?" },
    delete_alias: { full: "delete_alias", abbreviation: "@-" },
};
/**
 * Gets the full command name for an abbreviation
 */
function getFullCommand(abbr) {
    // Handle the special case where alias command starts with @
    if (abbr.startsWith("@")) {
        switch (abbr) {
            case "@+":
                return "alias";
            case "@-":
                return "delete_alias";
            case "@?":
                return "list_alias";
            default:
                return undefined;
        }
    }
    const entry = Object.entries(exports.COMMAND_MAP).find(([_, info]) => info.abbreviation === abbr.toLowerCase());
    return entry?.[0];
}
/**
 * Gets all possible command matches for a partial string
 */
function getCommandMatches(partial) {
    // Handle special alias abbreviations
    if (partial.startsWith("@")) {
        switch (partial) {
            case "@+":
                return ["alias"];
            case "@-":
                return ["delete_alias"];
            case "@?":
                return ["list_alias"];
        }
    }
    const search = partial.toLowerCase();
    return Object.entries(exports.COMMAND_MAP)
        .filter(([command, info]) => {
        return info.full === search || info.abbreviation.toLowerCase() === search;
    })
        .map(([command]) => command);
}
/**
 * Gets the option requirements for a command
 */
function getCommandOptionDefinitions(command) {
    const commands = getCommandMatches(command);
    return exports.COMMAND_MAP[commands[0]]?.options;
}


/***/ }),

/***/ "./src/utils/commands/parseAliasCommand.ts":
/*!*************************************************!*\
  !*** ./src/utils/commands/parseAliasCommand.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/utils/commands/parseAliasCommand.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAliasCommand = parseAliasCommand;
exports.isValidAliasName = isValidAliasName;
const types_1 = __webpack_require__(/*! ../../types */ "./src/types/index.ts");
/**
 * Parses an alias command into a script object
 * @param command - The parsed command name
 * @param args - Array of command arguments
 * @returns Parsed script object
 * @throws Error if command syntax is invalid
 */
function parseAliasCommand(parsedCommandLine) {
    const { command, prompt } = parsedCommandLine;
    const baseStatement = new types_1.ScriptStatement({
        isCommand: true,
        command: command,
        options: {},
        prompt: "",
    });
    switch (command) {
        case "alias": {
            // Expect format: /alias @name text
            const aliasArgs = prompt.trim().split(/\s+/);
            if (aliasArgs.length < 2 || !aliasArgs[0].startsWith("@")) {
                throw new Error("Invalid alias syntax. Use: /alias @name text");
            }
            const aliasName = aliasArgs[0].substring(1);
            const aliasText = aliasArgs.slice(1).join(" ");
            if (!isValidAliasName(aliasName)) {
                throw new Error("Invalid alias name. Only alphanumeric characters and underscores are allowed.");
            }
            return new types_1.ScriptStatement({
                isCommand: true,
                command: command,
                aliasCommand: {
                    type: "alias",
                    name: aliasName,
                    text: aliasText,
                },
            });
        }
        case "delete_alias": {
            // Expect format: /delete_alias @name
            const deleteArgs = prompt.trim().split(/\s+/);
            if (deleteArgs.length !== 1 || !deleteArgs[0].startsWith("@")) {
                throw new Error("Invalid delete alias syntax. Use: /delete_alias @name");
            }
            const deleteName = deleteArgs[0].substring(1);
            if (!isValidAliasName(deleteName)) {
                throw new Error("Invalid alias name. Only alphanumeric characters and underscores are allowed.");
            }
            return new types_1.ScriptStatement({
                isCommand: true,
                command: command,
                aliasCommand: {
                    type: "delete_alias",
                    name: deleteName,
                },
            });
        }
        case "list_alias": {
            // Expect format: /list_alias (no arguments)
            if (prompt.trim().length > 0) {
                throw new Error("List alias command takes no arguments. Use: /list_alias");
            }
            return new types_1.ScriptStatement({
                isCommand: true,
                command: command,
                aliasCommand: {
                    type: "list_alias",
                },
            });
        }
        default:
            throw new Error(`Unknown alias command: ${command}`);
    }
}
/**
 * Validates alias command argument format
 * @param name - Alias name to validate
 * @returns True if name is valid
 */
function isValidAliasName(name) {
    return /^[a-zA-Z0-9_]+$/.test(name);
}


/***/ }),

/***/ "./src/utils/commands/parseContentCommands.ts":
/*!****************************************************!*\
  !*** ./src/utils/commands/parseContentCommands.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/utils/commands/parseContentCommands.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseConversationCommand = parseConversationCommand;
exports.parseArtifactsCommand = parseArtifactsCommand;
const types_1 = __webpack_require__(/*! ../../types */ "./src/types/index.ts");
/**
 * Processes basic content command options
 */
function processContentOptions(options) {
    const commandOptions = {};
    // Process options
    for (const [key, _] of Object.entries(options)) {
        switch (key.toLowerCase()) {
            case "artifacts":
            case "a":
                commandOptions.includeArtifacts = true;
                break;
            case "multiple":
            case "m":
                commandOptions.downloadMultiple = true;
                break;
            default:
                throw new Error(`Unknown option: /${key}`);
        }
    }
    return commandOptions;
}
/**
 * Parses a conversation command
 */
function parseConversationCommand(parsedCommandLine) {
    const { options } = parsedCommandLine;
    const commandOptions = processContentOptions(options);
    // Conversation specific defaults
    commandOptions.includeConversation = true;
    // Validate options
    if (commandOptions.downloadMultiple && !commandOptions.includeArtifacts) {
        throw new Error("/multiple can only be used with /artifacts option");
    }
    return new types_1.ScriptStatement({
        isCommand: true,
        command: "conversation",
        options: commandOptions,
        prompt: parsedCommandLine.prompt.trim(),
    });
}
/**
 * Parses an artifacts command
 */
function parseArtifactsCommand(parsedCommandLine) {
    const { options } = parsedCommandLine;
    const commandOptions = processContentOptions(options);
    // Artifacts command always includes artifacts
    commandOptions.includeArtifacts = true;
    commandOptions.includeConversation = false;
    return new types_1.ScriptStatement({
        isCommand: true,
        command: "artifacts",
        options: commandOptions,
        prompt: parsedCommandLine.prompt.trim(),
    });
}


/***/ }),

/***/ "./src/utils/commands/parseDocsCommand.ts":
/*!************************************************!*\
  !*** ./src/utils/commands/parseDocsCommand.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseDocsCommand = parseDocsCommand;
const types_1 = __webpack_require__(/*! ../../types */ "./src/types/index.ts");
/**
 * Parses a basic project command
 */
function parseDocsCommand(parsedCommandLine) {
    return new types_1.ScriptStatement({
        isCommand: true,
        command: "docs",
        prompt: parsedCommandLine.prompt.trim(),
    });
}


/***/ }),

/***/ "./src/utils/commands/parseProjectCommands.ts":
/*!****************************************************!*\
  !*** ./src/utils/commands/parseProjectCommands.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/utils/commands/parseProjectCommands.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseProjectCommand = parseProjectCommand;
exports.parseSearchProjectCommand = parseSearchProjectCommand;
exports.parseQueryProjectCommand = parseQueryProjectCommand;
const types_1 = __webpack_require__(/*! ../../types */ "./src/types/index.ts");
/**
 * Parses a basic project command
 */
function parseProjectCommand(parsedCommandLine) {
    return new types_1.ScriptStatement({
        isCommand: true,
        command: "project",
        prompt: parsedCommandLine.prompt.trim(),
    });
}
/**
 * Parses a project search command with optional search text
 */
function parseSearchProjectCommand(parsedCommandLine) {
    const { prompt } = parsedCommandLine;
    if (!prompt.trim()) {
        throw new Error("Search project command requires search text");
    }
    return new types_1.ScriptStatement({
        isCommand: true,
        command: "search_project",
        searchText: prompt.trim(),
    });
}
/**
 * Parses a project query command with required prompt
 */
function parseQueryProjectCommand(parsedCommandLine) {
    const { prompt } = parsedCommandLine;
    if (!prompt.trim()) {
        throw new Error("Query project command requires a prompt");
    }
    return new types_1.ScriptStatement({
        isCommand: true,
        command: "query_project",
        options: {},
        prompt: prompt.trim(),
    });
}


/***/ }),

/***/ "./src/utils/commands/parseRepeatCommand.ts":
/*!**************************************************!*\
  !*** ./src/utils/commands/parseRepeatCommand.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/utils/commands/parseRepeatCommand.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseRepeatCommand = parseRepeatCommand;
const types_1 = __webpack_require__(/*! ../../types */ "./src/types/index.ts");
const DEFAULT_MAX_TRIES = 3;
/**
 * Parses a repeat command
 * Format: /repeat [/max number] [/stop_if condition | /stop_if_not condition] prompt
 */
function parseRepeatCommand(parsedCommandLine) {
    const { options, prompt } = parsedCommandLine;
    // Extract options
    const maxTries = options.max ? parseInt(options.max, 10) : DEFAULT_MAX_TRIES;
    if (isNaN(maxTries)) {
        throw new Error("Invalid /max value - must be a number");
    }
    // Validate prompt
    if (!prompt || prompt.trim().length === 0) {
        throw new Error("No prompt provided after /repeat command");
    }
    // Handle stop conditions
    const stopIfCondition = options["stop_if"];
    const stopIfNotCondition = options["stop_if_not"];
    if (stopIfCondition && stopIfNotCondition) {
        throw new Error("Cannot use both /stop_if and /stop_if_not options together");
    }
    // Initialize command options
    const commandOptions = {
        maxTries,
    };
    const statement = new types_1.ScriptStatement({
        isCommand: true,
        command: "repeat",
        options: commandOptions,
        prompt: prompt.trim(),
    });
    // Add stop conditions to options if present
    if (stopIfCondition || stopIfNotCondition) {
        statement.addStopCondition({
            target: stopIfCondition || stopIfNotCondition,
            type: stopIfCondition ? "if" : "if_not",
        });
    }
    return statement;
}


/***/ }),

/***/ "./src/utils/commands/parseStopConditions.ts":
/*!***************************************************!*\
  !*** ./src/utils/commands/parseStopConditions.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/utils/commands/parseStopConditions.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseStopConditionCommand = parseStopConditionCommand;
const types_1 = __webpack_require__(/*! ../../types */ "./src/types/index.ts");
/**
 * Parses a stop condition from command text
 */
function parseStopConditionCommand(parsedCommandLine) {
    const target = parsedCommandLine.prompt;
    const type = parsedCommandLine.command === "stop_if" ? "if" : "if_not";
    const statement = new types_1.ScriptStatement({
        isCommand: true,
        command: parsedCommandLine.command,
        options: { stopConditions: [{ target, type }] },
    });
    return statement;
}


/***/ }),

/***/ "./src/utils/getClaudeIds.ts":
/*!***********************************!*\
  !*** ./src/utils/getClaudeIds.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/utils/getClaudeIds.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Utility functions for retrieving organization and project IDs from Claude
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIdsFromUrl = getIdsFromUrl;
exports.getOrganizationId = getOrganizationId;
exports.getProjectUuid = getProjectUuid;
const getHeaders_1 = __webpack_require__(/*! ./getHeaders */ "./src/utils/getHeaders.ts");
const API_URL = "https://api.claude.ai/api/organizations";
/**
 * Gets project and conversation IDs from the current URL
 */
function getIdsFromUrl() {
    const projectMatch = window.location.pathname.match(/\/project\/([^\/]+)/);
    if (projectMatch) {
        return { projectId: projectMatch[1], conversationId: null };
    }
    const chatMatch = window.location.pathname.match(/\/chat\/([^\/]+)/);
    if (!chatMatch) {
        throw new Error("Please navigate to a Claude chat or project page before using this command");
    }
    return {
        projectId: null,
        conversationId: chatMatch[1],
    };
}
/**
 * Gets the organization ID from cookies
 * @throws Error if organization ID is not found or invalid
 */
function getOrganizationId() {
    const cookie = document.cookie
        .split("; ")
        .find((row) => row.startsWith("lastActiveOrg="));
    if (!cookie) {
        throw new Error("Organization ID not found in cookies");
    }
    try {
        const value = decodeURIComponent(cookie.split("=")[1]);
        return value.replace(/^"|"$/g, "");
    }
    catch (error) {
        throw new Error("Invalid organization ID format in cookie");
    }
}
/**
 * Gets the project UUID for API requests
 * @param organizationId - Organization ID to use for API request
 * @returns Promise resolving to project UUID
 * @throws Error if project UUID cannot be retrieved
 */
async function getProjectUuid(organizationId) {
    const { projectId, conversationId } = getIdsFromUrl();
    if (projectId) {
        return projectId;
    }
    if (conversationId) {
        const response = await fetch(`${API_URL}/${organizationId}/chat_conversations/${conversationId}?tree=True&rendering_mode=messages`, {
            method: "GET",
            headers: (0, getHeaders_1.getHeaders)(),
            credentials: "include",
        });
        if (!response.ok) {
            throw new Error(`Failed to fetch conversation details: ${response.status}`);
        }
        const data = await response.json();
        const projectUuid = data.project_uuid;
        if (!projectUuid) {
            throw new Error("Project UUID not found in conversation details");
        }
        return projectUuid;
    }
    throw new Error("No project or conversation ID found in URL");
}


/***/ }),

/***/ "./src/utils/getConversation.ts":
/*!**************************************!*\
  !*** ./src/utils/getConversation.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/utils/getConversation.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Utility functions for retrieving conversation details from Claude's API
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCurrentConversationDetails = getCurrentConversationDetails;
exports.getConversationDetails = getConversationDetails;
const getHeaders_1 = __webpack_require__(/*! ./getHeaders */ "./src/utils/getHeaders.ts");
const getClaudeIds_1 = __webpack_require__(/*! ./getClaudeIds */ "./src/utils/getClaudeIds.ts");
const API_URL = "https://api.claude.ai/api/organizations";
/**
 * Gets current conversation details including latest message ID
 * @returns Promise resolving to { conversationId, parentMessageUuid }
 * @throws Error if conversation details cannot be retrieved
 */
async function getCurrentConversationDetails() {
    // Get conversation ID from URL
    const match = window.location.pathname.match(/\/chat\/([^\/]+)/);
    if (!match) {
        throw new Error("Please navigate to a Claude chat page first");
    }
    const conversationId = match[1];
    return getConversationDetails(conversationId);
}
/**
 * Gets conversation details including latest message ID
 * @param conversationId identifies the conversation for which to get the details.
 * @returns Promise resolving to { conversationId, parentMessageUuid }
 * @throws Error if conversation details cannot be retrieved
 */
async function getConversationDetails(conversationId) {
    const orgId = (0, getClaudeIds_1.getOrganizationId)();
    try {
        // Get conversation details
        const response = await fetch(`${API_URL}/${orgId}/chat_conversations/${conversationId}?tree=True&rendering_mode=messages`, {
            method: "GET",
            headers: (0, getHeaders_1.getHeaders)(),
            credentials: "include",
        });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const conversation = await response.json();
        return conversation;
    }
    catch (error) {
        throw new Error(`Failed to get conversation details: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
}


/***/ }),

/***/ "./src/utils/getHeaders.ts":
/*!*********************************!*\
  !*** ./src/utils/getHeaders.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /src/utils/getHeaders.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHeaders = getHeaders;
function getHeaders() {
    return {
        Accept: "*/*",
        "Accept-Encoding": "gzip, deflate, br, zstd",
        "Accept-Language": "en-US,en;q=0.9,fr-CA;q=0.8,fr;q=0.7",
        "Anthropic-Client-Sha": "unknown",
        "Anthropic-Client-Version": "unknown",
        "Cache-Control": "no-cache",
        "Content-Type": "application/json",
        Origin: "https://claude.ai",
        Pragma: "no-cache",
        Referer: "https://claude.ai/",
        "Sec-Ch-Ua": '"Chromium";v="128", "Not;A=Brand";v="24", "Google Chrome";v="128"',
        "Sec-Ch-Ua-Mobile": "?0",
        "Sec-Ch-Ua-Platform": '"macOS"',
        Priority: "u=1, i",
    };
}


/***/ }),

/***/ "./src/utils/requestCompletion.ts":
/*!****************************************!*\
  !*** ./src/utils/requestCompletion.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/utils/requestCompletion.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.requestCompletion = requestCompletion;
const getHeaders_1 = __webpack_require__(/*! ./getHeaders */ "./src/utils/getHeaders.ts");
const getClaudeIds_1 = __webpack_require__(/*! ./getClaudeIds */ "./src/utils/getClaudeIds.ts");
const getConversation_1 = __webpack_require__(/*! ./getConversation */ "./src/utils/getConversation.ts");
const EventStreamParser_1 = __webpack_require__(/*! ./EventStreamParser */ "./src/utils/EventStreamParser.ts");
const API_URL = "https://api.claude.ai/api/organizations";
const STREAMING_API_URL = "https://claude.ai/api/organizations";
const DEFAULT_TIMEZONE = "America/Toronto";
/**
 * Makes a non-streaming completion request to Claude's API
 */
async function makeNonStreamingRequest(orgId, endpoint, requestBody) {
    const response = await fetch(endpoint, {
        method: "POST",
        headers: {
            ...(0, getHeaders_1.getHeaders)(),
            Accept: "application/json",
        },
        credentials: "include",
        body: JSON.stringify(requestBody),
    });
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    return {
        completion: data.completion,
        stop_reason: data.stop_reason || "", // Convert null to empty string
        model: data.model || "",
        stop: data.stop,
        log_id: data.log_id || "",
        messageLimit: data.messageLimit || {
            type: "none",
            remaining: 0,
        },
    };
}
/**
 * Handles a streaming response with the event stream parser
 */
async function handleStreamingResponse(response, onProgress) {
    if (!response.body) {
        throw new Error("Response has no body");
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    const parser = new EventStreamParser_1.EventStreamParser();
    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done)
                break;
            const chunk = decoder.decode(value, { stream: true });
            const message = parser.processChunk(chunk);
            if (onProgress && message) {
                onProgress(message);
            }
            if (parser.isMessageComplete()) {
                break;
            }
        }
        return parser.getMessage();
    }
    finally {
        reader.releaseLock();
    }
}
/**
 * Makes a completion request to Claude's API
 * @param params Request parameters
 * @returns Promise resolving to completion response
 * @throws Error if the request fails
 */
async function requestCompletion(params) {
    try {
        const orgId = (0, getClaudeIds_1.getOrganizationId)();
        // Get conversation details using appropriate utility function
        const { uuid: conversationId, current_leaf_message_uuid: parentMessageUuid, } = params.conversationId
            ? await (0, getConversation_1.getConversationDetails)(params.conversationId)
            : await (0, getConversation_1.getCurrentConversationDetails)();
        const endpoint = `${STREAMING_API_URL}/${orgId}/chat_conversations/${conversationId}/completion`;
        const requestBody = {
            prompt: params.prompt,
            parent_message_uuid: parentMessageUuid,
            timezone: params.timezone || DEFAULT_TIMEZONE,
            attachments: params.attachments || [],
            files: params.files || [],
            sync_sources: params.syncSources || [],
            rendering_mode: params.renderingMode || "messages",
        };
        if (!params.stream) {
            // Non-streaming request
            return await makeNonStreamingRequest(orgId, endpoint, requestBody);
        }
        // Streaming request
        const response = await fetch(endpoint, {
            method: "POST",
            headers: {
                ...(0, getHeaders_1.getHeaders)(),
                Accept: "text/event-stream",
            },
            credentials: "include",
            body: JSON.stringify(requestBody),
        });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        // Handle streaming response with parser
        const fullCompletion = await handleStreamingResponse(response, params.onProgress);
        return {
            completion: fullCompletion,
            stop_reason: "", // Empty string instead of null
            model: "",
            stop: null,
            log_id: "",
            messageLimit: {
                type: "none",
                remaining: 0,
            },
        };
    }
    catch (error) {
        throw new Error(`Completion request failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
}


/***/ }),

/***/ "./src/utils/splitText.ts":
/*!********************************!*\
  !*** ./src/utils/splitText.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {


// splitTextWithQuotes.ts
/*
 * Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
 * This software is licensed under the MIT License.
 * File path: src/utils/splitText.ts
 * Generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Splits text into tokens, handling quoted strings and escape sequences in unquoted text.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.processQuotedText = processQuotedText;
exports.processUnquotedText = processUnquotedText;
exports.splitTextWithQuotes = splitTextWithQuotes;
/**
 * Text splitting rules:
 *
 * For processQuotedText(text, startIndex, quoteChar):
 * 1. Starts AFTER the opening quote (startIndex is position after quote)
 * 2. Collects ALL characters literally, with NO special processing - this means any quoteChar is an unescaped quoteChar
 * 3. Stops at the first occurrence of quoteChar
 * 4. Returns:
 *    * result: all characters collected up to (but not including) quoteChar
 *    * position: index after the quoteChar
 *
 * For processUnquotedText(text, startIndex):
 * 1. When sees backslash:
 *    * Skips the backslash
 *    * Takes next character literally unless it's a whitespace since that's a delimitor
 * 2. When sees unescaped quote:
 *    * If has collected chars: returns [collected, quotePos, null]
 *    * If no collected chars: returns ["", quotePos, quoteChar]
 * 3. When sees unescaped whitespace:
 *    * Returns [collected, whitespacePos, null]
 * 4. Returns:
 *    * result: collected characters with escape processing
 *    * position: where it stopped
 *    * quoteChar: quote character found (if any) or null
 *
 * For splitTextWithQuotes(text):
 * 1. Skips leading whitespace
 * 2. If sees quote:
 *    * Calls processQuotedText
 *    * Skips trailing whitespace after quote
 * 3. If sees non-quote:
 *    * Calls processUnquotedText
 *    * If it returned a quote char, continues at same position
 *    * If no quote char, skips trailing whitespace
 * 4. Repeats until end of text
 * 5. Only adds non-empty tokens to result array
 * 6. Spaces cannot be escaped
 */
function processQuotedText(text, startIndex, quoteChar) {
    let result = "";
    let i = startIndex;
    while (i < text.length) {
        const char = text[i];
        if (char === quoteChar) {
            return [result, i + 1]; // Skip past closing quote
        }
        result += char;
        i++;
    }
    return [result, i]; // No closing quote found, return all remaining text
}
/**
 * Processes unquoted text, splitting at whitespace and handling escape sequences.
 * Watches for quotes to enable mode switching.
 */
function processUnquotedText(text, startIndex) {
    let result = "";
    let i = startIndex;
    let escaped = false;
    while (i < text.length) {
        const char = text[i];
        if (escaped) {
            if (/\s/.test(char)) {
                // Stop at escaped whitespace - it's a delimiter
                return [result, i, null];
            }
            // For non-whitespace, add literally
            result += char;
            escaped = false;
            i++;
            continue;
        }
        if (char === "\\") {
            escaped = true;
            i++;
            continue;
        }
        if (/\s/.test(char) && !escaped) {
            // Any unescaped whitespace is a delimiter
            return [result, i, null];
        }
        if ((char === '"' || char === "'") && !escaped) {
            // Handle both quote types the same way
            if (result === "") {
                // If we haven't collected any chars, return the quote char found
                return ["", i, char];
            }
            // If we have collected chars, return them and let caller handle the quote
            return [result, i, null];
        }
        result += char;
        i++;
    }
    return [result, i, null];
}
/**
 * Splits a given text into tokens based on whitespace and quotes.
 * Processes escape sequences only in unquoted text.
 */
function splitTextWithQuotes(text) {
    const result = [];
    let i = 0;
    text = text.trim();
    while (i < text.length) {
        if (text[i] === '"' || text[i] === "'") {
            const [token, newIndex] = processQuotedText(text, i + 1, text[i]);
            if (token !== "") {
                result.push(token); // No trim - quoted text is literal
            }
            i = newIndex;
        }
        else {
            const [token, newIndex, quoteChar] = processUnquotedText(text, i);
            if (token !== "") {
                result.push(token); // No trim - processUnquotedText handles it
            }
            if (token === "" && newIndex === i) {
                i++;
            }
            else {
                i = newIndex;
            }
        }
    }
    return result;
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __webpack_exports__;
/*!************************!*\
  !*** ./src/content.ts ***!
  \************************/

/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/content.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ClaudeExtension_1 = __webpack_require__(/*! ./ClaudeExtension */ "./src/ClaudeExtension.ts");
console.log("Claude Extension loading...");
// Prevent multiple initializations
if (window.claudeExtInitialized) {
    console.log("Claude Extension already initialized, skipping...");
}
else {
    console.log("Claude Extension initializing...");
    // Simple element waiter - keeping what works
    function waitForElement(selector) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                observer.disconnect();
                reject(new Error(`Timeout waiting for element: ${selector}`));
            }, 30000);
            if (document.querySelector(selector)) {
                console.log("Element found immediately:", selector);
                clearTimeout(timeout);
                return resolve(document.querySelector(selector));
            }
            console.log("Waiting for element:", selector);
            const observer = new MutationObserver(() => {
                if (document.querySelector(selector)) {
                    console.log("Element found after mutation:", selector);
                    clearTimeout(timeout);
                    observer.disconnect();
                    resolve(document.querySelector(selector));
                }
            });
            observer.observe(document.body, {
                childList: true,
                subtree: true,
            });
        });
    }
    // Initialize with same pattern as working version
    async function initialize() {
        try {
            console.log("Starting initialization...");
            // Check if we're on claude.ai
            if (!window.location.hostname.includes("claude.ai")) {
                console.log("Not on claude.ai, skipping initialization");
                return;
            }
            console.log("Waiting for Claude chat interface...");
            // Wait for elements BEFORE creating any UI
            await waitForElement('div[enterkeyhint="enter"]');
            console.log("Chat container found");
            // Only now create the UI
            const extension = new ClaudeExtension_1.ClaudeExtension();
            await extension.initializeUI();
            // Only NOW mark as initialized - after everything is complete
            window.claudeExtInitialized = true;
            console.log("Initialization complete");
        }
        catch (error) {
            console.error("Initialization failed:", error);
            // Show error to user
            const errorDiv = document.createElement("div");
            errorDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #ffebee;
                color: #c62828;
                padding: 15px;
                border-radius: 8px;
                z-index: 999999;
                font-family: Arial, sans-serif;
                box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            `;
            errorDiv.textContent = `Claude Extension Error: ${error instanceof Error ? error.message : "Unknown error"}`;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }
    }
    // Use proper async/await for initialization timing
    if (document.readyState === "loading") {
        console.log("Document loading, adding DOMContentLoaded listener...");
        document.addEventListener("DOMContentLoaded", async () => {
            // Wait for initialization to complete before continuing
            await initialize();
        });
    }
    else {
        console.log("Document already loaded, initializing...");
        // Wait for initialization to complete before continuing
        (async () => {
            await initialize();
        })();
    }
}

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDO0lBRUQsbURBQW1EO0lBQ25ELElBQUksUUFBUSxDQUFDLFVBQVUsS0FBSyxTQUFTLEVBQUUsQ0FBQztRQUN0QyxPQUFPLENBQUMsR0FBRyxDQUFDLHVEQUF1RCxDQUFDLENBQUM7UUFDckUsUUFBUSxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3ZELHdEQUF3RDtZQUN4RCxNQUFNLFVBQVUsRUFBRSxDQUFDO1FBQ3JCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztTQUFNLENBQUM7UUFDTixPQUFPLENBQUMsR0FBRyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7UUFDeEQsd0RBQXdEO1FBQ3hELENBQUMsS0FBSyxJQUFJLEVBQUU7WUFDVixNQUFNLFVBQVUsRUFBRSxDQUFDO1FBQ3JCLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDUCxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvQ2xhdWRlRXh0ZW5zaW9uLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvc2VydmljZXMvQWxpYXNTZXJ2aWNlLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvc2VydmljZXMvQW50aHJvcGljU2VydmljZS50cyIsIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL3NlcnZpY2VzL0NsYXVkZUNhY2hlLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvc2VydmljZXMvQ29tbWFuZEV4ZWN1dG9yLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvc2VydmljZXMvQ29udmVyc2F0aW9uUmV0cmlldmFsLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvc2VydmljZXMvRG9jdW1lbnREb3dubG9hZC50cyIsIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL3NlcnZpY2VzL0RvY3VtZW50UmV0cmlldmFsLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvc2VydmljZXMvUHJvamVjdFJldHJpZXZhbC50cyIsIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL3NlcnZpY2VzL1Byb2plY3RTZWFyY2hTZXJ2aWNlLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvc2VydmljZXMvUHJvbXB0QWxsLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvc2VydmljZXMvU2NyaXB0RXhlY3V0aW9uTWFuYWdlci50cyIsIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL3NlcnZpY2VzL1NjcmlwdFJ1bm5lci50cyIsIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL3NlcnZpY2VzL1NldHRpbmdzU2VydmljZS50cyIsIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL3NlcnZpY2VzL1dpbmRvd1N0YXRlU2VydmljZS50cyIsIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL3R5cGVzL2luZGV4LnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvdHlwZXMvc3RvcmFnZS50cyIsIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL3VpL2NvbXBvbmVudHMvQ29udGVudFByZXZpZXcudHMiLCJ3ZWJwYWNrOi8vY2xhdWRlLWV4dGVuc2lvbi8uL3NyYy91aS9jb21wb25lbnRzL0NvbnZlcnNhdGlvblByZXZpZXcudHMiLCJ3ZWJwYWNrOi8vY2xhdWRlLWV4dGVuc2lvbi8uL3NyYy91aS9jb21wb25lbnRzL0Rvd25sb2FkVGFibGUudHMiLCJ3ZWJwYWNrOi8vY2xhdWRlLWV4dGVuc2lvbi8uL3NyYy91aS9jb21wb25lbnRzL0Rvd25sb2FkV2lkZ2V0cy50cyIsIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL3VpL2NvbXBvbmVudHMvRHJhZ2dhYmxlTWFuYWdlci50cyIsIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL3VpL2NvbXBvbmVudHMvRWRpdGFibGVDZWxsLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvdWkvY29tcG9uZW50cy9GbG9hdGluZ1dpbmRvdy50cyIsIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL3VpL2NvbXBvbmVudHMvSGVscE1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vY2xhdWRlLWV4dGVuc2lvbi8uL3NyYy91aS9jb21wb25lbnRzL1NlYXJjaFJlc3VsdFByZXZpZXcudHMiLCJ3ZWJwYWNrOi8vY2xhdWRlLWV4dGVuc2lvbi8uL3NyYy91aS9jb21wb25lbnRzL1N0YXR1c01hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vY2xhdWRlLWV4dGVuc2lvbi8uL3NyYy91aS9jb21wb25lbnRzL1VJU3RhdGVNYW5hZ2VyLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvdXRpbHMvRXZlbnRTdHJlYW1QYXJzZXIudHMiLCJ3ZWJwYWNrOi8vY2xhdWRlLWV4dGVuc2lvbi8uL3NyYy91dGlscy9QYXRoRXh0cmFjdG9yLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvdXRpbHMvU2NyaXB0UGFyc2VyLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvdXRpbHMvY29tbWFuZHMvQ29tbWFuZE1hcC50cyIsIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL3V0aWxzL2NvbW1hbmRzL3BhcnNlQWxpYXNDb21tYW5kLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvdXRpbHMvY29tbWFuZHMvcGFyc2VDb250ZW50Q29tbWFuZHMudHMiLCJ3ZWJwYWNrOi8vY2xhdWRlLWV4dGVuc2lvbi8uL3NyYy91dGlscy9jb21tYW5kcy9wYXJzZURvY3NDb21tYW5kLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvdXRpbHMvY29tbWFuZHMvcGFyc2VQcm9qZWN0Q29tbWFuZHMudHMiLCJ3ZWJwYWNrOi8vY2xhdWRlLWV4dGVuc2lvbi8uL3NyYy91dGlscy9jb21tYW5kcy9wYXJzZVJlcGVhdENvbW1hbmQudHMiLCJ3ZWJwYWNrOi8vY2xhdWRlLWV4dGVuc2lvbi8uL3NyYy91dGlscy9jb21tYW5kcy9wYXJzZVN0b3BDb25kaXRpb25zLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvdXRpbHMvZ2V0Q2xhdWRlSWRzLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvdXRpbHMvZ2V0Q29udmVyc2F0aW9uLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvdXRpbHMvZ2V0SGVhZGVycy50cyIsIndlYnBhY2s6Ly9jbGF1ZGUtZXh0ZW5zaW9uLy4vc3JjL3V0aWxzL3JlcXVlc3RDb21wbGV0aW9uLnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vLi9zcmMvdXRpbHMvc3BsaXRUZXh0LnRzIiwid2VicGFjazovL2NsYXVkZS1leHRlbnNpb24vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vY2xhdWRlLWV4dGVuc2lvbi8uL3NyYy9jb250ZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDI0IE1hcnRpbiBCZWNoYXJkIDxtYXJ0aW4uYmVjaGFyZEBEZXZDb25zdWx0LmNhPlxuICogVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBGaWxlOiAvVXNlcnMvbWFydGluYmVjaGFyZC9kZXYvY2xhdWRlZXh0L3NyYy9DbGF1ZGVFeHRlbnNpb24udHNcbiAqIFRoaXMgd2FzIGdlbmVyYXRlZCBieSBDbGF1ZGUgU29ubmV0IDMuNSwgd2l0aCB0aGUgYXNzaXN0YW5jZSBvZiBteSBodW1hbiBtZW50b3JcbiAqXG4gKiBNYWluIGV4dGVuc2lvbiBjbGFzcyB0aGF0IGhhbmRsZXMgVUkgYW5kIHNjcmlwdCBleGVjdXRpb24gYWZ0ZXIgcmVxdWlyZWQgZWxlbWVudHMgZXhpc3QuXG4gKiBOb3RlOiBUaGlzIGNsYXNzIGFzc3VtZXMgZWxlbWVudHMgYXJlIGFscmVhZHkgcHJlc2VudCAtIGluaXRpYWxpemF0aW9uIGhhcHBlbnMgaW4gY29udGVudC50c1xuICovXG5cbmltcG9ydCB7IEZsb2F0aW5nV2luZG93IH0gZnJvbSBcIi4vdWkvY29tcG9uZW50cy9GbG9hdGluZ1dpbmRvd1wiO1xuaW1wb3J0IHsgRHJhZ2dhYmxlTWFuYWdlciB9IGZyb20gXCIuL3VpL2NvbXBvbmVudHMvRHJhZ2dhYmxlTWFuYWdlclwiO1xuaW1wb3J0IHsgU3RhdHVzTWFuYWdlciB9IGZyb20gXCIuL3VpL2NvbXBvbmVudHMvU3RhdHVzTWFuYWdlclwiO1xuaW1wb3J0IHsgVUlTdGF0ZU1hbmFnZXIgfSBmcm9tIFwiLi91aS9jb21wb25lbnRzL1VJU3RhdGVNYW5hZ2VyXCI7XG5pbXBvcnQgeyBTY3JpcHRFeGVjdXRpb25NYW5hZ2VyIH0gZnJvbSBcIi4vc2VydmljZXMvU2NyaXB0RXhlY3V0aW9uTWFuYWdlclwiO1xuaW1wb3J0IHsgSGVscE1hbmFnZXIgfSBmcm9tIFwiLi91aS9jb21wb25lbnRzL0hlbHBNYW5hZ2VyXCI7XG5pbXBvcnQgeyBBbGlhc1NlcnZpY2UgfSBmcm9tIFwiLi9zZXJ2aWNlcy9BbGlhc1NlcnZpY2VcIjtcbmltcG9ydCB0eXBlIHsgRmxvYXRpbmdXaW5kb3dFbGVtZW50cywgU3RhdHVzRWxlbWVudHMgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG5leHBvcnQgY2xhc3MgQ2xhdWRlRXh0ZW5zaW9uIHtcbiAgcHJpdmF0ZSBmbG9hdGluZ1dpbmRvdz86IEZsb2F0aW5nV2luZG93O1xuICBwcml2YXRlIGRyYWdnYWJsZU1hbmFnZXI/OiBEcmFnZ2FibGVNYW5hZ2VyO1xuICBwcml2YXRlIHN0YXR1c01hbmFnZXI/OiBTdGF0dXNNYW5hZ2VyO1xuICBwcml2YXRlIHVpU3RhdGVNYW5hZ2VyPzogVUlTdGF0ZU1hbmFnZXI7XG4gIHByaXZhdGUgc2NyaXB0RXhlY3V0aW9uTWFuYWdlcj86IFNjcmlwdEV4ZWN1dGlvbk1hbmFnZXI7XG4gIHByaXZhdGUgaGVscE1hbmFnZXI/OiBIZWxwTWFuYWdlcjtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBVSSBjb21wb25lbnRzIGFuZCBiaW5kIGV2ZW50IGxpc3RlbmVycy5cbiAgICogU2hvdWxkIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHJlcXVpcmVkIGVsZW1lbnRzIGV4aXN0IGluIHRoZSBET00uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZVVJKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKFwiSW5pdGlhbGl6aW5nIFVJIGNvbXBvbmVudHMuLi5cIik7XG5cbiAgICB0cnkge1xuICAgICAgLy8gSW5pdGlhbGl6ZSBBbGlhc1NlcnZpY2UgZmlyc3RcbiAgICAgIEFsaWFzU2VydmljZS5pbml0aWFsaXplKCk7XG5cbiAgICAgIC8vIENyZWF0ZSBVSSBjb21wb25lbnRzXG4gICAgICB0aGlzLmZsb2F0aW5nV2luZG93ID0gbmV3IEZsb2F0aW5nV2luZG93KCk7XG4gICAgICBjb25zdCB3aW5kb3dFbGVtZW50ID0gYXdhaXQgdGhpcy5mbG9hdGluZ1dpbmRvdy5jcmVhdGUoKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5mbG9hdGluZ1dpbmRvdy5nZXRFbGVtZW50cygpO1xuXG4gICAgICAvLyBDcmVhdGUgc3RhdHVzIGVsZW1lbnRzIG1hcHBpbmdcbiAgICAgIGNvbnN0IHN0YXR1c0VsZW1lbnRzOiBTdGF0dXNFbGVtZW50cyA9IHtcbiAgICAgICAgc3RhdHVzRWxlbWVudDogZWxlbWVudHMuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiBlbGVtZW50cy5zdGF0dXNUZXh0LFxuICAgICAgICBzdGF0dXNEZXRhaWxzOiBlbGVtZW50cy5zdGF0dXNEZXRhaWxzLFxuICAgICAgICBzY3JpcHRJbnB1dDogZWxlbWVudHMuc2NyaXB0VGV4dCxcbiAgICAgICAgcnVuQnV0dG9uOiBlbGVtZW50cy5ydW5CdXR0b24sXG4gICAgICB9O1xuXG4gICAgICAvLyBTZXQgdXAgbWFuYWdlcnNcbiAgICAgIHRoaXMuc3RhdHVzTWFuYWdlciA9IG5ldyBTdGF0dXNNYW5hZ2VyKHN0YXR1c0VsZW1lbnRzKTtcbiAgICAgIHRoaXMuZHJhZ2dhYmxlTWFuYWdlciA9IG5ldyBEcmFnZ2FibGVNYW5hZ2VyKFxuICAgICAgICB3aW5kb3dFbGVtZW50LFxuICAgICAgICBlbGVtZW50cy5zdGF0dXNcbiAgICAgICk7XG4gICAgICB0aGlzLnVpU3RhdGVNYW5hZ2VyID0gbmV3IFVJU3RhdGVNYW5hZ2VyKGVsZW1lbnRzLCB0aGlzLnN0YXR1c01hbmFnZXIpO1xuICAgICAgdGhpcy5zY3JpcHRFeGVjdXRpb25NYW5hZ2VyID0gbmV3IFNjcmlwdEV4ZWN1dGlvbk1hbmFnZXIoXG4gICAgICAgIHRoaXMuc3RhdHVzTWFuYWdlcixcbiAgICAgICAgdGhpcy5oYW5kbGVMb2cuYmluZCh0aGlzKSxcbiAgICAgICAgZWxlbWVudHMub3V0cHV0XG4gICAgICApO1xuICAgICAgdGhpcy5oZWxwTWFuYWdlciA9IG5ldyBIZWxwTWFuYWdlcihlbGVtZW50cy5vdXRwdXQpO1xuXG4gICAgICAvLyBCaW5kIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoZWxlbWVudHMpO1xuXG4gICAgICBjb25zb2xlLmxvZyhcIlVJIGluaXRpYWxpemF0aW9uIGNvbXBsZXRlXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVUkgaW5pdGlhbGl6YXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgZXZlbnQgbGlzdGVuZXJzIHRvIFVJIGVsZW1lbnRzXG4gICAqL1xuICBwcml2YXRlIGJpbmRFdmVudExpc3RlbmVycyhlbGVtZW50czogRmxvYXRpbmdXaW5kb3dFbGVtZW50cyk6IHZvaWQge1xuICAgIC8vIFJ1biBidXR0b24gdHJpZ2dlcnMgc2NyaXB0IGV4ZWN1dGlvblxuICAgIGVsZW1lbnRzLnJ1bkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT5cbiAgICAgIHRoaXMuaGFuZGxlUnVuU2NyaXB0KGVsZW1lbnRzLnNjcmlwdFRleHQpXG4gICAgKTtcblxuICAgIC8vIEhlbHAgYnV0dG9uIHNob3dzIGhlbHAgdGV4dFxuICAgIGVsZW1lbnRzLmhlbHBCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+XG4gICAgICB0aGlzLmhlbHBNYW5hZ2VyPy5zaG93KClcbiAgICApO1xuXG4gICAgLy8gTWluaW1pemUgYW5kIGNvbGxhcHNlIGJ1dHRvbnMgY29udHJvbCB3aW5kb3cgc3RhdGVcbiAgICBlbGVtZW50cy5taW5pbWl6ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT5cbiAgICAgIHRoaXMudWlTdGF0ZU1hbmFnZXI/LnRvZ2dsZU1pbmltaXplKClcbiAgICApO1xuICAgIGVsZW1lbnRzLmNvbGxhcHNlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PlxuICAgICAgdGhpcy51aVN0YXRlTWFuYWdlcj8udG9nZ2xlQ29sbGFwc2UoKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBzY3JpcHQgZXhlY3V0aW9uIGZyb20gdGhlIFVJXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGhhbmRsZVJ1blNjcmlwdChcbiAgICBzY3JpcHRUZXh0OiBIVE1MVGV4dEFyZWFFbGVtZW50XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5zY3JpcHRFeGVjdXRpb25NYW5hZ2VyKSB7XG4gICAgICB0aGlzLmhhbmRsZUxvZyhcIlNjcmlwdCBleGVjdXRpb24gbWFuYWdlciBub3QgaW5pdGlhbGl6ZWRcIiwgXCJlcnJvclwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0dXNNYW5hZ2VyPy5nZXRDdXJyZW50U3RhdGUoKSA9PT0gXCJ3b3JraW5nXCIpIHtcbiAgICAgIHRoaXMuc2NyaXB0RXhlY3V0aW9uTWFuYWdlci5jYW5jZWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgdGhpcy5zY3JpcHRFeGVjdXRpb25NYW5hZ2VyLmV4ZWN1dGVTY3JpcHQoc2NyaXB0VGV4dC52YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgbG9nZ2luZyBvdXRwdXQgdG8gdGhlIFVJXG4gICAqL1xuICBwcml2YXRlIGhhbmRsZUxvZyhcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgdHlwZTogXCJpbmZvXCIgfCBcImVycm9yXCIgfCBcInN1Y2Nlc3NcIiA9IFwiaW5mb1wiXG4gICk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgIHRoaXMudWlTdGF0ZU1hbmFnZXI/LmxvZyhtZXNzYWdlLCB0eXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5mbG9hdGluZ1dpbmRvdz8uZGVzdHJveSgpO1xuICAgIHRoaXMuZHJhZ2dhYmxlTWFuYWdlcj8uZGVzdHJveSgpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogc3JjL3NlcnZpY2VzL0FsaWFzU2VydmljZS50c1xuICogVGhpcyB3YXMgZ2VuZXJhdGVkIGJ5IENsYXVkZSBTb25uZXQgMy41LCB3aXRoIHRoZSBhc3Npc3RhbmNlIG9mIG15IGh1bWFuIG1lbnRvclxuICovXG5cbmltcG9ydCB7IElTdG9yYWdlLCBCcm93c2VyU3RvcmFnZSwgTWVtb3J5U3RvcmFnZSB9IGZyb20gXCIuLi90eXBlcy9zdG9yYWdlXCI7XG5cbi8qKlxuICogU3RydWN0dXJlIGZvciBzdG9yaW5nIGFsaWFzIGRhdGFcbiAqL1xuaW50ZXJmYWNlIEFsaWFzRGF0YSB7XG4gIFtrZXk6IHN0cmluZ106IHN0cmluZztcbn1cblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBtYW5hZ2luZyBhbGlhc2VzIHN0b3JlZCBpbiBzdG9yYWdlXG4gKi9cbmV4cG9ydCBjbGFzcyBBbGlhc1NlcnZpY2Uge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTVE9SQUdFX0tFWSA9IFwiY2xhdWRlX2V4dGVuc2lvbl9hbGlhc2VzXCI7XG4gIHByaXZhdGUgc3RhdGljIHN0b3JhZ2U6IElTdG9yYWdlO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBzdG9yYWdlIHN5c3RlbVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBpbml0aWFsaXplKHN0b3JhZ2U/OiBJU3RvcmFnZSk6IHZvaWQge1xuICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUZXN0IGlmIHdlJ3JlIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudFxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgICAgdGhpcy5zdG9yYWdlID0gbmV3IEJyb3dzZXJTdG9yYWdlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdG9yYWdlID0gbmV3IE1lbW9yeVN0b3JhZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gbmV3IE1lbW9yeVN0b3JhZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlcyBzdG9yYWdlIGlzIGluaXRpYWxpemVkXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBlbnN1cmVTdG9yYWdlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5zdG9yYWdlKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGFsbCBzdG9yZWQgYWxpYXNlc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXRBbGlhc2VzKCk6IEFsaWFzRGF0YSB7XG4gICAgdGhpcy5lbnN1cmVTdG9yYWdlKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLlNUT1JBR0VfS0VZKTtcbiAgICAgIHJldHVybiBkYXRhID8gSlNPTi5wYXJzZShkYXRhKSA6IHt9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmV0cmlldmluZyBhbGlhc2VzOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBzcGVjaWZpYyBhbGlhcyBieSBuYW1lXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldEFsaWFzKG5hbWU6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgdGhpcy5lbnN1cmVTdG9yYWdlKCk7XG4gICAgY29uc3QgYWxpYXNlcyA9IHRoaXMuZ2V0QWxpYXNlcygpO1xuICAgIHJldHVybiBhbGlhc2VzW25hbWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgb3IgdXBkYXRlcyBhbiBhbGlhc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzZXRBbGlhcyhuYW1lOiBzdHJpbmcsIHRleHQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuZW5zdXJlU3RvcmFnZSgpO1xuICAgIGlmICghdGhpcy5pc1ZhbGlkQWxpYXNOYW1lKG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiSW52YWxpZCBhbGlhcyBuYW1lLiBVc2Ugb25seSBsZXR0ZXJzLCBudW1iZXJzLCBhbmQgdW5kZXJzY29yZXMuXCJcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFsaWFzZXMgPSB0aGlzLmdldEFsaWFzZXMoKTtcbiAgICAgIGFsaWFzZXNbbmFtZV0gPSB0ZXh0O1xuICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoYWxpYXNlcykpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gc2F2ZSBhbGlhczogJHtcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiXG4gICAgICAgIH1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGFuIGFsaWFzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGRlbGV0ZUFsaWFzKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRoaXMuZW5zdXJlU3RvcmFnZSgpO1xuICAgIGNvbnN0IGFsaWFzZXMgPSB0aGlzLmdldEFsaWFzZXMoKTtcbiAgICBpZiAoIShuYW1lIGluIGFsaWFzZXMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGVsZXRlIGFsaWFzZXNbbmFtZV07XG4gICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoYWxpYXNlcykpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhbiBhbGlhcyBuYW1lXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBpc1ZhbGlkQWxpYXNOYW1lKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAvXlthLXpBLVowLTlfXSskLy50ZXN0KG5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyB0ZXh0IHRvIHJlcGxhY2UgYWxsIGFsaWFzZXMgd2l0aCB0aGVpciB2YWx1ZXNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcHJvY2Vzc1RleHQodGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICB0aGlzLmVuc3VyZVN0b3JhZ2UoKTtcbiAgICBjb25zdCBhbGlhc2VzID0gdGhpcy5nZXRBbGlhc2VzKCk7XG4gICAgbGV0IHByb2Nlc3NlZFRleHQgPSB0ZXh0O1xuXG4gICAgLy8gU29ydCBhbGlhc2VzIGJ5IGxlbmd0aCAobG9uZ2VzdCBmaXJzdCkgdG8gaGFuZGxlIG5lc3RlZCBhbGlhc2VzIGNvcnJlY3RseVxuICAgIGNvbnN0IHNvcnRlZEFsaWFzZXMgPSBPYmplY3QuZW50cmllcyhhbGlhc2VzKS5zb3J0KFxuICAgICAgKGEsIGIpID0+IGJbMF0ubGVuZ3RoIC0gYVswXS5sZW5ndGhcbiAgICApO1xuXG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIHNvcnRlZEFsaWFzZXMpIHtcbiAgICAgIC8vIFVzZSBsb29rYmVoaW5kIHRvIGVuc3VyZSBAIGlzIG5vdCBwcmVjZWRlZCBieSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYCg/PCFcXFxcUylAJHtuYW1lfVxcXFxiYCwgXCJnXCIpO1xuICAgICAgcHJvY2Vzc2VkVGV4dCA9IHByb2Nlc3NlZFRleHQucmVwbGFjZShyZWdleCwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9jZXNzZWRUZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgYWxpYXNlcyBmcm9tIHN0b3JhZ2VcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgY2xlYXJBbGxBbGlhc2VzKCk6IHZvaWQge1xuICAgIHRoaXMuZW5zdXJlU3RvcmFnZSgpO1xuICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuU1RPUkFHRV9LRVkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBmb3JtYXR0ZWQgbGlzdCBvZiBhbGwgYWxpYXNlc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBnZXRBbGlhc0xpc3QoKTogc3RyaW5nW10ge1xuICAgIHRoaXMuZW5zdXJlU3RvcmFnZSgpO1xuICAgIGNvbnN0IGFsaWFzZXMgPSB0aGlzLmdldEFsaWFzZXMoKTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYWxpYXNlcykubWFwKChbbmFtZSwgdmFsdWVdKSA9PiBgQCR7bmFtZX06ICR7dmFsdWV9YCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDI0IE1hcnRpbiBCZWNoYXJkIDxtYXJ0aW4uYmVjaGFyZEBEZXZDb25zdWx0LmNhPlxuICogVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBGaWxlOiBzcmMvc2VydmljZXMvQW50aHJvcGljU2VydmljZS50c1xuICogVGhpcyB3YXMgZ2VuZXJhdGVkIGJ5IENsYXVkZSBTb25uZXQgMy41LCB3aXRoIHRoZSBhc3Npc3RhbmNlIG9mIG15IGh1bWFuIG1lbnRvclxuICpcbiAqIFNlcnZpY2UgZm9yIG1ha2luZyByZXF1ZXN0cyB0byB0aGUgQW50aHJvcGljIEFQSVxuICogTm90ZTogWW91ciBmcmllbmRseSBuZWlnaGJvcmhvb2QgQUkgQVBJIHdoaXNwZXJlciFcbiAqL1xuXG5pbXBvcnQgeyBTZXR0aW5nc1NlcnZpY2UgfSBmcm9tIFwiLi9TZXR0aW5nc1NlcnZpY2VcIjtcblxuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlIHtcbiAgcm9sZTogXCJ1c2VyXCIgfCBcImFzc2lzdGFudFwiO1xuICBjb250ZW50OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQW50aHJvcGljUmVzcG9uc2Uge1xuICBpZDogc3RyaW5nO1xuICB0eXBlOiBzdHJpbmc7XG4gIHJvbGU6IHN0cmluZztcbiAgY29udGVudDogQXJyYXk8e1xuICAgIHR5cGU6IHN0cmluZztcbiAgICB0ZXh0OiBzdHJpbmc7XG4gIH0+O1xuICBtb2RlbDogc3RyaW5nO1xuICBzdG9wX3JlYXNvbjogc3RyaW5nIHwgbnVsbDtcbiAgc3RvcF9zZXF1ZW5jZTogc3RyaW5nIHwgbnVsbDtcbiAgdXNhZ2U6IHtcbiAgICBpbnB1dF90b2tlbnM6IG51bWJlcjtcbiAgICBvdXRwdXRfdG9rZW5zOiBudW1iZXI7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvbk9wdGlvbnMge1xuICBtYXhUb2tlbnM/OiBudW1iZXI7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuICB0b3BQPzogbnVtYmVyO1xuICB0b3BLPzogbnVtYmVyO1xuICBzaWduYWw/OiBBYm9ydFNpZ25hbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uUmVzdWx0IHtcbiAgc3VjY2VzczogYm9vbGVhbjtcbiAgdGV4dD86IHN0cmluZztcbiAgZXJyb3I/OiBzdHJpbmc7XG4gIGNhbmNlbGxlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBBbnRocm9waWNTZXJ2aWNlIHtcbiAgLyoqXG4gICAqIE1ha2VzIGEgcmVxdWVzdCB0byB0aGUgQW50aHJvcGljIEFQSSB0aHJvdWdoIHRoZSBiYWNrZ3JvdW5kIHNjcmlwdFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBjb21wbGV0ZShcbiAgICBtZXNzYWdlczogTWVzc2FnZVtdLFxuICAgIG9wdGlvbnM6IENvbXBsZXRpb25PcHRpb25zID0ge31cbiAgKTogUHJvbWlzZTxDb21wbGV0aW9uUmVzdWx0PiB7XG4gICAgY29uc29sZS5sb2coXCJbQW50aHJvcGljU2VydmljZV0gU3RhcnRpbmcgQVBJIHJlcXVlc3RcIik7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCBTZXR0aW5nc1NlcnZpY2UudmFsaWRhdGVTZXR0aW5ncygpO1xuICAgICAgaWYgKCFzZXR0aW5ncy52YWxpZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltBbnRocm9waWNTZXJ2aWNlXSBJbnZhbGlkIHNldHRpbmdzOlwiLCBzZXR0aW5ncy5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogc2V0dGluZ3MubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXBpS2V5ID0gYXdhaXQgU2V0dGluZ3NTZXJ2aWNlLmdldFNldHRpbmcoXCJhbnRocm9waWNBcGlLZXlcIik7XG4gICAgICBpZiAoIWFwaUtleSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIltBbnRocm9waWNTZXJ2aWNlXSBObyBBUEkga2V5IGZvdW5kXCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBcIkFQSSBrZXkgbm90IGZvdW5kIGluIHNldHRpbmdzXCIsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1vZGVsID0gYXdhaXQgU2V0dGluZ3NTZXJ2aWNlLmdldFNldHRpbmcoXCJtb2RlbFwiKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiW0FudGhyb3BpY1NlcnZpY2VdIFVzaW5nIG1vZGVsOlwiLCBtb2RlbCk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0ge1xuICAgICAgICBtb2RlbCxcbiAgICAgICAgbWVzc2FnZXMsXG4gICAgICAgIG1heF90b2tlbnM6IG9wdGlvbnMubWF4VG9rZW5zIHx8IDEwMjQsXG4gICAgICAgIHRlbXBlcmF0dXJlOiBvcHRpb25zLnRlbXBlcmF0dXJlLFxuICAgICAgICB0b3BfcDogb3B0aW9ucy50b3BQLFxuICAgICAgICB0b3Bfazogb3B0aW9ucy50b3BLLFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbQW50aHJvcGljU2VydmljZV0gU2VuZGluZyBtZXNzYWdlIHRvIGJhY2tncm91bmQgc2NyaXB0XCIpO1xuXG4gICAgICAgIC8vIFNldCB1cCBhYm9ydCBoYW5kbGVyIGlmIHNpZ25hbCBpcyBwcm92aWRlZFxuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICBvcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbQW50aHJvcGljU2VydmljZV0gUmVxdWVzdCBjYW5jZWxsZWRcIik7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGNhbmNlbGxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgZXJyb3I6IFwiUmVxdWVzdCBjYW5jZWxsZWRcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gSWYgc2lnbmFsIGlzIGFscmVhZHkgYWJvcnRlZCwgcmVzb2x2ZSBpbW1lZGlhdGVseVxuICAgICAgICAgIGlmIChvcHRpb25zLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIltBbnRocm9waWNTZXJ2aWNlXSBTaWduYWwgYWxyZWFkeSBhYm9ydGVkXCIpO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBjYW5jZWxsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGVycm9yOiBcIlJlcXVlc3QgY2FuY2VsbGVkXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZShcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImFudGhyb3BpY19jb21wbGV0ZVwiLFxuICAgICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgICAgYm9keTogcmVxdWVzdEJvZHksXG4gICAgICAgICAgfSxcbiAgICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHJlcXVlc3Qgd2FzIGNhbmNlbGxlZFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0FudGhyb3BpY1NlcnZpY2VdIFJlcXVlc3Qgd2FzIGNhbmNlbGxlZFwiKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2FuY2VsbGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBcIlJlcXVlc3QgY2FuY2VsbGVkXCIsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaHJvbWUucnVudGltZS5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBcIltBbnRocm9waWNTZXJ2aWNlXSBSdW50aW1lIGVycm9yOlwiLFxuICAgICAgICAgICAgICAgIGNocm9tZS5ydW50aW1lLmxhc3RFcnJvclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW0FudGhyb3BpY1NlcnZpY2VdIEFQSSBlcnJvcjpcIiwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogcmVzcG9uc2UuZXJyb3IsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0FudGhyb3BpY1NlcnZpY2VdIFJlY2VpdmVkIHN1Y2Nlc3NmdWwgcmVzcG9uc2VcIik7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgdGV4dDogcmVzcG9uc2UuY29udGVudFswXT8udGV4dCB8fCBcIlwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbQW50aHJvcGljU2VydmljZV0gVW5leHBlY3RlZCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBcIkFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWRcIixcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgbWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYVxuLy8gVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4vLyBGaWxlOiBzcmMvc2VydmljZXMvQ2xhdWRlQ2FjaGUudHNcbi8vIFNpbXBsZSBjYWNoaW5nIHV0aWxpdHkgZm9yIENsYXVkZSBBUEkgcmVzcG9uc2VzXG4vLyBUaGUgY2FjaGUgdGhhdCByZW1lbWJlcnMgc28geW91IGRvbid0IGhhdmUgdG8hXG5cbmltcG9ydCB7IGdldEhlYWRlcnMgfSBmcm9tIFwiLi4vdXRpbHMvZ2V0SGVhZGVyc1wiO1xuXG5pbnRlcmZhY2UgSUNhY2hlRW50cnk8VD4ge1xuICBkYXRhOiBUO1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIENsYXVkZUNhY2hlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgY2FjaGU6IE1hcDxzdHJpbmcsIElDYWNoZUVudHJ5PGFueT4+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBERUZBVUxUX1RJTUVPVVRfTVMgPSA1ICogNjAgKiAxMDAwOyAvLyA1IG1pbnV0ZXNcblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBlbnRyaWVzIGZyb20gdGhlIGNhY2hlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNsZWFyQ2FjaGUoKTogdm9pZCB7XG4gICAgQ2xhdWRlQ2FjaGUuY2FjaGUuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGRhdGEgd2l0aCBjYWNoaW5nIHN1cHBvcnRcbiAgICogQHBhcmFtIHVybCBUaGUgVVJMIHRvIGZldGNoIGZyb21cbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9uYWwgZmV0Y2ggY29uZmlndXJhdGlvblxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgZmV0Y2hlZCBkYXRhXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIGZldGNoV2l0aENhY2hlPFQ+KFxuICAgIHVybDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIGhlYWRlcnM/OiBIZWFkZXJzSW5pdDtcbiAgICAgIHRpbWVvdXRNcz86IG51bWJlcjtcbiAgICAgIGZvcmNlUmVmcmVzaD86IGJvb2xlYW47XG4gICAgfSA9IHt9XG4gICk6IFByb21pc2U8VD4ge1xuICAgIGNvbnN0IHsgdGltZW91dE1zID0gQ2xhdWRlQ2FjaGUuREVGQVVMVF9USU1FT1VUX01TLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSB9ID1cbiAgICAgIG9wdGlvbnM7XG5cbiAgICAvLyBBbHdheXMgdXNlIGZyZXNoIGRhdGEgaWYgcmVxdWVzdGVkXG4gICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgQ2xhdWRlQ2FjaGUuY2FjaGUuZGVsZXRlKHVybCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcbiAgICBjb25zdCBjYWNoZWRFbnRyeSA9IENsYXVkZUNhY2hlLmNhY2hlLmdldCh1cmwpO1xuICAgIGlmIChjYWNoZWRFbnRyeSkge1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmIChub3cgLSBjYWNoZWRFbnRyeS50aW1lc3RhbXAgPCB0aW1lb3V0TXMpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEVudHJ5LmRhdGEgYXMgVDtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBleHBpcmVkIGVudHJ5XG4gICAgICBDbGF1ZGVDYWNoZS5jYWNoZS5kZWxldGUodXJsKTtcbiAgICB9XG5cbiAgICAvLyBJZiBub3QgaW4gY2FjaGUgb3IgZXhwaXJlZCwgZmV0Y2ggbmV3IGRhdGFcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgaGVhZGVyczogb3B0aW9ucy5oZWFkZXJzIHx8IGdldEhlYWRlcnMoKSxcbiAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgLy8gQ2FjaGUgdGhlIG5ldyBkYXRhXG4gICAgQ2xhdWRlQ2FjaGUuY2FjaGUuc2V0KHVybCwge1xuICAgICAgZGF0YSxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICB9KTtcblxuICAgIHJldHVybiBkYXRhIGFzIFQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGNhY2hlZCBlbnRyeSBkaXJlY3RseVxuICAgKiBAcGFyYW0ga2V5IENhY2hlIGtleSB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyBDYWNoZWQgZGF0YSBpZiBmb3VuZCBhbmQgbm90IGV4cGlyZWRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZ2V0Q2FjaGVkPFQ+KGtleTogc3RyaW5nKTogVCB8IG51bGwge1xuICAgIGNvbnN0IGVudHJ5ID0gQ2xhdWRlQ2FjaGUuY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKCFlbnRyeSkgcmV0dXJuIG51bGw7XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChub3cgLSBlbnRyeS50aW1lc3RhbXAgPCBDbGF1ZGVDYWNoZS5ERUZBVUxUX1RJTUVPVVRfTVMpIHtcbiAgICAgIHJldHVybiBlbnRyeS5kYXRhIGFzIFQ7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGV4cGlyZWQgZW50cnlcbiAgICBDbGF1ZGVDYWNoZS5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgY2FjaGUgZW50cnkgZGlyZWN0bHlcbiAgICogQHBhcmFtIGtleSBDYWNoZSBrZXlcbiAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBjYWNoZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzZXRDYWNoZWQ8VD4oa2V5OiBzdHJpbmcsIGRhdGE6IFQpOiB2b2lkIHtcbiAgICBDbGF1ZGVDYWNoZS5jYWNoZS5zZXQoa2V5LCB7XG4gICAgICBkYXRhLFxuICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBzcGVjaWZpYyBlbnRyeSBmcm9tIHRoZSBjYWNoZVxuICAgKiBAcGFyYW0ga2V5IENhY2hlIGtleSB0byByZW1vdmVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVtb3ZlQ2FjaGVkKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgQ2xhdWRlQ2FjaGUuY2FjaGUuZGVsZXRlKGtleSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDI0IE1hcnRpbiBCZWNoYXJkIDxtYXJ0aW4uYmVjaGFyZEBEZXZDb25zdWx0LmNhPlxuICogVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBGaWxlOiAvVXNlcnMvbWFydGluYmVjaGFyZC9kZXYvY2xhdWRlZXh0L3NyYy9zZXJ2aWNlcy9Db21tYW5kRXhlY3V0b3IudHNcbiAqIFRoaXMgd2FzIGdlbmVyYXRlZCBieSBDbGF1ZGUgU29ubmV0IDMuNSwgd2l0aCB0aGUgYXNzaXN0YW5jZSBvZiBteSBodW1hbiBtZW50b3JcbiAqXG4gKiBIYW5kbGVzIGV4ZWN1dGlvbiBvZiBDbGF1ZGUgZXh0ZW5zaW9uIGNvbW1hbmRzXG4gKiBOb3RlOiBPbmUgY29tbWFuZCBoYW5kbGVyIHRvIHJ1bGUgdGhlbSBhbGwhXG4gKi9cblxuaW1wb3J0IHsgRG9jdW1lbnRSZXRyaWV2YWwgfSBmcm9tIFwiLi9Eb2N1bWVudFJldHJpZXZhbFwiO1xuaW1wb3J0IHsgUHJvamVjdFJldHJpZXZhbCB9IGZyb20gXCIuL1Byb2plY3RSZXRyaWV2YWxcIjtcbmltcG9ydCB7IFByb2plY3RTZWFyY2hTZXJ2aWNlIH0gZnJvbSBcIi4vUHJvamVjdFNlYXJjaFNlcnZpY2VcIjtcbmltcG9ydCB7IENvbnZlcnNhdGlvblJldHJpZXZhbCB9IGZyb20gXCIuL0NvbnZlcnNhdGlvblJldHJpZXZhbFwiO1xuaW1wb3J0IHsgUHJvbXB0QWxsIH0gZnJvbSBcIi4vUHJvbXB0QWxsXCI7XG5pbXBvcnQgeyBBbGlhc1NlcnZpY2UgfSBmcm9tIFwiLi9BbGlhc1NlcnZpY2VcIjtcbmltcG9ydCB0eXBlIHsgQ29tbWFuZE9wdGlvbnMsIFNjcmlwdCwgU2NyaXB0U3RhdGVtZW50IH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgdHlwZSB7IFN0YXR1c01hbmFnZXIgfSBmcm9tIFwiLi4vdWkvY29tcG9uZW50cy9TdGF0dXNNYW5hZ2VyXCI7XG5pbXBvcnQgeyBTZXR0aW5nc1NlcnZpY2UgfSBmcm9tIFwiLi9TZXR0aW5nc1NlcnZpY2VcIjtcblxudHlwZSBMb2dGdW5jdGlvbiA9IChcbiAgbWVzc2FnZTogc3RyaW5nLFxuICB0eXBlPzogXCJpbmZvXCIgfCBcImVycm9yXCIgfCBcInN1Y2Nlc3NcIlxuKSA9PiB2b2lkO1xuXG5leHBvcnQgY2xhc3MgQ29tbWFuZEV4ZWN1dG9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBzdGF0dXNNYW5hZ2VyOiBTdGF0dXNNYW5hZ2VyO1xuICBwcml2YXRlIHJlYWRvbmx5IGhhbmRsZUxvZzogTG9nRnVuY3Rpb247XG4gIHByaXZhdGUgcmVhZG9ubHkgb3V0cHV0RWxlbWVudDogSFRNTEVsZW1lbnQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgc3RhdHVzTWFuYWdlcjogU3RhdHVzTWFuYWdlcixcbiAgICBoYW5kbGVMb2c6IExvZ0Z1bmN0aW9uLFxuICAgIG91dHB1dEVsZW1lbnQ6IEhUTUxFbGVtZW50XG4gICkge1xuICAgIHRoaXMuc3RhdHVzTWFuYWdlciA9IHN0YXR1c01hbmFnZXI7XG4gICAgdGhpcy5oYW5kbGVMb2cgPSBoYW5kbGVMb2c7XG4gICAgdGhpcy5vdXRwdXRFbGVtZW50ID0gb3V0cHV0RWxlbWVudDtcblxuICAgIC8vIEhvb2sgdXAgdGhlIHNjcmlwdCdzIENhbmNlbCBidXR0b24gdG8gYWJvcnQgZnVuY3Rpb25hbGl0eVxuICAgIHRoaXMuc3RhdHVzTWFuYWdlci5vbkNhbmNlbCA9ICgpID0+IHtcbiAgICAgIFByb2plY3RTZWFyY2hTZXJ2aWNlLmFib3J0U2VhcmNoKCk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSAvZG9jcyBjb21tYW5kIGV4ZWN1dGlvblxuICAgKi9cbiAgcHVibGljIGFzeW5jIGhhbmRsZURvY3NDb21tYW5kKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm91dHB1dEVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgIHRoaXMuaGFuZGxlTG9nKFwiRmV0Y2hpbmcgZG9jdW1lbnRzLi4uXCIpO1xuICAgICAgY29uc3QgZG9jcyA9IGF3YWl0IERvY3VtZW50UmV0cmlldmFsLmZldGNoRG9jdW1lbnRzKCk7XG4gICAgICBhd2FpdCBEb2N1bWVudFJldHJpZXZhbC5kaXNwbGF5RG9jdW1lbnRzKGRvY3MsIHRoaXMub3V0cHV0RWxlbWVudCk7XG4gICAgICBhd2FpdCB0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFwicmVhZHlcIiwgXCJDb21wbGV0ZVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCI7XG4gICAgICB0aGlzLmhhbmRsZUxvZyhgRXJyb3IgZmV0Y2hpbmcgZG9jdW1lbnRzOiAke21lc3NhZ2V9YCwgXCJlcnJvclwiKTtcbiAgICAgIGF3YWl0IHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoXCJyZWFkeVwiLCBcIlwiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgL3Byb2plY3QgY29tbWFuZCBleGVjdXRpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBoYW5kbGVQcm9qZWN0Q29tbWFuZCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5vdXRwdXRFbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICB0aGlzLmhhbmRsZUxvZyhcIkZldGNoaW5nIHByb2plY3QgY29udmVyc2F0aW9ucy4uLlwiKTtcbiAgICAgIGF3YWl0IFByb2plY3RSZXRyaWV2YWwuZGlzcGxheUN1cnJlbnRQcm9qZWN0KHRoaXMub3V0cHV0RWxlbWVudCk7XG4gICAgICBhd2FpdCB0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFwicmVhZHlcIiwgXCJDb21wbGV0ZVwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCI7XG4gICAgICB0aGlzLmhhbmRsZUxvZyhcbiAgICAgICAgYEVycm9yIGZldGNoaW5nIHByb2plY3QgY29udmVyc2F0aW9uczogJHttZXNzYWdlfWAsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgICAgKTtcbiAgICAgIGF3YWl0IHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoXCJlcnJvclwiLCBtZXNzYWdlKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGF0dXNNYW5hZ2VyLnNldFN0YXR1cyhcInJlYWR5XCIpLCAyMDAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgL3NlYXJjaF9wcm9qZWN0IGNvbW1hbmQgZXhlY3V0aW9uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgaGFuZGxlU2VhcmNoUHJvamVjdENvbW1hbmQoXG4gICAgc2NyaXB0OiBTY3JpcHRTdGF0ZW1lbnRcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMub3V0cHV0RWxlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgICB0aGlzLmhhbmRsZUxvZyhcbiAgICAgICAgc2NyaXB0LnNlYXJjaFRleHRcbiAgICAgICAgICA/IGBTZWFyY2hpbmcgcHJvamVjdHMgZm9yOiAke3NjcmlwdC5zZWFyY2hUZXh0fWBcbiAgICAgICAgICA6IFwiUmV0cmlldmluZyBwcm9qZWN0IGNvbnZlcnNhdGlvbnMuLi5cIlxuICAgICAgKTtcblxuICAgICAgYXdhaXQgUHJvamVjdFNlYXJjaFNlcnZpY2Uuc2VhcmNoQW5kRGlzcGxheVJlc3VsdHMoXG4gICAgICAgIHNjcmlwdC5zZWFyY2hUZXh0LFxuICAgICAgICB0aGlzLm91dHB1dEVsZW1lbnRcbiAgICAgICk7XG5cbiAgICAgIGF3YWl0IHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoXG4gICAgICAgIFwicmVhZHlcIixcbiAgICAgICAgc2NyaXB0LnNlYXJjaFRleHRcbiAgICAgICAgICA/IFwiU2VhcmNoIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlcIlxuICAgICAgICAgIDogXCJQcm9qZWN0cyByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5XCJcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuaGFuZGxlTG9nKFxuICAgICAgICBzY3JpcHQuc2VhcmNoVGV4dFxuICAgICAgICAgID8gXCJTZWFyY2ggY29tcGxldGVkIHN1Y2Nlc3NmdWxseVwiXG4gICAgICAgICAgOiBcIlByb2plY3RzIHJldHJpZXZlZCBzdWNjZXNzZnVsbHlcIixcbiAgICAgICAgXCJzdWNjZXNzXCJcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiO1xuICAgICAgdGhpcy5oYW5kbGVMb2coYEVycm9yIGR1cmluZyBwcm9qZWN0IHNlYXJjaDogJHttZXNzYWdlfWAsIFwiZXJyb3JcIik7XG4gICAgICBhd2FpdCB0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFwiZXJyb3JcIiwgbWVzc2FnZSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoXCJyZWFkeVwiKSwgMjAwMCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGhhbmRsZVNldHRpbmdzQ29tbWFuZChzY3JpcHQ6IFNjcmlwdFN0YXRlbWVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBGb3JtYXQ6IC9zZXR0aW5ncyBhcGlfa2V5IFlPVVJfS0VZXG4gICAgICBjb25zdCBwYXJ0cyA9IHNjcmlwdC5wcm9tcHQgPyBzY3JpcHQucHJvbXB0LnRyaW0oKS5zcGxpdCgvXFxzKy8pIDogW107XG5cbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIk1pc3Npbmcgc2V0dGluZyBuYW1lLiBGb3JtYXQ6IC9zZXR0aW5ncyBbc2V0dGluZ19uYW1lXSBbdmFsdWVdXCJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2V0dGluZ05hbWUgPSBwYXJ0c1swXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFydHMuc2xpY2UoMSkuam9pbihcIiBcIik7XG5cbiAgICAgIHN3aXRjaCAoc2V0dGluZ05hbWUpIHtcbiAgICAgICAgY2FzZSBcImFwaV9rZXlcIjpcbiAgICAgICAgICBjb25zdCBlcnJvciA9IFNldHRpbmdzU2VydmljZS52YWxpZGF0ZUFwaUtleSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQVBJIGtleTogJHtlcnJvcn1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgU2V0dGluZ3NTZXJ2aWNlLnNldFNldHRpbmcoXCJhbnRocm9waWNBcGlLZXlcIiwgdmFsdWUpO1xuICAgICAgICAgIHRoaXMuaGFuZGxlTG9nKFwiQVBJIGtleSB1cGRhdGVkIHN1Y2Nlc3NmdWxseVwiLCBcInN1Y2Nlc3NcIik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2V0dGluZzogJHtzZXR0aW5nTmFtZX1gKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgdGhpcy5zdGF0dXNNYW5hZ2VyLnNldFN0YXR1cyhcInJlYWR5XCIsIFwiU2V0dGluZ3MgdXBkYXRlZFwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCI7XG4gICAgICB0aGlzLmhhbmRsZUxvZyhgU2V0dGluZ3MgZXJyb3I6ICR7bWVzc2FnZX1gLCBcImVycm9yXCIpO1xuICAgICAgYXdhaXQgdGhpcy5zdGF0dXNNYW5hZ2VyLnNldFN0YXR1cyhcImVycm9yXCIsIG1lc3NhZ2UpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFwicmVhZHlcIiksIDIwMDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSAvcXVlcnlfcHJvamVjdCBjb21tYW5kIGV4ZWN1dGlvblxuICAgKi9cbiAgcHVibGljIGFzeW5jIGhhbmRsZVF1ZXJ5UHJvamVjdENvbW1hbmQoXG4gICAgc2NyaXB0OiBTY3JpcHRTdGF0ZW1lbnRcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMub3V0cHV0RWxlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgICBjb25zdCBwcm9tcHQgPSBzY3JpcHQucHJvbXB0O1xuICAgICAgaWYgKCFwcm9tcHQgfHwgcHJvbXB0LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJvbXB0IHByb3ZpZGVkIGZvciBxdWVyeV9wcm9qZWN0IGNvbW1hbmRcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGFuZGxlTG9nKFwiUXVlcnlpbmcgYWxsIGNvbnZlcnNhdGlvbnMuLi5cIik7XG5cbiAgICAgIGF3YWl0IFByb21wdEFsbC5xdWVyeUFuZERpc3BsYXlSZXN1bHRzKFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIHRoaXMub3V0cHV0RWxlbWVudCxcbiAgICAgICAgYXN5bmMgKHN0YXR1cykgPT4ge1xuICAgICAgICAgIGF3YWl0IHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoXCJ3b3JraW5nXCIsIHN0YXR1cyk7XG4gICAgICAgICAgdGhpcy5oYW5kbGVMb2coc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgYXdhaXQgdGhpcy5zdGF0dXNNYW5hZ2VyLnNldFN0YXR1cyhcbiAgICAgICAgXCJyZWFkeVwiLFxuICAgICAgICBcIlF1ZXJ5IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlcIlxuICAgICAgKTtcbiAgICAgIHRoaXMuaGFuZGxlTG9nKFwiUXVlcnkgY29tcGxldGVkIHN1Y2Nlc3NmdWxseVwiLCBcInN1Y2Nlc3NcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiO1xuICAgICAgdGhpcy5oYW5kbGVMb2coYEVycm9yIGR1cmluZyBwcm9qZWN0IHF1ZXJ5OiAke21lc3NhZ2V9YCwgXCJlcnJvclwiKTtcbiAgICAgIGF3YWl0IHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoXCJlcnJvclwiLCBtZXNzYWdlKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGF0dXNNYW5hZ2VyLnNldFN0YXR1cyhcInJlYWR5XCIpLCAyMDAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBjb252ZXJzYXRpb24tcmVsYXRlZCBjb21tYW5kcyBleGVjdXRpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBoYW5kbGVDb252ZXJzYXRpb25Db21tYW5kKFxuICAgIG9wdGlvbnM6IENvbW1hbmRPcHRpb25zXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLm91dHB1dEVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgIHRoaXMuaGFuZGxlTG9nKFwiUmV0cmlldmluZyBjb252ZXJzYXRpb24uLi5cIik7XG5cbiAgICAgIGF3YWl0IENvbnZlcnNhdGlvblJldHJpZXZhbC5kaXNwbGF5Q3VycmVudENvbnZlcnNhdGlvbihcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgdGhpcy5vdXRwdXRFbGVtZW50XG4gICAgICApO1xuXG4gICAgICBhd2FpdCB0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFxuICAgICAgICBcInJlYWR5XCIsXG4gICAgICAgIFwiQ29udmVyc2F0aW9uIHJldHJpZXZlZCBzdWNjZXNzZnVsbHlcIlxuICAgICAgKTtcbiAgICAgIHRoaXMuaGFuZGxlTG9nKFwiQ29udmVyc2F0aW9uIHJldHJpZXZlZCBzdWNjZXNzZnVsbHlcIiwgXCJzdWNjZXNzXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIjtcbiAgICAgIHRoaXMuaGFuZGxlTG9nKGBFcnJvciByZXRyaWV2aW5nIGNvbnZlcnNhdGlvbjogJHttZXNzYWdlfWAsIFwiZXJyb3JcIik7XG4gICAgICBhd2FpdCB0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFwiZXJyb3JcIiwgbWVzc2FnZSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoXCJyZWFkeVwiKSwgMjAwMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYWxpYXMgY29tbWFuZCBleGVjdXRpb25cbiAgICovXG4gIHB1YmxpYyBhc3luYyBoYW5kbGVBbGlhc0NvbW1hbmQoc2NyaXB0OiBTY3JpcHRTdGF0ZW1lbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXNjcmlwdC5hbGlhc0NvbW1hbmQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFsaWFzIGNvbW1hbmQgc3BlY2lmaWVkXCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKHNjcmlwdC5hbGlhc0NvbW1hbmQudHlwZSkge1xuICAgICAgICBjYXNlIFwiYWxpYXNcIjpcbiAgICAgICAgICBpZiAoIXNjcmlwdC5hbGlhc0NvbW1hbmQubmFtZSB8fCAhc2NyaXB0LmFsaWFzQ29tbWFuZC50ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFsaWFzIGNvbW1hbmQ6IG1pc3NpbmcgbmFtZSBvciB0ZXh0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBBbGlhc1NlcnZpY2Uuc2V0QWxpYXMoXG4gICAgICAgICAgICBzY3JpcHQuYWxpYXNDb21tYW5kLm5hbWUsXG4gICAgICAgICAgICBzY3JpcHQuYWxpYXNDb21tYW5kLnRleHRcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuaGFuZGxlTG9nKFxuICAgICAgICAgICAgYEFsaWFzIEAke3NjcmlwdC5hbGlhc0NvbW1hbmQubmFtZX0gY3JlYXRlZGAsXG4gICAgICAgICAgICBcInN1Y2Nlc3NcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcImRlbGV0ZV9hbGlhc1wiOlxuICAgICAgICAgIGlmICghc2NyaXB0LmFsaWFzQ29tbWFuZC5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRlbGV0ZSBhbGlhcyBjb21tYW5kOiBtaXNzaW5nIG5hbWVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBbGlhc1NlcnZpY2UuZGVsZXRlQWxpYXMoc2NyaXB0LmFsaWFzQ29tbWFuZC5uYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVMb2coXG4gICAgICAgICAgICAgIGBBbGlhcyBAJHtzY3JpcHQuYWxpYXNDb21tYW5kLm5hbWV9IGRlbGV0ZWRgLFxuICAgICAgICAgICAgICBcInN1Y2Nlc3NcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVMb2coXG4gICAgICAgICAgICAgIGBBbGlhcyBAJHtzY3JpcHQuYWxpYXNDb21tYW5kLm5hbWV9IG5vdCBmb3VuZGAsXG4gICAgICAgICAgICAgIFwiZXJyb3JcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcImxpc3RfYWxpYXNcIjpcbiAgICAgICAgICBjb25zdCBhbGlhc2VzID0gQWxpYXNTZXJ2aWNlLmdldEFsaWFzTGlzdCgpO1xuICAgICAgICAgIGlmIChhbGlhc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVMb2coXCJObyBhbGlhc2VzIGRlZmluZWRcIiwgXCJpbmZvXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICAgICAgICAgIGFsaWFzZXMuZm9yRWFjaCgoYWxpYXMpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgZGl2LnRleHRDb250ZW50ID0gYWxpYXM7XG4gICAgICAgICAgICAgIHRoaXMub3V0cHV0RWxlbWVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhbGlhcyBjb21tYW5kIHR5cGVcIik7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoXCJyZWFkeVwiLCBcIkNvbXBsZXRlXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIjtcbiAgICAgIHRoaXMuaGFuZGxlTG9nKGBBbGlhcyBjb21tYW5kIGZhaWxlZDogJHttZXNzYWdlfWAsIFwiZXJyb3JcIik7XG4gICAgICBhd2FpdCB0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFwiZXJyb3JcIiwgbWVzc2FnZSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoXCJyZWFkeVwiKSwgMjAwMCk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogL3NyYy9zZXJ2aWNlcy9Db252ZXJzYXRpb25SZXRyaWV2YWwudHNcbiAqIFRoaXMgd2FzIGdlbmVyYXRlZCBieSBDbGF1ZGUgU29ubmV0IDMuNSwgd2l0aCB0aGUgYXNzaXN0YW5jZSBvZiBteSBodW1hbiBtZW50b3JcbiAqXG4gKiBTZXJ2aWNlIGZvciBtYW5hZ2luZyBDbGF1ZGUgY29udmVyc2F0aW9ucyBhbmQgYXJ0aWZhY3RzXG4gKiBOb3RlOiBNYWtpbmcgY29udmVyc2F0aW9uIGhpc3RvcnkgZWFzaWVyIHRvIGJyb3dzZSBhbmQgYW5hbHl6ZSFcbiAqL1xuXG5pbXBvcnQgdHlwZSB7XG4gIENvbnZlcnNhdGlvbixcbiAgQ2hhdE1lc3NhZ2UsXG4gIENoYXRNZXNzYWdlSW5wdXQsXG4gIENvbW1hbmRPcHRpb25zLFxuICBDb252ZXJzYXRpb25BcnRpZmFjdCxcbiAgRG9jdW1lbnRJbmZvLFxufSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IENsYXVkZUNhY2hlIH0gZnJvbSBcIi4vQ2xhdWRlQ2FjaGVcIjtcbmltcG9ydCB7IERvd25sb2FkVGFibGUgfSBmcm9tIFwiLi4vdWkvY29tcG9uZW50cy9Eb3dubG9hZFRhYmxlXCI7XG5pbXBvcnQgeyBnZXRPcmdhbml6YXRpb25JZCB9IGZyb20gXCIuLi91dGlscy9nZXRDbGF1ZGVJZHNcIjtcbmltcG9ydCB7IGV4dHJhY3RSZWxQYXRoIH0gZnJvbSBcIkAvdXRpbHMvUGF0aEV4dHJhY3RvclwiO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXh0cmFjdGVkIGFydGlmYWN0IGZvciBtYXJrZG93biByZW5kZXJpbmdcbiAqL1xuaW50ZXJmYWNlIE1hcmtkb3duQXJ0aWZhY3Qge1xuICB0aXRsZTogc3RyaW5nO1xuICBsYW5ndWFnZT86IHN0cmluZztcbiAgY29udGVudD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBUeXBlIGRlZmluaXRpb24gZm9yIG1lc3NhZ2UgZmlsdGVyIGNhbGxiYWNrXG4gKi9cbmV4cG9ydCB0eXBlIE1lc3NhZ2VGaWx0ZXJDYWxsYmFjayA9IChtZXNzYWdlOiBDaGF0TWVzc2FnZSkgPT4gYm9vbGVhbjtcblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBtYW5hZ2luZyBDbGF1ZGUgY29udmVyc2F0aW9ucyBhbmQgYXJ0aWZhY3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBDb252ZXJzYXRpb25SZXRyaWV2YWwge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBBUElfVVJMID0gXCJodHRwczovL2FwaS5jbGF1ZGUuYWkvYXBpL29yZ2FuaXphdGlvbnNcIjtcblxuICAvKipcbiAgICogR2V0cyB0aGUgY29udmVyc2F0aW9uIElEIGZyb20gdGhlIGN1cnJlbnQgVVJMXG4gICAqIEByZXR1cm5zIENvbnZlcnNhdGlvbiBJRCBpZiBmb3VuZFxuICAgKiBAdGhyb3dzIEVycm9yIGlmIG5vdCBvbiBhIGNvbnZlcnNhdGlvbiBwYWdlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldENvbnZlcnNhdGlvbklkRnJvbVVybCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IG1hdGNoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLm1hdGNoKC9cXC9jaGF0XFwvKFteXFwvXSspLyk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIlBsZWFzZSBuYXZpZ2F0ZSB0byBhIENsYXVkZSBjaGF0IHBhZ2UgYmVmb3JlIHVzaW5nIGNvbnZlcnNhdGlvbiBjb21tYW5kc1wiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hbMV07XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgY29udmVyc2F0aW9uIGJ5IElEIHdpdGggY2FjaGluZ1xuICAgKiBAcGFyYW0gb3JnSWQgLSBPcmdhbml6YXRpb24gSURcbiAgICogQHBhcmFtIGNvbnZlcnNhdGlvbklkIC0gQ29udmVyc2F0aW9uIElEIHRvIHJldHJpZXZlXG4gICAqIEBwYXJhbSBmb3JjZVJlZnJlc2ggLSBGb3JjZSByZWZyZXNoIGZyb20gQVBJIGluc3RlYWQgb2YgY2FjaGVcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gY29udmVyc2F0aW9uIGRhdGFcbiAgICogQHRocm93cyBFcnJvciBpZiByZXRyaWV2YWwgZmFpbHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgZ2V0Q29udmVyc2F0aW9uKFxuICAgIG9yZ0lkOiBzdHJpbmcsXG4gICAgY29udmVyc2F0aW9uSWQ6IHN0cmluZyxcbiAgICBmb3JjZVJlZnJlc2g6IGJvb2xlYW4gPSBmYWxzZVxuICApOiBQcm9taXNlPENvbnZlcnNhdGlvbj4ge1xuICAgIGNvbnN0IHVybCA9IGAke3RoaXMuQVBJX1VSTH0vJHtvcmdJZH0vY2hhdF9jb252ZXJzYXRpb25zLyR7Y29udmVyc2F0aW9uSWR9P3RyZWU9VHJ1ZSZyZW5kZXJpbmdfbW9kZT1tZXNzYWdlcyZyZW5kZXJfYWxsX3Rvb2xzPXRydWVgO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBDbGF1ZGVDYWNoZS5mZXRjaFdpdGhDYWNoZTxDb252ZXJzYXRpb24+KHVybCwge1xuICAgICAgICBmb3JjZVJlZnJlc2gsXG4gICAgICAgIHRpbWVvdXRNczogNjAwMDAsIC8vIENhY2hlIGZvciAxIG1pbnV0ZSBzaW5jZSBjb252ZXJzYXRpb25zIGNhbiB1cGRhdGUgZnJlcXVlbnRseVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEVycm9yIHJldHJpZXZpbmcgY29udmVyc2F0aW9uOiAke1xuICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYXBwcm9wcmlhdGUgZmlsZSBleHRlbnNpb24gYmFzZWQgb24gbGFuZ3VhZ2VcbiAgICogQHBhcmFtIGxhbmd1YWdlIC0gUHJvZ3JhbW1pbmcgbGFuZ3VhZ2Ugb3IgZmlsZSB0eXBlXG4gICAqIEByZXR1cm5zIEZpbGUgZXh0ZW5zaW9uIGluY2x1ZGluZyBkb3RcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldEZpbGVFeHRlbnNpb24obGFuZ3VhZ2U/OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICghbGFuZ3VhZ2UpIHJldHVybiBcIi50eHRcIjtcblxuICAgIGNvbnN0IGV4dGVuc2lvbk1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgIHR5cGVzY3JpcHQ6IFwiLnRzXCIsXG4gICAgICBqYXZhc2NyaXB0OiBcIi5qc1wiLFxuICAgICAgcHl0aG9uOiBcIi5weVwiLFxuICAgICAgamF2YTogXCIuamF2YVwiLFxuICAgICAgXCJ0ZXh0L21hcmtkb3duXCI6IFwiLm1kXCIsXG4gICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjogXCIuanNvblwiLFxuICAgICAgaHRtbDogXCIuaHRtbFwiLFxuICAgICAgY3NzOiBcIi5jc3NcIixcbiAgICAgIFwidGV4dC9odG1sXCI6IFwiLmh0bWxcIixcbiAgICAgIFwiYXBwbGljYXRpb24vdm5kLmFudC5jb2RlXCI6IFwiLnR4dFwiLFxuICAgICAgXCJhcHBsaWNhdGlvbi92bmQuYW50LnJlYWN0XCI6IFwiLnRzeFwiLFxuICAgICAgXCJhcHBsaWNhdGlvbi92bmQuYW50Lm1lcm1haWRcIjogXCIubW1kXCIsXG4gICAgICBcImltYWdlL3N2Zyt4bWxcIjogXCIuc3ZnXCIsXG4gICAgfTtcblxuICAgIHJldHVybiBleHRlbnNpb25NYXBbbGFuZ3VhZ2UudG9Mb3dlckNhc2UoKV0gfHwgXCIudHh0XCI7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdHMgYXJ0aWZhY3RzIGZyb20gYSBjb252ZXJzYXRpb25cbiAgICogQHBhcmFtIGNvbnZlcnNhdGlvbiAtIENvbnZlcnNhdGlvbiB0byBleHRyYWN0IGFydGlmYWN0cyBmcm9tXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIGFydGlmYWN0c1xuICAgKi9cbiAgLy8gSW4gQ29udmVyc2F0aW9uUmV0cmlldmFsLnRzLCB1cGRhdGUgdGhlIGV4dHJhY3RBcnRpZmFjdHMgbWV0aG9kOlxuXG4gIHByaXZhdGUgc3RhdGljIGV4dHJhY3RBcnRpZmFjdHMoXG4gICAgY29udmVyc2F0aW9uOiBDb252ZXJzYXRpb25cbiAgKTogQ29udmVyc2F0aW9uQXJ0aWZhY3RbXSB7XG4gICAgY29uc3QgYXJ0aWZhY3RzOiBDb252ZXJzYXRpb25BcnRpZmFjdFtdID0gW107XG5cbiAgICBjb252ZXJzYXRpb24uY2hhdF9tZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XG4gICAgICBtZXNzYWdlLmNvbnRlbnQuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBpZiAoaXRlbS50eXBlID09PSBcInRvb2xfdXNlXCIgJiYgaXRlbS5pbnB1dCkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBpdGVtLmlucHV0LmNvbnRlbnQ7XG5cbiAgICAgICAgICAvLyBFeHRyYWN0IHBhdGggZnJvbSBjb250ZW50XG4gICAgICAgICAgbGV0IGZpbGVQYXRoID0gY29udGVudCA/IGV4dHJhY3RSZWxQYXRoKGNvbnRlbnQpIDogXCJcIjtcblxuICAgICAgICAgIC8vIElmIG5vIHBhdGggZm91bmQsIHVzZSB0aXRsZSBhcyBmaWxlbmFtZSB3aXRob3V0IGZvcmNpbmcgZXh0ZW5zaW9uXG4gICAgICAgICAgaWYgKCFmaWxlUGF0aCAmJiBpdGVtLmlucHV0LnRpdGxlKSB7XG4gICAgICAgICAgICBmaWxlUGF0aCA9IGl0ZW0uaW5wdXQudGl0bGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHJvY2VzcyBkaXJlY3RvcnkgbmFtZXMgdG8ga2Fib2IgY2FzZSBidXQga2VlcCBmaWxlbmFtZSBhcyBpc1xuICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFBhdGggPSAhZmlsZVBhdGhcbiAgICAgICAgICAgID8gXCJcIlxuICAgICAgICAgICAgOiBmaWxlUGF0aFxuICAgICAgICAgICAgICAgIC5zcGxpdChcIi9cIilcbiAgICAgICAgICAgICAgICAubWFwKChwYXJ0LCBpbmRleCwgYXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAvLyBLZWVwIGZpbGVuYW1lIChsYXN0IHBhcnQpIGFzIGlzXG4gICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGFyci5sZW5ndGggLSAxKSByZXR1cm4gcGFydDtcbiAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBkaXJlY3RvcnkgbmFtZXMgdG8ga2Fib2IgY2FzZVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnQucmVwbGFjZSgvXFxzKy9nLCBcIi1cIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKFwiL1wiKTtcblxuICAgICAgICAgIGFydGlmYWN0cy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBpdGVtLmlucHV0LmlkLFxuICAgICAgICAgICAgdGl0bGU6XG4gICAgICAgICAgICAgIGZpbGVQYXRoPy5zcGxpdChcIi9cIik/LnBvcCgpIHx8IGl0ZW0uaW5wdXQudGl0bGUgfHwgXCJVbnRpdGxlZFwiLFxuICAgICAgICAgICAgbGFuZ3VhZ2U6IGl0ZW0uaW5wdXQubGFuZ3VhZ2UsXG4gICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgZGVsdGE6XG4gICAgICAgICAgICAgIGl0ZW0uaW5wdXQubmV3X3N0ciB8fCBpdGVtLmlucHV0Lm9sZF9zdHJcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgb2xkOiBpdGVtLmlucHV0Lm9sZF9zdHIgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgbmV3OiBpdGVtLmlucHV0Lm5ld19zdHIgfHwgXCJcIixcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZpbGVQYXRoOiBwcm9jZXNzZWRQYXRoLFxuICAgICAgICAgICAgLy8gQWRkIHRoZSBkYXRlcyBmcm9tIHRoZSBjb250YWluaW5nIG1lc3NhZ2VcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG1lc3NhZ2UuY3JlYXRlZF9hdCxcbiAgICAgICAgICAgIHVwZGF0ZWRfYXQ6IG1lc3NhZ2UudXBkYXRlZF9hdCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXJ0aWZhY3RzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGZpbGUgcGF0aCBmcm9tIGFydGlmYWN0IGNvbnRlbnQgaWYgcHJlc2VudFxuICAgKiBAcGFyYW0gY29udGVudCAtIEFydGlmYWN0IGNvbnRlbnQgdG8gc2VhcmNoXG4gICAqIEByZXR1cm5zIEZpbGUgcGF0aCBpZiBmb3VuZCwgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZXh0cmFjdEZpbGVQYXRoKGNvbnRlbnQ6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgZmlsZVBhdGhNYXRjaCA9IGV4dHJhY3RSZWxQYXRoKGNvbnRlbnQpO1xuICAgIHJldHVybiBmaWxlUGF0aE1hdGNoO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFydGlmYWN0cyB0byBEb2N1bWVudEluZm8gZm9ybWF0IGZvciBEb3dubG9hZFRhYmxlXG4gICAqIEBwYXJhbSBhcnRpZmFjdHMgLSBBcnJheSBvZiBjb252ZXJzYXRpb24gYXJ0aWZhY3RzXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIERvY3VtZW50SW5mbyBvYmplY3RzXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBjb252ZXJ0QXJ0aWZhY3RzVG9Eb2N1bWVudEluZm8oXG4gICAgYXJ0aWZhY3RzOiBDb252ZXJzYXRpb25BcnRpZmFjdFtdXG4gICk6IERvY3VtZW50SW5mb1tdIHtcbiAgICBjb25zdCB1bmlxdWUgPSBuZXcgTWFwPHN0cmluZywgQ29udmVyc2F0aW9uQXJ0aWZhY3Q+KCk7XG5cbiAgICAvLyBLZWVwIG9ubHkgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIGVhY2ggYXJ0aWZhY3RcbiAgICBhcnRpZmFjdHMuZm9yRWFjaCgoYXJ0aWZhY3QpID0+IHtcbiAgICAgIGlmIChhcnRpZmFjdC5jb250ZW50KSB7XG4gICAgICAgIHVuaXF1ZS5zZXQoYXJ0aWZhY3QuaWQsIGFydGlmYWN0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBBcnJheS5mcm9tKHVuaXF1ZS52YWx1ZXMoKSkubWFwKChhcnRpZmFjdCkgPT4gKHtcbiAgICAgIGZpbGVOYW1lOiBhcnRpZmFjdC50aXRsZSxcbiAgICAgIGZpbGVQYXRoOiBhcnRpZmFjdC5maWxlUGF0aCB8fCBhcnRpZmFjdC50aXRsZSxcbiAgICAgIGNvbnRlbnQ6IGFydGlmYWN0LmNvbnRlbnQgfHwgXCJcIixcbiAgICAgIGlzU2VsZWN0ZWQ6IHRydWUsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBsYW5ndWFnZTogYXJ0aWZhY3QubGFuZ3VhZ2UsXG4gICAgICAgIGlkOiBhcnRpZmFjdC5pZCxcbiAgICAgICAgLy8gUGFzcyB0aHJvdWdoIHRoZSBkYXRlcyBmcm9tIHRoZSBhcnRpZmFjdFxuICAgICAgICBjcmVhdGVkX2F0OiBhcnRpZmFjdC5jcmVhdGVkX2F0LFxuICAgICAgICB1cGRhdGVkX2F0OiBhcnRpZmFjdC51cGRhdGVkX2F0LFxuICAgICAgfSxcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGxheXMgY29udmVyc2F0aW9uIGVsZW1lbnRzIGluIHRoZSBvdXRwdXQgZWxlbWVudFxuICAgKiBAcGFyYW0gZG9jcyAtIERvY3VtZW50cyB0byBkaXNwbGF5XG4gICAqIEBwYXJhbSBvdXRwdXRFbGVtZW50IC0gRWxlbWVudCB0byBkaXNwbGF5IGRvY3VtZW50cyBpblxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBkaXNwbGF5Q29udmVyc2F0aW9uKFxuICAgIGRvY3M6IERvY3VtZW50SW5mb1tdLFxuICAgIG91dHB1dEVsZW1lbnQ6IEhUTUxFbGVtZW50XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIG91dHB1dEVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBjb25zdCB0YWJsZSA9IG5ldyBEb3dubG9hZFRhYmxlKG91dHB1dEVsZW1lbnQsIGRvY3MpO1xuICAgIHRhYmxlLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbmQgZGlzcGxheXMgdGhlIGN1cnJlbnQgY29udmVyc2F0aW9uIGJhc2VkIG9uIGNvbW1hbmQgb3B0aW9uc1xuICAgKiBAcGFyYW0gb3B0aW9ucyAtIENvbW1hbmQgb3B0aW9ucyBmb3IgdGhlIGV4cG9ydFxuICAgKiBAcGFyYW0gb3V0cHV0RWxlbWVudCAtIEVsZW1lbnQgdG8gZGlzcGxheSB0aGUgY29udmVyc2F0aW9uIGluXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGRpc3BsYXkgaXMgY29tcGxldGVcbiAgICovXG5cbiAgcHVibGljIHN0YXRpYyBhc3luYyBkaXNwbGF5Q3VycmVudENvbnZlcnNhdGlvbihcbiAgICBvcHRpb25zOiBDb21tYW5kT3B0aW9ucyxcbiAgICBvdXRwdXRFbGVtZW50OiBIVE1MRWxlbWVudFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3JnSWQgPSBnZXRPcmdhbml6YXRpb25JZCgpO1xuICAgICAgY29uc3QgY29udmVyc2F0aW9uSWQgPSB0aGlzLmdldENvbnZlcnNhdGlvbklkRnJvbVVybCgpO1xuICAgICAgY29uc3QgY29udmVyc2F0aW9uID0gYXdhaXQgdGhpcy5nZXRDb252ZXJzYXRpb24oXG4gICAgICAgIG9yZ0lkLFxuICAgICAgICBjb252ZXJzYXRpb25JZCxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcblxuICAgICAgLy8gRXh0cmFjdCBhbmQgcHJvY2VzcyBhcnRpZmFjdHMgaWYgcmVxdWVzdGVkXG4gICAgICBpZiAob3B0aW9ucz8uaW5jbHVkZUFydGlmYWN0cykge1xuICAgICAgICBjb25zdCBhcnRpZmFjdHMgPSB0aGlzLmV4dHJhY3RBcnRpZmFjdHMoY29udmVyc2F0aW9uKTtcbiAgICAgICAgY29uc3QgZG9jcyA9IHRoaXMuY29udmVydEFydGlmYWN0c1RvRG9jdW1lbnRJbmZvKGFydGlmYWN0cyk7XG5cbiAgICAgICAgaWYgKGRvY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYXJ0aWZhY3RzIGZvdW5kIGluIGNvbnZlcnNhdGlvblwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHRoaXMuZGlzcGxheUNvbnZlcnNhdGlvbihkb2NzLCBvdXRwdXRFbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERpc3BsYXkgY29udmVyc2F0aW9uIHdpdGggbWV0YWRhdGEgZm9yIHByZXZpZXdcbiAgICAgICAgY29uc3QgZG9jczogRG9jdW1lbnRJbmZvW10gPSBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmlsZU5hbWU6IGNvbnZlcnNhdGlvbi5uYW1lLFxuICAgICAgICAgICAgZmlsZVBhdGg6IGBjb252ZXJzYXRpb25zLyR7Y29udmVyc2F0aW9uLm5hbWV9Lm1kYCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsIC8vIEVtcHR5IGluaXRpYWwgY29udGVudCwgd2lsbCBiZSBsb2FkZWQgYnkgY2FsbGJhY2tcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICBjb252ZXJzYXRpb25JZDogY29udmVyc2F0aW9uLnV1aWQsXG4gICAgICAgICAgICAgIHVybDogYGh0dHBzOi8vY2xhdWRlLmFpL2NoYXQvJHtjb252ZXJzYXRpb24udXVpZH1gLFxuICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBjb252ZXJzYXRpb24uY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgdXBkYXRlZF9hdDogY29udmVyc2F0aW9uLnVwZGF0ZWRfYXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudENhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnYgPSBhd2FpdCB0aGlzLmdldENvbnZlcnNhdGlvbihcbiAgICAgICAgICAgICAgICBvcmdJZCxcbiAgICAgICAgICAgICAgICBjb252ZXJzYXRpb25JZCxcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnNhdGlvblRvTWFya2Rvd24oY29udik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIF07XG5cbiAgICAgICAgYXdhaXQgdGhpcy5kaXNwbGF5Q29udmVyc2F0aW9uKGRvY3MsIG91dHB1dEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZGlzcGxheSBjb252ZXJzYXRpb246ICR7XG4gICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIlxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgb3JnYW5pemF0aW9uIElEIGZyb20gY29va2llc1xuICAgKiBAdGhyb3dzIEVycm9yIGlmIG9yZ2FuaXphdGlvbiBJRCBpcyBub3QgZm91bmQgb3IgaW52YWxpZFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0T3JnYW5pemF0aW9uSWQoKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb29raWUgPSBkb2N1bWVudC5jb29raWVcbiAgICAgIC5zcGxpdChcIjsgXCIpXG4gICAgICAuZmluZCgocm93KSA9PiByb3cuc3RhcnRzV2l0aChcImxhc3RBY3RpdmVPcmc9XCIpKTtcblxuICAgIGlmICghY29va2llKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcmdhbml6YXRpb24gSUQgbm90IGZvdW5kIGluIGNvb2tpZXNcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZS5zcGxpdChcIj1cIilbMV0pO1xuICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL15cInxcIiQvZywgXCJcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3JnYW5pemF0aW9uIElEIGZvcm1hdCBpbiBjb29raWVcIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgY29udmVyc2F0aW9uIHRvIG1hcmtkb3duIGZvcm1hdFxuICAgKiBAcGFyYW0gY29udmVyc2F0aW9uIC0gQ29udmVyc2F0aW9uIHRvIGNvbnZlcnRcbiAgICogQHBhcmFtIGZpbHRlckNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gZmlsdGVyIG1lc3NhZ2VzXG4gICAqIEByZXR1cm5zIE1hcmtkb3duIHN0cmluZyBvZiB0aGUgY29udmVyc2F0aW9uXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGNvbnZlcnNhdGlvblRvTWFya2Rvd24oXG4gICAgY29udmVyc2F0aW9uOiBDb252ZXJzYXRpb24sXG4gICAgZmlsdGVyQ2FsbGJhY2s/OiBNZXNzYWdlRmlsdGVyQ2FsbGJhY2tcbiAgKTogc3RyaW5nIHtcbiAgICBjb25zdCBzZWN0aW9uczogc3RyaW5nW10gPSBbXTtcbiAgICBzZWN0aW9ucy5wdXNoKGAjICR7Y29udmVyc2F0aW9uLm5hbWV9XFxuYCk7XG5cbiAgICAvLyBBZGQgY29udmVyc2F0aW9uIG1ldGFkYXRhXG4gICAgY29uc3QgY3JlYXRlZERhdGUgPSBuZXcgRGF0ZShjb252ZXJzYXRpb24uY3JlYXRlZF9hdCk7XG4gICAgY29uc3QgdXBkYXRlZERhdGUgPSBuZXcgRGF0ZShjb252ZXJzYXRpb24udXBkYXRlZF9hdCk7XG5cbiAgICBzZWN0aW9ucy5wdXNoKFwiIyMgQ29udmVyc2F0aW9uIERldGFpbHNcIik7XG4gICAgc2VjdGlvbnMucHVzaChcbiAgICAgIGAtIENyZWF0ZWQ6ICR7Y3JlYXRlZERhdGUudG9Mb2NhbGVTdHJpbmcodW5kZWZpbmVkLCB7XG4gICAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgICBtb250aDogXCJsb25nXCIsXG4gICAgICAgIGRheTogXCJudW1lcmljXCIsXG4gICAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgICB0aW1lWm9uZU5hbWU6IFwic2hvcnRcIixcbiAgICAgIH0pfWBcbiAgICApO1xuICAgIHNlY3Rpb25zLnB1c2goXG4gICAgICBgLSBMYXN0IFVwZGF0ZWQ6ICR7dXBkYXRlZERhdGUudG9Mb2NhbGVTdHJpbmcodW5kZWZpbmVkLCB7XG4gICAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgICBtb250aDogXCJsb25nXCIsXG4gICAgICAgIGRheTogXCJudW1lcmljXCIsXG4gICAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgICB0aW1lWm9uZU5hbWU6IFwic2hvcnRcIixcbiAgICAgIH0pfWBcbiAgICApO1xuICAgIHNlY3Rpb25zLnB1c2goXCJcXG4tLS1cXG5cIik7XG5cbiAgICBjb25zdCBmaWx0ZXJlZE1lc3NhZ2VzID0gZmlsdGVyQ2FsbGJhY2tcbiAgICAgID8gY29udmVyc2F0aW9uLmNoYXRfbWVzc2FnZXMuZmlsdGVyKGZpbHRlckNhbGxiYWNrKVxuICAgICAgOiBjb252ZXJzYXRpb24uY2hhdF9tZXNzYWdlcztcblxuICAgIGZpbHRlcmVkTWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZSwgaW5kZXgpID0+IHtcbiAgICAgIC8vIEFkZCBtZXNzYWdlIGhlYWRlciB3aXRoIHRpbWVzdGFtcFxuICAgICAgY29uc3QgbWVzc2FnZURhdGUgPSBuZXcgRGF0ZShtZXNzYWdlLmNyZWF0ZWRfYXQpO1xuICAgICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IG1lc3NhZ2VEYXRlLnRvTG9jYWxlU3RyaW5nKHVuZGVmaW5lZCwge1xuICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgICAgbW9udGg6IFwibG9uZ1wiLFxuICAgICAgICBkYXk6IFwibnVtZXJpY1wiLFxuICAgICAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICAgICAgdGltZVpvbmVOYW1lOiBcInNob3J0XCIsXG4gICAgICB9KTtcblxuICAgICAgc2VjdGlvbnMucHVzaChcbiAgICAgICAgYCMjICR7XG4gICAgICAgICAgbWVzc2FnZS5zZW5kZXIgPT09IFwiaHVtYW5cIiA/IFwiSHVtYW5cIiA6IFwiQXNzaXN0YW50XCJcbiAgICAgICAgfSBfKCR7Zm9ybWF0dGVkRGF0ZX0pX1xcbmBcbiAgICAgICk7XG5cbiAgICAgIG1lc3NhZ2UuY29udGVudC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgc2VjdGlvbnMucHVzaChpdGVtLnRleHQgfHwgXCJcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBcInRvb2xfdXNlXCIgJiYgaXRlbS5pbnB1dCkge1xuICAgICAgICAgIC8vIEhhbmRsZSBhcnRpZmFjdHNcbiAgICAgICAgICBjb25zdCBhcnRpZmFjdCA9IHRoaXMuZXh0cmFjdFNpbmdsZUFydGlmYWN0KGl0ZW0uaW5wdXQpO1xuICAgICAgICAgIGlmIChhcnRpZmFjdCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaChgXFxuKipBcnRpZmFjdDogJHthcnRpZmFjdC50aXRsZX0qKmApO1xuICAgICAgICAgICAgaWYgKGFydGlmYWN0LmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChcIlxcbmBgYFwiICsgKGFydGlmYWN0Lmxhbmd1YWdlIHx8IFwiXCIpKTtcbiAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChhcnRpZmFjdC5jb250ZW50KTtcbiAgICAgICAgICAgICAgc2VjdGlvbnMucHVzaChcImBgYFxcblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW5kZXggPCBmaWx0ZXJlZE1lc3NhZ2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgc2VjdGlvbnMucHVzaChcIlxcbi0tLVxcblwiKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzZWN0aW9ucy5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGEgc2luZ2xlIGFydGlmYWN0IGZyb20gbWVzc2FnZSBpbnB1dFxuICAgKiBAcGFyYW0gaW5wdXQgLSBNZXNzYWdlIGlucHV0IGNvbnRhaW5pbmcgYXJ0aWZhY3QgZGF0YVxuICAgKiBAcmV0dXJucyBBcnRpZmFjdCBpbmZvcm1hdGlvbiBmb3IgbWFya2Rvd24gb3IgbnVsbCBpZiBpbnZhbGlkXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBleHRyYWN0U2luZ2xlQXJ0aWZhY3QoXG4gICAgaW5wdXQ6IENoYXRNZXNzYWdlSW5wdXRcbiAgKTogTWFya2Rvd25BcnRpZmFjdCB8IG51bGwge1xuICAgIGlmICghaW5wdXQudGl0bGUpIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRpdGxlOiBpbnB1dC50aXRsZSxcbiAgICAgIGxhbmd1YWdlOiBpbnB1dC5sYW5ndWFnZSxcbiAgICAgIGNvbnRlbnQ6IGlucHV0LmNvbnRlbnQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGN1cnJlbnQgY29udmVyc2F0aW9uIGRldGFpbHMgaW5jbHVkaW5nIGxhdGVzdCBtZXNzYWdlIElEXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHsgY29udmVyc2F0aW9uSWQsIHBhcmVudE1lc3NhZ2VVdWlkIH1cbiAgICogQHRocm93cyBFcnJvciBpZiBjb252ZXJzYXRpb24gZGV0YWlscyBjYW5ub3QgYmUgcmV0cmlldmVkXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIGdldEN1cnJlbnRDb252ZXJzYXRpb25EZXRhaWxzKCk6IFByb21pc2U8e1xuICAgIGNvbnZlcnNhdGlvbklkOiBzdHJpbmc7XG4gICAgcGFyZW50TWVzc2FnZVV1aWQ6IHN0cmluZztcbiAgfT4ge1xuICAgIC8vIEdldCBjb252ZXJzYXRpb24gSUQgZnJvbSBVUkxcbiAgICBjb25zdCBjb252ZXJzYXRpb25JZCA9IHRoaXMuZ2V0Q29udmVyc2F0aW9uSWRGcm9tVXJsKCk7XG4gICAgY29uc3Qgb3JnSWQgPSBnZXRPcmdhbml6YXRpb25JZCgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjb252ZXJzYXRpb24gZGV0YWlsc1xuICAgICAgY29uc3QgY29udmVyc2F0aW9uID0gYXdhaXQgdGhpcy5nZXRDb252ZXJzYXRpb24oXG4gICAgICAgIG9yZ0lkLFxuICAgICAgICBjb252ZXJzYXRpb25JZCxcbiAgICAgICAgdHJ1ZVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udmVyc2F0aW9uSWQsXG4gICAgICAgIHBhcmVudE1lc3NhZ2VVdWlkOiBjb252ZXJzYXRpb24uY3VycmVudF9sZWFmX21lc3NhZ2VfdXVpZCxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBnZXQgY29udmVyc2F0aW9uIGRldGFpbHM6ICR7XG4gICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIlxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDI0IE1hcnRpbiBCZWNoYXJkIDxtYXJ0aW4uYmVjaGFyZEBEZXZDb25zdWx0LmNhPlxuICogVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBGaWxlOiAvVXNlcnMvbWFydGluYmVjaGFyZC9kZXYvY2xhdWRlZXh0L3NyYy9zZXJ2aWNlcy9Eb2N1bWVudERvd25sb2FkLnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKlxuICogU2VydmljZSBmb3IgaGFuZGxpbmcgZG9jdW1lbnQgZG93bmxvYWRzIHdpdGggc3VwcG9ydCBmb3IgZHluYW1pYyBjb250ZW50IHJldHJpZXZhbFxuICogTm90ZTogWW91ciBmcmllbmRseSBuZWlnaGJvcmhvb2QgZmlsZSBkb3dubG9hZGVyIVxuICovXG5cbmltcG9ydCB0eXBlIHsgRG9jdW1lbnRJbmZvIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmV4cG9ydCBjbGFzcyBEb2N1bWVudERvd25sb2FkIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya2Rvd24gY29udGVudCBmcm9tIG11bHRpcGxlIGRvY3VtZW50c1xuICAgKiBAcGFyYW0gZG9jcyAtIEFycmF5IG9mIGRvY3VtZW50cyB0byBjb21iaW5lXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIG1hcmtkb3duIHN0cmluZ1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgY3JlYXRlTWFya2Rvd25Db250ZW50KFxuICAgIGRvY3M6IERvY3VtZW50SW5mb1tdXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qgc2VjdGlvbnM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgZ3JvdXBlZERvY3MgPSB0aGlzLmdyb3VwRG9jdW1lbnRzQnlEaXJlY3RvcnkoZG9jcyk7XG5cbiAgICBjb25zdCBzaW5nbGVGaWxlID0gT2JqZWN0LmtleXMoZ3JvdXBlZERvY3MpLmxlbmd0aCA+IDE7XG5cbiAgICBzZWN0aW9ucy5wdXNoKFwiIyBzcmNcXG5cIik7XG5cbiAgICBmb3IgKGNvbnN0IFtkaXJlY3RvcnksIGRpckRvY3NdIG9mIE9iamVjdC5lbnRyaWVzKGdyb3VwZWREb2NzKSkge1xuICAgICAgaWYgKGRpcmVjdG9yeSAhPT0gXCJcIiAmJiAhc2luZ2xlRmlsZSkge1xuICAgICAgICBzZWN0aW9ucy5wdXNoKGAjIyAke2RpcmVjdG9yeX1cXG5gKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBkb2Mgb2YgZGlyRG9jcykge1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBkb2MuZmlsZVBhdGguc3BsaXQoXCIuXCIpLnBvcCgpIHx8IFwiXCI7XG4gICAgICAgIGNvbnN0IGxhbmd1YWdlID0gdGhpcy5nZXRMYW5ndWFnZUZyb21FeHRlbnNpb24oZXh0ZW5zaW9uKTtcblxuICAgICAgICBzZWN0aW9ucy5wdXNoKGAjIyAke2RvYy5maWxlUGF0aH1cXG5gKTtcblxuICAgICAgICBpZiAoIXNpbmdsZUZpbGUpIHtcbiAgICAgICAgICBzZWN0aW9ucy5wdXNoKFwiYGBgXCIgKyBsYW5ndWFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgY29udGVudENhbGxiYWNrIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVzZSBzdGF0aWMgY29udGVudFxuICAgICAgICBjb25zdCBjb250ZW50ID0gZG9jLmNvbnRlbnRDYWxsYmFja1xuICAgICAgICAgID8gYXdhaXQgZG9jLmNvbnRlbnRDYWxsYmFjayhkb2MpXG4gICAgICAgICAgOiBkb2MuY29udGVudDtcblxuICAgICAgICBzZWN0aW9ucy5wdXNoKGNvbnRlbnQpO1xuICAgICAgICBpZiAoIXNpbmdsZUZpbGUpIHtcbiAgICAgICAgICBzZWN0aW9ucy5wdXNoKFwiYGBgXFxuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb25zLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICAvKipcbiAgICogR3JvdXBzIGRvY3VtZW50cyBieSB0aGVpciBkaXJlY3RvcnkgcGF0aFxuICAgKiBAcGFyYW0gZG9jcyAtIERvY3VtZW50cyB0byBncm91cFxuICAgKiBAcmV0dXJucyBSZWNvcmQgb2YgZGlyZWN0b3J5IHBhdGhzIHRvIGRvY3VtZW50IGFycmF5c1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ3JvdXBEb2N1bWVudHNCeURpcmVjdG9yeShcbiAgICBkb2NzOiBEb2N1bWVudEluZm9bXVxuICApOiBSZWNvcmQ8c3RyaW5nLCBEb2N1bWVudEluZm9bXT4ge1xuICAgIGNvbnN0IGdyb3VwczogUmVjb3JkPHN0cmluZywgRG9jdW1lbnRJbmZvW10+ID0ge307XG5cbiAgICBkb2NzLmZvckVhY2goKGRvYykgPT4ge1xuICAgICAgY29uc3QgcGF0aCA9IGRvYy5maWxlUGF0aDtcbiAgICAgIGNvbnN0IGxhc3RTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgICAgY29uc3QgZGlyZWN0b3J5ID0gbGFzdFNsYXNoID4gMCA/IHBhdGguc3Vic3RyaW5nKDAsIGxhc3RTbGFzaCkgOiBcIlwiO1xuXG4gICAgICBpZiAoIWdyb3Vwc1tkaXJlY3RvcnldKSB7XG4gICAgICAgIGdyb3Vwc1tkaXJlY3RvcnldID0gW107XG4gICAgICB9XG4gICAgICBncm91cHNbZGlyZWN0b3J5XS5wdXNoKGRvYyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZ3JvdXBzKVxuICAgICAgLnNvcnQoKVxuICAgICAgLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgICAgICAgb2JqW2tleV0gPSBncm91cHNba2V5XS5zb3J0KChhLCBiKSA9PlxuICAgICAgICAgIGEuZmlsZU5hbWUubG9jYWxlQ29tcGFyZShiLmZpbGVOYW1lKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgRG9jdW1lbnRJbmZvW10+KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXBzIGZpbGUgZXh0ZW5zaW9ucyB0byBsYW5ndWFnZSBpZGVudGlmaWVycyBmb3Igc3ludGF4IGhpZ2hsaWdodGluZ1xuICAgKiBAcGFyYW0gZXh0ZW5zaW9uIC0gRmlsZSBleHRlbnNpb24gd2l0aG91dCBkb3RcbiAgICogQHJldHVybnMgTGFuZ3VhZ2UgaWRlbnRpZmllciBzdHJpbmdcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGdldExhbmd1YWdlRnJvbUV4dGVuc2lvbihleHRlbnNpb246IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgbGFuZ3VhZ2VNYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICB0czogXCJ0eXBlc2NyaXB0XCIsXG4gICAgICBqczogXCJqYXZhc2NyaXB0XCIsXG4gICAgICBqc3g6IFwianN4XCIsXG4gICAgICB0c3g6IFwidHN4XCIsXG4gICAgICBjc3M6IFwiY3NzXCIsXG4gICAgICBzY3NzOiBcInNjc3NcIixcbiAgICAgIGh0bWw6IFwiaHRtbFwiLFxuICAgICAganNvbjogXCJqc29uXCIsXG4gICAgICBtZDogXCJtYXJrZG93blwiLFxuICAgICAgcHk6IFwicHl0aG9uXCIsXG4gICAgICByYjogXCJydWJ5XCIsXG4gICAgICBqYXZhOiBcImphdmFcIixcbiAgICAgIGNwcDogXCJjcHBcIixcbiAgICAgIGM6IFwiY1wiLFxuICAgICAgY3M6IFwiY3NoYXJwXCIsXG4gICAgICBnbzogXCJnb1wiLFxuICAgICAgcnM6IFwicnVzdFwiLFxuICAgICAgcGhwOiBcInBocFwiLFxuICAgICAgc3FsOiBcInNxbFwiLFxuICAgICAgeWFtbDogXCJ5YW1sXCIsXG4gICAgICB5bWw6IFwieWFtbFwiLFxuICAgICAgeG1sOiBcInhtbFwiLFxuICAgICAgc2g6IFwiYmFzaFwiLFxuICAgICAgYmFzaDogXCJiYXNoXCIsXG4gICAgICB6c2g6IFwiYmFzaFwiLFxuICAgICAgc3dpZnQ6IFwic3dpZnRcIixcbiAgICB9O1xuXG4gICAgcmV0dXJuIGxhbmd1YWdlTWFwW2V4dGVuc2lvbi50b0xvd2VyQ2FzZSgpXSB8fCBcIlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBmaWxlIGRvd25sb2FkIHRocm91Z2ggQ2hyb21lIGV4dGVuc2lvblxuICAgKiBAcGFyYW0gY29udGVudCAtIENvbnRlbnQgdG8gZG93bmxvYWRcbiAgICogQHBhcmFtIGZpbGVQYXRoIC0gTmFtZSBmb3IgZG93bmxvYWRlZCBmaWxlXG4gICAqIEBwYXJhbSBpc0J1bmRsZWQgLSBXaGV0aGVyIHRoZSBjb250ZW50IGlzIGEgbWFya2Rvd24gYnVuZGxlXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBkb3dubG9hZENvbnRlbnQoXG4gICAgY29udGVudDogc3RyaW5nLFxuICAgIGZpbGVQYXRoOiBzdHJpbmcsXG4gICAgaXNCdW5kbGVkOiBib29sZWFuID0gZmFsc2VcbiAgKTogdm9pZCB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gZmlsZVBhdGguc3BsaXQoXCIuXCIpLnBvcCgpIHx8IFwiXCI7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBpc0J1bmRsZWRcbiAgICAgID8gXCJcIlxuICAgICAgOiB0aGlzLmdldExhbmd1YWdlRnJvbUV4dGVuc2lvbihleHRlbnNpb24pIHx8IFwicGxhaW5cIjtcblxuICAgIGNvbnN0IG1pbWVUeXBlID0gaXNCdW5kbGVkID8gXCJ0ZXh0L21hcmtkb3duXCIgOiBgdGV4dC8ke2xhbmd1YWdlfWA7XG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtjb250ZW50XSwgeyB0eXBlOiBtaW1lVHlwZSB9KTtcbiAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlKFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJkb3dubG9hZFwiLFxuICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgIGZpbGVuYW1lOiBmaWxlUGF0aCxcbiAgICAgICAgfSxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRG93bmxvYWQgZmFpbGVkOlwiLCByZXNwb25zZS5lcnJvcik7XG4gICAgICAgICAgICBhbGVydChcIkZhaWxlZCB0byBzdGFydCBkb3dubG9hZC4gUGxlYXNlIHRyeSBhZ2Fpbi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IFVSTC5yZXZva2VPYmplY3RVUkwodXJsKSwgMTAwMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERvd25sb2FkcyBzZWxlY3RlZCBkb2N1bWVudHMgYXMgYSBzaW5nbGUgbWFya2Rvd24gZmlsZVxuICAgKiBAcGFyYW0gc2VsZWN0ZWREb2NzIC0gQXJyYXkgb2YgZG9jdW1lbnRzIHRvIGRvd25sb2FkXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgbm8gZG9jdW1lbnRzIHNlbGVjdGVkIG9yIGRvd25sb2FkIGZhaWxzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIGhhbmRsZVNpbmdsZURvd25sb2FkKFxuICAgIHNlbGVjdGVkRG9jczogRG9jdW1lbnRJbmZvW11cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHNlbGVjdGVkRG9jcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGRvY3VtZW50cyBzZWxlY3RlZCBmb3IgZXhwb3J0XCIpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBtYXJrZG93bkNvbnRlbnQgPSBhd2FpdCB0aGlzLmNyZWF0ZU1hcmtkb3duQ29udGVudChzZWxlY3RlZERvY3MpO1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKVxuICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAucmVwbGFjZSgvWzpdL2csIFwiLVwiKVxuICAgICAgICAuc3BsaXQoXCIuXCIpWzBdO1xuICAgICAgY29uc3QgZmlsZW5hbWUgPSBgY2xhdWRlLWV4cG9ydC0ke3RpbWVzdGFtcH0ubWRgO1xuICAgICAgdGhpcy5kb3dubG9hZENvbnRlbnQobWFya2Rvd25Db250ZW50LCBmaWxlbmFtZSwgdHJ1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBleHBvcnQgZG9jdW1lbnQgYnVuZGxlOiAke1xuICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERvd25sb2FkcyBlYWNoIHNlbGVjdGVkIGRvY3VtZW50IGFzIGEgc2VwYXJhdGUgZmlsZVxuICAgKiBAcGFyYW0gc2VsZWN0ZWREb2NzIC0gQXJyYXkgb2YgZG9jdW1lbnRzIHRvIGRvd25sb2FkXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgbm8gZG9jdW1lbnRzIHNlbGVjdGVkIG9yIGRvd25sb2FkIGZhaWxzXG4gICAqL1xuICAvLyBJbiBEb2N1bWVudERvd25sb2FkLnRzLCB1cGRhdGUgdGhlIGhhbmRsZU11bHRpcGxlRG93bmxvYWQgbWV0aG9kOlxuXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgaGFuZGxlTXVsdGlwbGVEb3dubG9hZChcbiAgICBzZWxlY3RlZERvY3M6IERvY3VtZW50SW5mb1tdXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChzZWxlY3RlZERvY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkb2N1bWVudHMgc2VsZWN0ZWQgZm9yIGV4cG9ydFwiKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChjb25zdCBkb2Mgb2Ygc2VsZWN0ZWREb2NzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2MuY29udGVudENhbGxiYWNrXG4gICAgICAgICAgPyBhd2FpdCBkb2MuY29udGVudENhbGxiYWNrKGRvYylcbiAgICAgICAgICA6IGRvYy5jb250ZW50O1xuXG4gICAgICAgIC8vIFVzZSB0aGUgZnVsbCBwYXRoIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGZpbGVuYW1lXG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gZG9jLmZpbGVQYXRoIHx8IGRvYy5maWxlTmFtZTtcblxuICAgICAgICB0aGlzLmRvd25sb2FkQ29udGVudChjb250ZW50LCBmaWxlUGF0aCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZXhwb3J0IGluZGl2aWR1YWwgZG9jdW1lbnRzOiAke1xuICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgbWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYVxuLy8gVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4vLyBGaWxlOiBzcmMvc2VydmljZXMvRG9jdW1lbnRSZXRyaWV2YWwudHNcbi8vIFNlcnZpY2UgZm9yIHJldHJpZXZpbmcgQ2xhdWRlLWdlbmVyYXRlZCBkb2N1bWVudHNcbi8vIE5vdGU6IExpa2UgYSBsaWJyYXJpYW4gZm9yIHlvdXIgQUkncyBjcmVhdGl2ZSB3b3JrcyFcblxuaW1wb3J0IHR5cGUgeyBEb2N1bWVudEluZm8gfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IERvd25sb2FkVGFibGUgfSBmcm9tIFwiLi4vdWkvY29tcG9uZW50cy9Eb3dubG9hZFRhYmxlXCI7XG5pbXBvcnQgeyBnZXRPcmdhbml6YXRpb25JZCwgZ2V0UHJvamVjdFV1aWQgfSBmcm9tIFwiLi4vdXRpbHMvZ2V0Q2xhdWRlSWRzXCI7XG5pbXBvcnQgeyBDbGF1ZGVDYWNoZSB9IGZyb20gXCIuL0NsYXVkZUNhY2hlXCI7XG5pbXBvcnQgeyBleHRyYWN0UmVsUGF0aCB9IGZyb20gXCJAL3V0aWxzL1BhdGhFeHRyYWN0b3JcIjtcblxuZXhwb3J0IGNsYXNzIERvY3VtZW50UmV0cmlldmFsIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQVBJX1VSTCA9IFwiaHR0cHM6Ly9hcGkuY2xhdWRlLmFpL2FwaS9vcmdhbml6YXRpb25zXCI7XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgYXZhaWxhYmxlIGRvY3VtZW50cyBmcm9tIHRoZSBBUEkgd2l0aCBjYWNoaW5nXG4gICAqIEBwYXJhbSBmb3JjZVJlZnJlc2ggRm9yY2UgcmVmcmVzaCBmcm9tIEFQSSBpbnN0ZWFkIG9mIGNhY2hlXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgZG9jdW1lbnRzIGNhbm5vdCBiZSByZXRyaWV2ZWRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgZmV0Y2hEb2N1bWVudHMoXG4gICAgZm9yY2VSZWZyZXNoOiBib29sZWFuID0gZmFsc2VcbiAgKTogUHJvbWlzZTxEb2N1bWVudEluZm9bXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvcmdhbml6YXRpb25JZCA9IGdldE9yZ2FuaXphdGlvbklkKCk7XG4gICAgICBjb25zdCBwcm9qZWN0VXVpZCA9IGF3YWl0IGdldFByb2plY3RVdWlkKG9yZ2FuaXphdGlvbklkKTtcblxuICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5BUElfVVJMfS8ke29yZ2FuaXphdGlvbklkfS9wcm9qZWN0cy8ke3Byb2plY3RVdWlkfS9kb2NzYDtcblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IENsYXVkZUNhY2hlLmZldGNoV2l0aENhY2hlPGFueVtdPih1cmwsIHtcbiAgICAgICAgdGltZW91dE1zOiAzMDAwMDAsIC8vIENhY2hlIGRvY3VtZW50cyBmb3IgNSBtaW51dGVzXG4gICAgICAgIGZvcmNlUmVmcmVzaCxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzRG9jdW1lbnRzKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBFcnJvciBmZXRjaGluZyBkb2N1bWVudHM6ICR7XG4gICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIlxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGxheXMgZG9jdW1lbnRzIGluIHRoZSBwcm92aWRlZCBvdXRwdXQgZWxlbWVudFxuICAgKiBAcGFyYW0gZG9jcyAtIERvY3VtZW50cyB0byBkaXNwbGF5XG4gICAqIEBwYXJhbSBvdXRwdXRFbGVtZW50IC0gRWxlbWVudCB0byBkaXNwbGF5IGRvY3VtZW50cyBpblxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBkaXNwbGF5RG9jdW1lbnRzKFxuICAgIGRvY3M6IERvY3VtZW50SW5mb1tdLFxuICAgIG91dHB1dEVsZW1lbnQ6IEhUTUxFbGVtZW50XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIG91dHB1dEVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBjb25zdCB0YWJsZSA9IG5ldyBEb3dubG9hZFRhYmxlKG91dHB1dEVsZW1lbnQsIGRvY3MpO1xuICAgIHRhYmxlLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyByYXcgZG9jdW1lbnQgZGF0YSBpbnRvIERvY3VtZW50SW5mbyBvYmplY3RzXG4gICAqIEBwYXJhbSBkYXRhIC0gUmF3IGRvY3VtZW50IGRhdGEgZnJvbSBBUElcbiAgICogQHJldHVybnMgUHJvY2Vzc2VkIGRvY3VtZW50IGluZm9ybWF0aW9uXG4gICAqL1xuXG4gIHByaXZhdGUgc3RhdGljIHByb2Nlc3NEb2N1bWVudHMoZGF0YTogYW55W10pOiBEb2N1bWVudEluZm9bXSB7XG4gICAgcmV0dXJuIGRhdGEubWFwKChkb2MpID0+IHtcbiAgICAgIC8vIEV4dHJhY3QgcGF0aCBmcm9tIGNvbnRlbnQsIHdpdGhvdXQgZm9yY2luZyBhbiBleHRlbnNpb25cbiAgICAgIGNvbnN0IGZpbGVQYXRoTWF0Y2ggPSBleHRyYWN0UmVsUGF0aChkb2MuY29udGVudCk7XG4gICAgICBjb25zdCBmaWxlUGF0aCA9IGZpbGVQYXRoTWF0Y2ggfHwgZG9jLmZpbGVfbmFtZTtcblxuICAgICAgLy8gQ29udmVydCBkaXJlY3Rvcnkgc2VwYXJhdG9ycyB0byBrYWJvYiBjYXNlIGJ1dCBrZWVwIGZpbGVuYW1lIGFzIGlzXG4gICAgICBjb25zdCBwcm9jZXNzZWRQYXRoID0gZmlsZVBhdGhcbiAgICAgICAgLnNwbGl0KFwiL1wiKVxuICAgICAgICAubWFwKChwYXJ0LCBpbmRleCwgYXJyKSA9PiB7XG4gICAgICAgICAgLy8gRG9uJ3QgdHJhbnNmb3JtIHRoZSBmaWxlbmFtZSAobGFzdCBwYXJ0KVxuICAgICAgICAgIGlmIChpbmRleCA9PT0gYXJyLmxlbmd0aCAtIDEpIHJldHVybiBwYXJ0O1xuICAgICAgICAgIC8vIFRyYW5zZm9ybSBkaXJlY3RvcnkgbmFtZXMgdG8ga2Fib2IgY2FzZVxuICAgICAgICAgIHJldHVybiBwYXJ0LnJlcGxhY2UoL1xccysvZywgXCItXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKFwiL1wiKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZU5hbWU6IGRvYy5maWxlX25hbWUsXG4gICAgICAgIGZpbGVQYXRoOiBwcm9jZXNzZWRQYXRoLFxuICAgICAgICBjb250ZW50OiBkb2MuY29udGVudCB8fCBcIlwiLFxuICAgICAgICBpc1NlbGVjdGVkOiBkb2MuY29udGVudD8uaW5jbHVkZXMoXG4gICAgICAgICAgXCJUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldFwiXG4gICAgICAgICksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgY3JlYXRlZF9hdDogZG9jLmNyZWF0ZWRfYXQsXG4gICAgICAgICAgdXBkYXRlZF9hdDogZG9jLnVwZGF0ZWRfYXQgfHwgZG9jLmNyZWF0ZWRfYXQsIC8vIEZhbGxiYWNrIHRvIGNyZWF0ZWRfYXQgaWYgdXBkYXRlZF9hdCBub3QgYXZhaWxhYmxlXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgbWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYVxuLy8gVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4vLyBGaWxlOiBzcmMvc2VydmljZXMvUHJvamVjdFJldHJpZXZhbC50c1xuLy8gU2VydmljZSBmb3IgcmV0cmlldmluZyBhbmQgbWFuYWdpbmcgQ2xhdWRlIHByb2plY3QgZGF0YVxuLy8gTm90ZTogVGhlIHByb2plY3QgbWFuYWdlciB0aGF0IGtlZXBzIHlvdXIgY29udmVyc2F0aW9ucyBvcmdhbml6ZWQhXG5cbmltcG9ydCB0eXBlIHsgRG9jdW1lbnRJbmZvLCBQcm9qZWN0Q29udmVyc2F0aW9uIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBnZXRPcmdhbml6YXRpb25JZCwgZ2V0UHJvamVjdFV1aWQgfSBmcm9tIFwiLi4vdXRpbHMvZ2V0Q2xhdWRlSWRzXCI7XG5pbXBvcnQgeyBEb3dubG9hZFRhYmxlIH0gZnJvbSBcIi4uL3VpL2NvbXBvbmVudHMvRG93bmxvYWRUYWJsZVwiO1xuaW1wb3J0IHsgQ29udmVyc2F0aW9uUmV0cmlldmFsIH0gZnJvbSBcIi4vQ29udmVyc2F0aW9uUmV0cmlldmFsXCI7XG5pbXBvcnQgeyBDbGF1ZGVDYWNoZSB9IGZyb20gXCIuL0NsYXVkZUNhY2hlXCI7XG5cbi8qKlxuICogU2VydmljZSBmb3IgbWFuYWdpbmcgQ2xhdWRlIHByb2plY3RzIGFuZCB0aGVpciBjb252ZXJzYXRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9qZWN0UmV0cmlldmFsIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQVBJX1VSTCA9IFwiaHR0cHM6Ly9hcGkuY2xhdWRlLmFpL2FwaS9vcmdhbml6YXRpb25zXCI7XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbGwgY29udmVyc2F0aW9ucyBpbiB0aGUgY3VycmVudCBwcm9qZWN0IHdpdGggY2FjaGluZ1xuICAgKiBAcGFyYW0gZm9yY2VSZWZyZXNoIEZvcmNlIHJlZnJlc2ggZnJvbSBBUEkgaW5zdGVhZCBvZiBjYWNoZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBwcm9qZWN0IGNvbnZlcnNhdGlvbnNcbiAgICogQHRocm93cyBFcnJvciBpZiByZXRyaWV2YWwgZmFpbHNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgZ2V0UHJvamVjdENvbnZlcnNhdGlvbnMoXG4gICAgZm9yY2VSZWZyZXNoOiBib29sZWFuID0gZmFsc2VcbiAgKTogUHJvbWlzZTxQcm9qZWN0Q29udmVyc2F0aW9uW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3JnSWQgPSBnZXRPcmdhbml6YXRpb25JZCgpO1xuICAgICAgY29uc3QgcHJvamVjdElkID0gYXdhaXQgZ2V0UHJvamVjdFV1aWQob3JnSWQpO1xuICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5BUElfVVJMfS8ke29yZ0lkfS9wcm9qZWN0cy8ke3Byb2plY3RJZH0vY29udmVyc2F0aW9uc2A7XG5cbiAgICAgIHJldHVybiBhd2FpdCBDbGF1ZGVDYWNoZS5mZXRjaFdpdGhDYWNoZTxQcm9qZWN0Q29udmVyc2F0aW9uW10+KHVybCwge1xuICAgICAgICB0aW1lb3V0TXM6IDEyMDAwMCwgLy8gQ2FjaGUgcHJvamVjdCBjb252ZXJzYXRpb25zIGZvciAyIG1pbnV0ZXNcbiAgICAgICAgZm9yY2VSZWZyZXNoLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEVycm9yIHJldHJpZXZpbmcgcHJvamVjdCBjb252ZXJzYXRpb25zOiAke1xuICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGNvbnZlcnNhdGlvbnMgdG8gRG9jdW1lbnRJbmZvIGZvcm1hdCBmb3IgRG93bmxvYWRUYWJsZVxuICAgKiBAcGFyYW0gY29udmVyc2F0aW9ucyAtIEFycmF5IG9mIHByb2plY3QgY29udmVyc2F0aW9uc1xuICAgKiBAcmV0dXJucyBBcnJheSBvZiBEb2N1bWVudEluZm8gb2JqZWN0c1xuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgY29udmVydENvbnZlcnNhdGlvbnNUb0RvY3VtZW50SW5mbyhcbiAgICBjb252ZXJzYXRpb25zOiBQcm9qZWN0Q29udmVyc2F0aW9uW11cbiAgKTogRG9jdW1lbnRJbmZvW10ge1xuICAgIHJldHVybiBjb252ZXJzYXRpb25zLm1hcCgoY29udmVyc2F0aW9uKSA9PiAoe1xuICAgICAgZmlsZU5hbWU6IGNvbnZlcnNhdGlvbi5uYW1lLFxuICAgICAgZmlsZVBhdGg6IGAke2NvbnZlcnNhdGlvbi5uYW1lLnJlcGxhY2UoL1xccysvZywgXCItXCIpfS5tZGAsXG4gICAgICBjb250ZW50OiB0aGlzLmNyZWF0ZUNvbnZlcnNhdGlvblN1bW1hcnkoY29udmVyc2F0aW9uKSxcbiAgICAgIGlzU2VsZWN0ZWQ6IGZhbHNlLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgY29udmVyc2F0aW9uSWQ6IGNvbnZlcnNhdGlvbi51dWlkLFxuICAgICAgICB1cmw6IGBodHRwczovL2NsYXVkZS5haS9jaGF0LyR7Y29udmVyc2F0aW9uLnV1aWR9YCxcbiAgICAgICAgY3JlYXRlZF9hdDogY29udmVyc2F0aW9uLmNyZWF0ZWRfYXQsXG4gICAgICAgIHVwZGF0ZWRfYXQ6IGNvbnZlcnNhdGlvbi51cGRhdGVkX2F0LFxuICAgICAgfSxcbiAgICAgIGNvbnRlbnRDYWxsYmFjazogYXN5bmMgKGRvYzogRG9jdW1lbnRJbmZvKSA9PiB7XG4gICAgICAgIGNvbnN0IG9yZ0lkID0gZ2V0T3JnYW5pemF0aW9uSWQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjb252ID0gYXdhaXQgQ29udmVyc2F0aW9uUmV0cmlldmFsLmdldENvbnZlcnNhdGlvbihcbiAgICAgICAgICAgIG9yZ0lkLFxuICAgICAgICAgICAgY29udmVyc2F0aW9uLnV1aWQsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gQ29udmVyc2F0aW9uUmV0cmlldmFsLmNvbnZlcnNhdGlvblRvTWFya2Rvd24oY29udik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBnZXQgY29udmVyc2F0aW9uOlwiLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWFya2Rvd24gc3VtbWFyeSBvZiBhIGNvbnZlcnNhdGlvblxuICAgKiBAcGFyYW0gY29udmVyc2F0aW9uIC0gQ29udmVyc2F0aW9uIHRvIHN1bW1hcml6ZVxuICAgKiBAcmV0dXJucyBNYXJrZG93biBmb3JtYXR0ZWQgc3VtbWFyeVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgY3JlYXRlQ29udmVyc2F0aW9uU3VtbWFyeShcbiAgICBjb252ZXJzYXRpb246IFByb2plY3RDb252ZXJzYXRpb25cbiAgKTogc3RyaW5nIHtcbiAgICBjb25zdCBzZWN0aW9uczogc3RyaW5nW10gPSBbXTtcblxuICAgIHNlY3Rpb25zLnB1c2goYCMgJHtjb252ZXJzYXRpb24ubmFtZX1cXG5gKTtcbiAgICBzZWN0aW9ucy5wdXNoKGBVVUlEOiAke2NvbnZlcnNhdGlvbi51dWlkfWApO1xuICAgIHNlY3Rpb25zLnB1c2goXG4gICAgICBgQ3JlYXRlZDogJHtuZXcgRGF0ZShjb252ZXJzYXRpb24uY3JlYXRlZF9hdCkudG9Mb2NhbGVTdHJpbmcoKX1gXG4gICAgKTtcbiAgICBzZWN0aW9ucy5wdXNoKFxuICAgICAgYFVwZGF0ZWQ6ICR7bmV3IERhdGUoY29udmVyc2F0aW9uLnVwZGF0ZWRfYXQpLnRvTG9jYWxlU3RyaW5nKCl9YFxuICAgICk7XG4gICAgc2VjdGlvbnMucHVzaChgXFxuTWVzc2FnZSBDb3VudDogJHtjb252ZXJzYXRpb24ubWVzc2FnZV9jb3VudH1gKTtcblxuICAgIGlmIChjb252ZXJzYXRpb24uc3VtbWFyeSkge1xuICAgICAgc2VjdGlvbnMucHVzaChgXFxuIyMgU3VtbWFyeVxcbiR7Y29udmVyc2F0aW9uLnN1bW1hcnl9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb25zLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGxheXMgcHJvamVjdCBjb252ZXJzYXRpb25zIGluIHRoZSBvdXRwdXQgZWxlbWVudFxuICAgKiBAcGFyYW0gZG9jcyAtIERvY3VtZW50cyB0byBkaXNwbGF5XG4gICAqIEBwYXJhbSBvdXRwdXRFbGVtZW50IC0gRWxlbWVudCB0byBkaXNwbGF5IGRvY3VtZW50cyBpblxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBkaXNwbGF5Q29udmVyc2F0aW9ucyhcbiAgICBkb2NzOiBEb2N1bWVudEluZm9bXSxcbiAgICBvdXRwdXRFbGVtZW50OiBIVE1MRWxlbWVudFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBvdXRwdXRFbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgY29uc3QgdGFibGUgPSBuZXcgRG93bmxvYWRUYWJsZShvdXRwdXRFbGVtZW50LCBkb2NzKTtcbiAgICB0YWJsZS5yZW5kZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYW5kIGRpc3BsYXlzIGNvbnZlcnNhdGlvbnMgaW4gdGhlIGN1cnJlbnQgcHJvamVjdFxuICAgKiBAcGFyYW0gb3V0cHV0RWxlbWVudCAtIEVsZW1lbnQgdG8gZGlzcGxheSB0aGUgY29udmVyc2F0aW9ucyBpblxuICAgKiBAcGFyYW0gZm9yY2VSZWZyZXNoIEZvcmNlIHJlZnJlc2ggZnJvbSBBUEkgaW5zdGVhZCBvZiBjYWNoZVxuICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBkaXNwbGF5IGlzIGNvbXBsZXRlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIGRpc3BsYXlDdXJyZW50UHJvamVjdChcbiAgICBvdXRwdXRFbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgICBmb3JjZVJlZnJlc2g6IGJvb2xlYW4gPSBmYWxzZVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udmVyc2F0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0UHJvamVjdENvbnZlcnNhdGlvbnMoZm9yY2VSZWZyZXNoKTtcbiAgICAgIGNvbnN0IGRvY3MgPSB0aGlzLmNvbnZlcnRDb252ZXJzYXRpb25zVG9Eb2N1bWVudEluZm8oY29udmVyc2F0aW9ucyk7XG5cbiAgICAgIGlmIChkb2NzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjb252ZXJzYXRpb25zIGZvdW5kIGluIHByb2plY3RcIik7XG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuZGlzcGxheUNvbnZlcnNhdGlvbnMoZG9jcywgb3V0cHV0RWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byBkaXNwbGF5IHByb2plY3QgY29udmVyc2F0aW9uczogJHtcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiXG4gICAgICAgIH1gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgPG1hcnRpbi5iZWNoYXJkQERldkNvbnN1bHQuY2E+XG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIEZpbGU6IC9Vc2Vycy9tYXJ0aW5iZWNoYXJkL2Rldi9jbGF1ZGVleHQvc3JjL3NlcnZpY2VzL1Byb2plY3RTZWFyY2hTZXJ2aWNlLnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKlxuICogU2VydmljZSBmb3Igc2VhcmNoaW5nIHRocm91Z2ggcHJvamVjdCBjb252ZXJzYXRpb25zIHVzaW5nIHNlbWFudGljIHNlYXJjaCB3aXRoIGJhdGNoaW5nXG4gKiBOb3RlOiBGaW5kaW5nIG5lZWRsZXMgaW4gY29udmVyc2F0aW9uYWwgaGF5c3RhY2tzLCBvbmUgYmF0Y2ggYXQgYSB0aW1lIVxuICovXG5cbmltcG9ydCB7IFByb2plY3RSZXRyaWV2YWwgfSBmcm9tIFwiLi9Qcm9qZWN0UmV0cmlldmFsXCI7XG5pbXBvcnQgeyBDb252ZXJzYXRpb25SZXRyaWV2YWwgfSBmcm9tIFwiLi9Db252ZXJzYXRpb25SZXRyaWV2YWxcIjtcbmltcG9ydCB7IHJlcXVlc3RDb21wbGV0aW9uIH0gZnJvbSBcIi4uL3V0aWxzL3JlcXVlc3RDb21wbGV0aW9uXCI7XG5pbXBvcnQgeyBnZXRPcmdhbml6YXRpb25JZCB9IGZyb20gXCIuLi91dGlscy9nZXRDbGF1ZGVJZHNcIjtcbmltcG9ydCB7IGdldEhlYWRlcnMgfSBmcm9tIFwiLi4vdXRpbHMvZ2V0SGVhZGVyc1wiO1xuaW1wb3J0IHsgRG93bmxvYWRUYWJsZSB9IGZyb20gXCIuLi91aS9jb21wb25lbnRzL0Rvd25sb2FkVGFibGVcIjtcbmltcG9ydCB0eXBlIHtcbiAgU2VhcmNoUmVzdWx0SW5mbyxcbiAgRG9jdW1lbnRJbmZvLFxuICBQcm9qZWN0Q29udmVyc2F0aW9uLFxuICBDb252ZXJzYXRpb24sXG4gIENoYXRNZXNzYWdlLFxufSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IEFudGhyb3BpY1NlcnZpY2UgfSBmcm9tIFwiLi9BbnRocm9waWNTZXJ2aWNlXCI7XG5cbmV4cG9ydCBjbGFzcyBQcm9qZWN0U2VhcmNoU2VydmljZSB7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEFQSV9VUkwgPSBcImh0dHBzOi8vYXBpLmNsYXVkZS5haS9hcGkvb3JnYW5pemF0aW9uc1wiO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBNQVhfTUVTU0FHRV9MRU5HVEggPSA1MDAwO1xuICBwcml2YXRlIHN0YXRpYyBjdXJyZW50QWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBzdGF0aWMgaXNDYW5jZWxsaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgc3RhdGljIGN1cnJlbnRUYWJsZTogRG93bmxvYWRUYWJsZSB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBNYWtlcyBhIGNvbXBsZXRpb24gcmVxdWVzdCB0byBBbnRocm9waWNcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGFzeW5jIG1ha2VDb21wbGV0aW9uUmVxdWVzdChcbiAgICBwcm9tcHQ6IHN0cmluZyxcbiAgICBzaWduYWw6IEFib3J0U2lnbmFsXG4gICk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgXCJbUHJvamVjdFNlYXJjaFNlcnZpY2VdIE1ha2luZyBjb21wbGV0aW9uIHJlcXVlc3Qgd2l0aCBwcm9tcHQ6XCIsXG4gICAgICBwcm9tcHRcbiAgICApO1xuXG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXG4gICAgICB7XG4gICAgICAgIHJvbGU6IFwidXNlclwiIGFzIGNvbnN0LFxuICAgICAgICBjb250ZW50OiBwcm9tcHQsXG4gICAgICB9LFxuICAgIF07XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBBbnRocm9waWNTZXJ2aWNlLmNvbXBsZXRlKG1lc3NhZ2VzLCB7XG4gICAgICB0ZW1wZXJhdHVyZTogMC43LFxuICAgICAgbWF4VG9rZW5zOiAyMDAwLFxuICAgICAgc2lnbmFsLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgaWYgKHJlc3VsdC5jYW5jZWxsZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJbUHJvamVjdFNlYXJjaFNlcnZpY2VdIFJlcXVlc3QgY2FuY2VsbGVkXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgIFwiW1Byb2plY3RTZWFyY2hTZXJ2aWNlXSBDb21wbGV0aW9uIHJlcXVlc3QgZmFpbGVkOlwiLFxuICAgICAgICByZXN1bHQuZXJyb3JcbiAgICAgICk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0LnRleHQgfHwgbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRG9jdW1lbnRJbmZvIG9iamVjdCBmb3IgYSBjb252ZXJzYXRpb25cbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGNyZWF0ZURvY3VtZW50SW5mbyhcbiAgICBjb252ZXJzYXRpb246IFByb2plY3RDb252ZXJzYXRpb25cbiAgKTogRG9jdW1lbnRJbmZvIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsZU5hbWU6IGNvbnZlcnNhdGlvbi5uYW1lLFxuICAgICAgZmlsZVBhdGg6IGAke2NvbnZlcnNhdGlvbi5uYW1lLnJlcGxhY2UoL1xccysvZywgXCItXCIpfS5tZGAsXG4gICAgICBjb250ZW50OiBjb252ZXJzYXRpb24uc3VtbWFyeSB8fCBcIlwiLFxuICAgICAgaXNTZWxlY3RlZDogZmFsc2UsXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBjb252ZXJzYXRpb25JZDogY29udmVyc2F0aW9uLnV1aWQsXG4gICAgICAgIHVybDogYGh0dHBzOi8vY2xhdWRlLmFpL2NoYXQvJHtjb252ZXJzYXRpb24udXVpZH1gLFxuICAgICAgICBjcmVhdGVkX2F0OiBjb252ZXJzYXRpb24uY3JlYXRlZF9hdCxcbiAgICAgICAgdXBkYXRlZF9hdDogY29udmVyc2F0aW9uLnVwZGF0ZWRfYXQsXG4gICAgICB9LFxuICAgICAgY29udGVudENhbGxiYWNrOiBhc3luYyAoZG9jOiBEb2N1bWVudEluZm8pID0+IHtcbiAgICAgICAgY29uc3Qgb3JnSWQgPSBnZXRPcmdhbml6YXRpb25JZCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNvbnYgPSBhd2FpdCBDb252ZXJzYXRpb25SZXRyaWV2YWwuZ2V0Q29udmVyc2F0aW9uKFxuICAgICAgICAgICAgb3JnSWQsXG4gICAgICAgICAgICBjb252ZXJzYXRpb24udXVpZCxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gRGVmaW5lIG1lc3NhZ2UgZmlsdGVyIGNhbGxiYWNrXG4gICAgICAgICAgY29uc3QgZmlsdGVyTG9uZ01lc3NhZ2VzID0gKG1lc3NhZ2U6IENoYXRNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5mb3JtYXRNZXNzYWdlQ29udGVudChtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50Lmxlbmd0aCA8PSB0aGlzLk1BWF9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuIENvbnZlcnNhdGlvblJldHJpZXZhbC5jb252ZXJzYXRpb25Ub01hcmtkb3duKFxuICAgICAgICAgICAgY29udixcbiAgICAgICAgICAgIGZpbHRlckxvbmdNZXNzYWdlc1xuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiW1Byb2plY3RTZWFyY2hTZXJ2aWNlXSBGYWlsZWQgdG8gZ2V0IGNvbnZlcnNhdGlvbjpcIixcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFib3J0cyB0aGUgY3VycmVudCBzZWFyY2ggb3BlcmF0aW9uIGlmIG9uZSBpcyBpbiBwcm9ncmVzc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhYm9ydFNlYXJjaCgpOiB2b2lkIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmN1cnJlbnRBYm9ydENvbnRyb2xsZXIgJiZcbiAgICAgICF0aGlzLmN1cnJlbnRBYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWRcbiAgICApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiW1Byb2plY3RTZWFyY2hTZXJ2aWNlXSBBYm9ydGluZyBzZWFyY2guLi5cIik7XG4gICAgICB0aGlzLmlzQ2FuY2VsbGluZyA9IHRydWU7XG4gICAgICB0aGlzLmN1cnJlbnRBYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcblxuICAgICAgLy8gVXBkYXRlIFVJIHRvIHNob3cgY2FuY2VsbGluZyBzdGF0ZSBmb3IgdW5wcm9jZXNzZWQgcm93c1xuICAgICAgaWYgKHRoaXMuY3VycmVudFRhYmxlKSB7XG4gICAgICAgIGNvbnN0IHJvd3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwidHJbZGF0YS1jb252ZXJzYXRpb24taWRdXCIpO1xuICAgICAgICByb3dzLmZvckVhY2goKHJvdykgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkID0gcm93LmdldEF0dHJpYnV0ZShcImRhdGEtY29udmVyc2F0aW9uLWlkXCIpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlkICYmXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUYWJsZSAmJlxuICAgICAgICAgICAgIXRoaXMuY3VycmVudFRhYmxlLmlzUm93UHJvY2Vzc2VkKGlkKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGFibGUudXBkYXRlU2VhcmNoUmVzdWx0KFxuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBcIlNlYXJjaCBjYW5jZWxsZWRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyBwcm9qZWN0IGNvbnZlcnNhdGlvbnMgYW5kIGRpc3BsYXlzIHJlc3VsdHMgcHJvZ3Jlc3NpdmVseVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBzZWFyY2hBbmREaXNwbGF5UmVzdWx0cyhcbiAgICBzZWFyY2hUZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgb3V0cHV0RWxlbWVudDogSFRNTEVsZW1lbnQsXG4gICAgY29udmVyc2F0aW9ucz86IFByb2plY3RDb252ZXJzYXRpb25bXVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsZXQgdGFibGU6IERvd25sb2FkVGFibGUgfCBudWxsID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgLy8gUmVzZXQgY2FuY2VsbGluZyBzdGF0ZSBhbmQgY3JlYXRlIG5ldyBhYm9ydCBjb250cm9sbGVyXG4gICAgICB0aGlzLmlzQ2FuY2VsbGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5jdXJyZW50QWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jdXJyZW50QWJvcnRDb250cm9sbGVyLnNpZ25hbDtcblxuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiW1Byb2plY3RTZWFyY2hTZXJ2aWNlXSBTdGFydGluZyBzZWFyY2ggd2l0aCB0ZXh0OlwiLFxuICAgICAgICBzZWFyY2hUZXh0XG4gICAgICApO1xuXG4gICAgICAvLyBHZXQgcHJvamVjdCBjb252ZXJzYXRpb25zIGlmIG5vdCBwcm92aWRlZFxuICAgICAgaWYgKCFjb252ZXJzYXRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiW1Byb2plY3RTZWFyY2hTZXJ2aWNlXSBGZXRjaGluZyBwcm9qZWN0IGNvbnZlcnNhdGlvbnMuLi5cIik7XG4gICAgICAgIGNvbnZlcnNhdGlvbnMgPSBhd2FpdCBQcm9qZWN0UmV0cmlldmFsLmdldFByb2plY3RDb252ZXJzYXRpb25zKHRydWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0aWFsaXplIHRhYmxlIHdpdGgganVzdCBoZWFkZXJzLCBwYXNzaW5nIGZhbHNlIHRvIGRpc2FibGUgQ2FuY2VsIGJ1dHRvblxuICAgICAgdGFibGUgPSBuZXcgRG93bmxvYWRUYWJsZShvdXRwdXRFbGVtZW50LCB0cnVlLCBmYWxzZSk7XG4gICAgICB0aGlzLmN1cnJlbnRUYWJsZSA9IHRhYmxlO1xuXG4gICAgICAvLyBBZGQgZWFjaCBjb252ZXJzYXRpb24gYXMgYSByb3dcbiAgICAgIGZvciAoY29uc3QgY29udiBvZiBjb252ZXJzYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRvY0luZm8gPSB0aGlzLmNyZWF0ZURvY3VtZW50SW5mbyhjb252KTtcbiAgICAgICAgdGFibGUuYWRkUm93KGRvY0luZm8pO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBzZWFyY2ggdGV4dCBwcm92aWRlZCwgcHJvY2VzcyBlYWNoIGNvbnZlcnNhdGlvblxuICAgICAgaWYgKHNlYXJjaFRleHQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCJbUHJvamVjdFNlYXJjaFNlcnZpY2VdIFN0YXJ0aW5nIGNvbnZlcnNhdGlvbiBwcm9jZXNzaW5nLi4uXCJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgb3JnSWQgPSBnZXRPcmdhbml6YXRpb25JZCgpO1xuXG4gICAgICAgIGZvciAoY29uc3QgY29udiBvZiBjb252ZXJzYXRpb25zKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHNlYXJjaCB3YXMgYWJvcnRlZFxuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1Byb2plY3RTZWFyY2hTZXJ2aWNlXSBTZWFyY2ggYWJvcnRlZFwiKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldCB3b3JraW5nIHN0YXR1c1xuICAgICAgICAgICAgdGFibGUudXBkYXRlU2VhcmNoUmVzdWx0KGNvbnYudXVpZCwgdW5kZWZpbmVkLCBcIldvcmtpbmcuLi5cIik7XG5cbiAgICAgICAgICAgIC8vIEdldCBkZXRhaWxlZCBjb252ZXJzYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IGF3YWl0IENvbnZlcnNhdGlvblJldHJpZXZhbC5nZXRDb252ZXJzYXRpb24oXG4gICAgICAgICAgICAgIG9yZ0lkLFxuICAgICAgICAgICAgICBjb252LnV1aWQsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGFnYWluIGZvciBhYm9ydCBhZnRlciBjb252ZXJzYXRpb24gcmV0cmlldmFsXG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgXCJbUHJvamVjdFNlYXJjaFNlcnZpY2VdIFNlYXJjaCBhYm9ydGVkIGFmdGVyIGNvbnZlcnNhdGlvbiByZXRyaWV2YWxcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJvY2VzcyBtZXNzYWdlc1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBjb252ZXJzYXRpb24uY2hhdF9tZXNzYWdlc1xuICAgICAgICAgICAgICAuZmlsdGVyKChtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5mb3JtYXRNZXNzYWdlQ29udGVudChtc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICBjb250ZW50LnRyaW0oKS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICBjb250ZW50Lmxlbmd0aCA8PSB0aGlzLk1BWF9NRVNTQUdFX0xFTkdUSFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5tYXAoKG1zZykgPT4gKHtcbiAgICAgICAgICAgICAgICBpZDogbXNnLnV1aWQsXG4gICAgICAgICAgICAgICAgc2VuZGVyOiBtc2cuc2VuZGVyLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuZm9ybWF0TWVzc2FnZUNvbnRlbnQobXNnKSxcbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgc2VhcmNoIHByb21wdCBmb3IgdGhpcyBjb252ZXJzYXRpb25cbiAgICAgICAgICAgIGNvbnN0IHByb21wdCA9IGBIZXJlIGlzIGEgY29udmVyc2F0aW9uLiBQbGVhc2UgZmluZCBpZiBpdCBjb250YWlucyBpbmZvcm1hdGlvbiBzYXRpc2Z5aW5nIHRoaXMgc2VhcmNoIGNyaXRlcmlhIGFuZCBvdXRwdXQgYSBTZWFyY2hSZXN1bHRJbmZvIG9iamVjdDogXG4gICAgICAgICAgICA8Q3JpdGVyaWE+JHtzZWFyY2hUZXh0fTwvQ3JpdGVyaWE+XG5cbiR7SlNPTi5zdHJpbmdpZnkoXG4gIHtcbiAgICBpZDogY29udmVyc2F0aW9uLnV1aWQsXG4gICAgbmFtZTogY29udmVyc2F0aW9uLm5hbWUsXG4gICAgbWVzc2FnZXM6IG1lc3NhZ2VzLFxuICB9LFxuICBudWxsLFxuICAyXG4pfVxuXG5JZiB0aGUgY29udmVyc2F0aW9uIG1hdGNoZXMsIHJldHVybiBhIFNlYXJjaFJlc3VsdEluZm8gb2JqZWN0IHdpdGggdGhpcyBUeXBlU2NyaXB0IHR5cGU6XG5pbnRlcmZhY2UgU2VhcmNoUmVzdWx0SW5mbyB7XG4gIGNvbnZlcnNhdGlvbklkOiBzdHJpbmc7ICAgICAvLyBJRCBvZiB0aGUgbWF0Y2hpbmcgY29udmVyc2F0aW9uXG4gIG1lc3NhZ2VJZDogc3RyaW5nOyAgICAgICAgICAvLyBVVUlEIG9mIHRoZSBzcGVjaWZpYyBtZXNzYWdlIHRoYXQgbWF0Y2hlc1xuICBtYXRjaFJlYXNvbjogc3RyaW5nOyAgICAgICAgLy8gQ2xlYXIgZXhwbGFuYXRpb24gb2Ygd2h5IHRoaXMgY29udmVyc2F0aW9uIG1hdGNoZXNcbiAgcmVsZXZhbnRTbmlwcGV0OiBzdHJpbmc7ICAgIC8vIFRoZSBzcGVjaWZpYyB0ZXh0IHNuaXBwZXQgdGhhdCBtYXRjaGVzIChtYXggMjAwIGNoYXJzKVxufVxuXG5JZiB0aGUgY29udmVyc2F0aW9uIGRvZXMgbm90IG1hdGNoLCByZXR1cm4gbnVsbC4gUmV0dXJuIE9OTFkgdGhlIEpTT04gb2JqZWN0IG9yIG51bGwsIHdpdGggbm8gYWRkaXRpb25hbCB0ZXh0IG9yIGV4cGxhbmF0aW9uLmA7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBhYm9ydCBiZWZvcmUgbWFraW5nIGNvbXBsZXRpb24gcmVxdWVzdFxuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIFwiW1Byb2plY3RTZWFyY2hTZXJ2aWNlXSBTZWFyY2ggYWJvcnRlZCBiZWZvcmUgY29tcGxldGlvbiByZXF1ZXN0XCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIE1ha2UgcmVxdWVzdCBhbmQgcHJvY2VzcyByZXNwb25zZVxuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCB0aGlzLm1ha2VDb21wbGV0aW9uUmVxdWVzdChcbiAgICAgICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICAgICAgc2lnbmFsXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgLy8gSWYgcmVxdWVzdCB3YXMgY2FuY2VsbGVkXG4gICAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgICAgXCJbUHJvamVjdFNlYXJjaFNlcnZpY2VdIFNlYXJjaCBhYm9ydGVkIGR1cmluZyBjb21wbGV0aW9uIHJlcXVlc3RcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGluZykge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhYmxlLnVwZGF0ZVNlYXJjaFJlc3VsdChcbiAgICAgICAgICAgICAgICAgIGNvbnYudXVpZCxcbiAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIFwiRmFpbGVkIHRvIGdldCByZXNwb25zZSBmcm9tIEFQSVwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIGBbUHJvamVjdFNlYXJjaFNlcnZpY2VdIFByb2Nlc3NpbmcgcmVzcG9uc2UgZm9yIGNvbnZlcnNhdGlvbiAke2NvbnYudXVpZH1gXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuY29udmVyc2F0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFZhbGlkIHJlc3VsdCBmb3VuZCwgdXBkYXRlIHRoZSB0YWJsZSBhbmQgc2VsZWN0IHRoZSByb3dcbiAgICAgICAgICAgICAgICAgIHRhYmxlLnVwZGF0ZVNlYXJjaFJlc3VsdChjb252LnV1aWQsIHJlc3VsdCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gTm8gbWF0Y2gsIGNsZWFyIGFueSBleGlzdGluZyByZXN1bHQgYW5kIGRvbid0IHNlbGVjdFxuICAgICAgICAgICAgICAgICAgdGFibGUudXBkYXRlU2VhcmNoUmVzdWx0KFxuICAgICAgICAgICAgICAgICAgICBjb252LnV1aWQsXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgXCJObyBtYXRjaCBmb3VuZFwiXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgRmFpbGVkIHRvIHBhcnNlIHNlYXJjaCByZXN1bHRzOiAke1xuICAgICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIlxuICAgICAgICAgICAgICAgIH1gO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICBgW1Byb2plY3RTZWFyY2hTZXJ2aWNlXSAke2Vycm9yTWVzc2FnZX0gZm9yIGNvbnZlcnNhdGlvbiAke2NvbnYudXVpZH1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0YWJsZS51cGRhdGVTZWFyY2hSZXN1bHQoY29udi51dWlkLCB1bmRlZmluZWQsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICAgICAgICAgICAgPyBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICA6IFwiRmFpbGVkIHRvIGdldCByZXNwb25zZSBmcm9tIEFQSVwiO1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIGBbUHJvamVjdFNlYXJjaFNlcnZpY2VdIEFQSSByZXF1ZXN0IGZhaWxlZCBmb3IgY29udmVyc2F0aW9uICR7Y29udi51dWlkfTpgLFxuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHRhYmxlLnVwZGF0ZVNlYXJjaFJlc3VsdChjb252LnV1aWQsIHVuZGVmaW5lZCwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBGYWlsZWQgdG8gcHJvY2VzcyBjb252ZXJzYXRpb246ICR7XG4gICAgICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJcbiAgICAgICAgICAgIH1gO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgYFtQcm9qZWN0U2VhcmNoU2VydmljZV0gJHtlcnJvck1lc3NhZ2V9IGZvciBjb252ZXJzYXRpb24gJHtjb252LnV1aWR9OmAsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGFibGUudXBkYXRlU2VhcmNoUmVzdWx0KGNvbnYudXVpZCwgdW5kZWZpbmVkLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgc2VhcmNoIHdhcyBjYW5jZWxsZWQsIHVwZGF0ZSBhbnkgcmVtYWluaW5nIHVucHJvY2Vzc2VkIHJvd3NcbiAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBjb252IG9mIGNvbnZlcnNhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghdGFibGUuaXNSb3dQcm9jZXNzZWQoY29udi51dWlkKSkge1xuICAgICAgICAgICAgICB0YWJsZS51cGRhdGVTZWFyY2hSZXN1bHQoXG4gICAgICAgICAgICAgICAgY29udi51dWlkLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcIlNlYXJjaCBjYW5jZWxsZWRcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1Byb2plY3RTZWFyY2hTZXJ2aWNlXSBTZWFyY2ggZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPVxuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiU2VhcmNoIGZhaWxlZFwiO1xuICAgICAgLy8gVXBkYXRlIGFsbCBjb252ZXJzYXRpb25zIHdpdGggZXJyb3Igc3RhdHVzXG4gICAgICBpZiAoY29udmVyc2F0aW9ucyAmJiB0YWJsZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnYgb2YgY29udmVyc2F0aW9ucykge1xuICAgICAgICAgIHRhYmxlLnVwZGF0ZVNlYXJjaFJlc3VsdChjb252LnV1aWQsIHVuZGVmaW5lZCwgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmN1cnJlbnRBYm9ydENvbnRyb2xsZXIgPSBudWxsO1xuICAgICAgdGhpcy5pc0NhbmNlbGxpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuY3VycmVudFRhYmxlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmlsdGVycyBhbmQgZm9ybWF0cyBtZXNzYWdlIGNvbnRlbnRcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIGZvcm1hdE1lc3NhZ2VDb250ZW50KG1lc3NhZ2U6IENoYXRNZXNzYWdlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbWVzc2FnZS5jb250ZW50XG4gICAgICAuZmlsdGVyKChjb250ZW50KSA9PiB7XG4gICAgICAgIC8vIE9ubHkgaW5jbHVkZSB0ZXh0IGNvbnRlbnQsIGV4Y2x1ZGUgdG9vbHMgYW5kIGFydGlmYWN0c1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGNvbnRlbnQudHlwZSA9PT0gXCJ0ZXh0XCIgJiZcbiAgICAgICAgICBjb250ZW50LnRleHQgJiZcbiAgICAgICAgICAhY29udGVudC50ZXh0LmluY2x1ZGVzKFwiYW50bWw6ZnVuY3Rpb25fY2FsbHNcIikgJiZcbiAgICAgICAgICAhY29udGVudC50ZXh0LmluY2x1ZGVzKFwiYW50QXJ0aWZhY3RcIilcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgICAubWFwKChjb250ZW50KSA9PiBjb250ZW50LnRleHQpXG4gICAgICAuam9pbihcIlxcblwiKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgPG1hcnRpbi5iZWNoYXJkQERldkNvbnN1bHQuY2E+XG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIEZpbGU6IC9Vc2Vycy9tYXJ0aW5iZWNoYXJkL2Rldi9jbGF1ZGVleHQvc3JjL3NlcnZpY2VzL1Byb21wdEFsbC50c1xuICogVGhpcyB3YXMgZ2VuZXJhdGVkIGJ5IENsYXVkZSBTb25uZXQgMy41LCB3aXRoIHRoZSBhc3Npc3RhbmNlIG9mIG15IGh1bWFuIG1lbnRvclxuICpcbiAqIFNlcnZpY2UgZm9yIHN1Ym1pdHRpbmcgcHJvbXB0cyB0byBtdWx0aXBsZSBjb252ZXJzYXRpb25zIHNlcXVlbnRpYWxseVxuICogTm90ZTogTGlrZSBhIHBhdGllbnQgdGVhY2hlciAtIGFza2luZyB0aGUgc2FtZSBxdWVzdGlvbiB0byBlYWNoIHN0dWRlbnQgb25lIGF0IGEgdGltZSFcbiAqL1xuXG5pbXBvcnQgeyBQcm9qZWN0UmV0cmlldmFsIH0gZnJvbSBcIi4vUHJvamVjdFJldHJpZXZhbFwiO1xuaW1wb3J0IHsgRG93bmxvYWRUYWJsZSB9IGZyb20gXCIuLi91aS9jb21wb25lbnRzL0Rvd25sb2FkVGFibGVcIjtcbmltcG9ydCB7IHJlcXVlc3RDb21wbGV0aW9uIH0gZnJvbSBcIi4uL3V0aWxzL3JlcXVlc3RDb21wbGV0aW9uXCI7XG5pbXBvcnQgeyBnZXRPcmdhbml6YXRpb25JZCB9IGZyb20gXCIuLi91dGlscy9nZXRDbGF1ZGVJZHNcIjtcbmltcG9ydCB0eXBlIHsgRG9jdW1lbnRJbmZvLCBQcm9qZWN0Q29udmVyc2F0aW9uIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbi8qKlxuICogQWRkaXRpb25hbCByZXN1bHQgaW5mb3JtYXRpb24gZm9yIHByb21wdCByZXNwb25zZXNcbiAqL1xuaW50ZXJmYWNlIFByb21wdFJlc3VsdEluZm8ge1xuICBjb252ZXJzYXRpb25JZDogc3RyaW5nO1xuICBwcm9tcHQ6IHN0cmluZztcbiAgcmVzcG9uc2U6IHN0cmluZztcbiAgZXJyb3I/OiBzdHJpbmc7XG4gIHN0YXR1cz86IHN0cmluZztcbn1cblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBtYW5hZ2luZyBwcm9tcHRzIGFjcm9zcyBtdWx0aXBsZSBjb252ZXJzYXRpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9tcHRBbGwge1xuICAvKipcbiAgICogU3VibWl0cyBhIHByb21wdCB0byBhIHNwZWNpZmljIGNvbnZlcnNhdGlvblxuICAgKiBAcGFyYW0gY29udmVyc2F0aW9uSWQgLSBJRCBvZiBjb252ZXJzYXRpb24gdG8gcXVlcnlcbiAgICogQHBhcmFtIHByb21wdCAtIFByb21wdCB0byBzdWJtaXRcbiAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gY29tcGxldGlvbiByZXNwb25zZVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgc3VibWl0UHJvbXB0KFxuICAgIGNvbnZlcnNhdGlvbklkOiBzdHJpbmcsXG4gICAgcHJvbXB0OiBzdHJpbmdcbiAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXF1ZXN0Q29tcGxldGlvbih7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgY29udmVyc2F0aW9uSWQsXG4gICAgICAgIHJlbmRlcmluZ01vZGU6IFwianNvblwiLFxuICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwb25zZS5jb21wbGV0aW9uO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gc3VibWl0IHByb21wdCB0byBjb252ZXJzYXRpb24gJHtjb252ZXJzYXRpb25JZH06ICR7XG4gICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIlxuICAgICAgICB9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBkb2N1bWVudCBpbmZvIG9iamVjdHMgZm9yIGRpc3BsYXlcbiAgICogQHBhcmFtIGNvbnZlcnNhdGlvbnMgLSBPcmlnaW5hbCBjb252ZXJzYXRpb25zXG4gICAqIEBwYXJhbSByZXN1bHRzIC0gUHJvbXB0IHJlc3VsdHNcbiAgICogQHJldHVybnMgQXJyYXkgb2YgZG9jdW1lbnQgaW5mbyBvYmplY3RzXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBjcmVhdGVEb2N1bWVudEluZm8oXG4gICAgY29udmVyc2F0aW9uczogUHJvamVjdENvbnZlcnNhdGlvbltdLFxuICAgIHJlc3VsdHM6IFByb21wdFJlc3VsdEluZm9bXVxuICApOiBEb2N1bWVudEluZm9bXSB7XG4gICAgLy8gQ3JlYXRlIGEgbWFwIGZvciBxdWljayByZXN1bHQgbG9va3VwXG4gICAgY29uc3QgcmVzdWx0TWFwID0gbmV3IE1hcChcbiAgICAgIHJlc3VsdHMubWFwKChyZXN1bHQpID0+IFtyZXN1bHQuY29udmVyc2F0aW9uSWQsIHJlc3VsdF0pXG4gICAgKTtcblxuICAgIHJldHVybiBjb252ZXJzYXRpb25zLm1hcCgoY29udikgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0TWFwLmdldChjb252LnV1aWQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZU5hbWU6IGNvbnYubmFtZSxcbiAgICAgICAgZmlsZVBhdGg6IGAke2NvbnYubmFtZS5yZXBsYWNlKC9cXHMrL2csIFwiLVwiKX0ubWRgLFxuICAgICAgICBjb250ZW50OiBjb252LnN1bW1hcnkgfHwgXCJcIixcbiAgICAgICAgaXNTZWxlY3RlZDogZmFsc2UsXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgY29udmVyc2F0aW9uSWQ6IGNvbnYudXVpZCxcbiAgICAgICAgICB1cmw6IGBodHRwczovL2NsYXVkZS5haS9jaGF0LyR7Y29udi51dWlkfWAsXG4gICAgICAgIH0sXG4gICAgICAgIHNlYXJjaFJlc3VsdDogcmVzdWx0XG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICAgIGNvbnZlcnNhdGlvbklkOiBjb252LnV1aWQsXG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogXCJcIiwgLy8gTm8gc3BlY2lmaWMgbWVzc2FnZSBJRCBmb3IgcHJvbXB0IHJlc3BvbnNlc1xuICAgICAgICAgICAgICBtYXRjaFJlYXNvbjpcbiAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3IgfHwgcmVzdWx0LnN0YXR1cyB8fCBcIlByb21wdCByZXNwb25zZSByZWNlaXZlZFwiLFxuICAgICAgICAgICAgICByZWxldmFudFNuaXBwZXQ6IHJlc3VsdC5yZXNwb25zZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgY29udmVyc2F0aW9uSWQ6IGNvbnYudXVpZCxcbiAgICAgICAgICAgICAgbWVzc2FnZUlkOiBcIlwiLFxuICAgICAgICAgICAgICBtYXRjaFJlYXNvbjogXCJQZW5kaW5nLi4uXCIsXG4gICAgICAgICAgICAgIHJlbGV2YW50U25pcHBldDogXCJXYWl0aW5nIHRvIHByb2Nlc3MgdGhpcyBjb252ZXJzYXRpb25cIixcbiAgICAgICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXJpZXMgYWxsIGNvbnZlcnNhdGlvbnMgd2l0aCBhIHByb21wdCBhbmQgZGlzcGxheXMgcmVzdWx0cyBwcm9ncmVzc2l2ZWx5XG4gICAqIEBwYXJhbSBwcm9tcHQgLSBQcm9tcHQgdG8gc3VibWl0IHRvIGFsbCBjb252ZXJzYXRpb25zXG4gICAqIEBwYXJhbSBvdXRwdXRFbGVtZW50IC0gRWxlbWVudCB0byBkaXNwbGF5IHJlc3VsdHMgaW5cbiAgICogQHBhcmFtIHN0YXR1c0NhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgZm9yIHN0YXR1cyB1cGRhdGVzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIHF1ZXJ5QW5kRGlzcGxheVJlc3VsdHMoXG4gICAgcHJvbXB0OiBzdHJpbmcsXG4gICAgb3V0cHV0RWxlbWVudDogSFRNTEVsZW1lbnQsXG4gICAgc3RhdHVzQ2FsbGJhY2s/OiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZldGNoaW5nIHByb2plY3QgY29udmVyc2F0aW9ucy4uLlwiKTtcbiAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbnMgPSBhd2FpdCBQcm9qZWN0UmV0cmlldmFsLmdldFByb2plY3RDb252ZXJzYXRpb25zKFxuICAgICAgICB0cnVlXG4gICAgICApO1xuXG4gICAgICBpZiAoY29udmVyc2F0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY29udmVyc2F0aW9ucyBmb3VuZCBpbiBwcm9qZWN0XCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0aWFsaXplIHJlc3VsdHMgYXJyYXlcbiAgICAgIGNvbnN0IGFsbFJlc3VsdHM6IFByb21wdFJlc3VsdEluZm9bXSA9IGNvbnZlcnNhdGlvbnMubWFwKChjb252KSA9PiAoe1xuICAgICAgICBjb252ZXJzYXRpb25JZDogY29udi51dWlkLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIHJlc3BvbnNlOiBcIlwiLFxuICAgICAgICBzdGF0dXM6IFwiUGVuZGluZ1wiLFxuICAgICAgfSkpO1xuXG4gICAgICAvLyBJbml0aWFsaXplIHRhYmxlIHdpdGggcGVuZGluZyBzdGF0dXMgZm9yIGFsbCBjb252ZXJzYXRpb25zXG4gICAgICBjb25zdCBkb2NzID0gdGhpcy5jcmVhdGVEb2N1bWVudEluZm8oY29udmVyc2F0aW9ucywgYWxsUmVzdWx0cyk7XG4gICAgICBjb25zdCB0YWJsZSA9IG5ldyBEb3dubG9hZFRhYmxlKG91dHB1dEVsZW1lbnQsIGRvY3MsIHRydWUpO1xuICAgICAgdGFibGUucmVuZGVyKCk7XG5cbiAgICAgIC8vIFByb2Nlc3MgZWFjaCBjb252ZXJzYXRpb24gc2VxdWVudGlhbGx5XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnZlcnNhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29udiA9IGNvbnZlcnNhdGlvbnNbaV07XG4gICAgICAgIGNvbnN0IHByb2dyZXNzTXNnID0gYFByb2Nlc3NpbmcgY29udmVyc2F0aW9uICR7aSArIDF9LyR7XG4gICAgICAgICAgY29udmVyc2F0aW9ucy5sZW5ndGhcbiAgICAgICAgfTogJHtjb252Lm5hbWV9YDtcblxuICAgICAgICBpZiAoc3RhdHVzQ2FsbGJhY2spIHtcbiAgICAgICAgICBzdGF0dXNDYWxsYmFjayhwcm9ncmVzc01zZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cocHJvZ3Jlc3NNc2cpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnN1Ym1pdFByb21wdChjb252LnV1aWQsIHByb21wdCk7XG4gICAgICAgICAgYWxsUmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbklkOiBjb252LnV1aWQsXG4gICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHN0YXR1czogXCJDb21wbGV0ZWRcIixcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGFsbFJlc3VsdHNbaV0gPSB7XG4gICAgICAgICAgICBjb252ZXJzYXRpb25JZDogY29udi51dWlkLFxuICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgcmVzcG9uc2U6IFwiXCIsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIixcbiAgICAgICAgICAgIHN0YXR1czogXCJFcnJvclwiLFxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBjb252ZXJzYXRpb24gJHtjb252LnV1aWR9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBVSSBhZnRlciBlYWNoIGNvbnZlcnNhdGlvblxuICAgICAgICBjb25zdCB1cGRhdGVkRG9jcyA9IHRoaXMuY3JlYXRlRG9jdW1lbnRJbmZvKGNvbnZlcnNhdGlvbnMsIGFsbFJlc3VsdHMpO1xuICAgICAgICB0YWJsZS51cGRhdGVJdGVtcyh1cGRhdGVkRG9jcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0dXNDYWxsYmFjaykge1xuICAgICAgICBzdGF0dXNDYWxsYmFjayhcIkFsbCBjb252ZXJzYXRpb25zIHByb2Nlc3NlZFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgUXVlcnkgZmFpbGVkOiAke1xuICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogL1VzZXJzL21hcnRpbmJlY2hhcmQvZGV2L2NsYXVkZWV4dC9zcmMvc2VydmljZXMvU2NyaXB0RXhlY3V0aW9uTWFuYWdlci50c1xuICogVGhpcyB3YXMgZ2VuZXJhdGVkIGJ5IENsYXVkZSBTb25uZXQgMy41LCB3aXRoIHRoZSBhc3Npc3RhbmNlIG9mIG15IGh1bWFuIG1lbnRvclxuICpcbiAqIE1hbmFnZXMgc2NyaXB0IGV4ZWN1dGlvbiBhbmQgc3RhdGVcbiAqIE5vdGU6IEtlZXBpbmcgeW91ciBzY3JpcHRzIHJ1bm5pbmcgc21vb3RobHkgc2luY2UgMjAyNCFcbiAqL1xuXG5pbXBvcnQgeyBTY3JpcHRQYXJzZXIgfSBmcm9tIFwiLi4vdXRpbHMvU2NyaXB0UGFyc2VyXCI7XG5pbXBvcnQgeyBTY3JpcHRSdW5uZXIgfSBmcm9tIFwiLi9TY3JpcHRSdW5uZXJcIjtcbmltcG9ydCB7IENvbW1hbmRFeGVjdXRvciB9IGZyb20gXCIuL0NvbW1hbmRFeGVjdXRvclwiO1xuaW1wb3J0IHsgQ2xhdWRlQ2FjaGUgfSBmcm9tIFwiLi9DbGF1ZGVDYWNoZVwiO1xuaW1wb3J0IHR5cGUgeyBTY3JpcHQsIFNjcmlwdFN0YXRlbWVudCB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHR5cGUgeyBTdGF0dXNNYW5hZ2VyIH0gZnJvbSBcIi4uL3VpL2NvbXBvbmVudHMvU3RhdHVzTWFuYWdlclwiO1xuXG50eXBlIExvZ0Z1bmN0aW9uID0gKFxuICBtZXNzYWdlOiBzdHJpbmcsXG4gIHR5cGU/OiBcImluZm9cIiB8IFwiZXJyb3JcIiB8IFwic3VjY2Vzc1wiXG4pID0+IHZvaWQ7XG5cbmV4cG9ydCBjbGFzcyBTY3JpcHRFeGVjdXRpb25NYW5hZ2VyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBzY3JpcHRSdW5uZXI6IFNjcmlwdFJ1bm5lcjtcblxuICBwcml2YXRlIHJlYWRvbmx5IHN0YXR1c01hbmFnZXI6IFN0YXR1c01hbmFnZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgaGFuZGxlTG9nOiBMb2dGdW5jdGlvbjtcbiAgcHJpdmF0ZSBpc0V4ZWN1dGluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHN0YXR1c01hbmFnZXI6IFN0YXR1c01hbmFnZXIsXG4gICAgaGFuZGxlTG9nOiBMb2dGdW5jdGlvbixcbiAgICBvdXRwdXRFbGVtZW50OiBIVE1MRWxlbWVudFxuICApIHtcbiAgICB0aGlzLnN0YXR1c01hbmFnZXIgPSBzdGF0dXNNYW5hZ2VyO1xuICAgIHRoaXMuaGFuZGxlTG9nID0gaGFuZGxlTG9nO1xuICAgIHRoaXMuc2NyaXB0UnVubmVyID0gbmV3IFNjcmlwdFJ1bm5lcihcbiAgICAgIGhhbmRsZUxvZyxcbiAgICAgIG5ldyBDb21tYW5kRXhlY3V0b3Ioc3RhdHVzTWFuYWdlciwgaGFuZGxlTG9nLCBvdXRwdXRFbGVtZW50KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBzY3JpcHQgZnJvbSByYXcgdGV4dCBpbnB1dFxuICAgKiBAcGFyYW0gc2NyaXB0VGV4dCAtIFJhdyBzY3JpcHQgdGV4dCB0byBleGVjdXRlXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgc2NyaXB0IGV4ZWN1dGlvbiBmYWlsc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGV4ZWN1dGVTY3JpcHQoc2NyaXB0VGV4dDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNFeGVjdXRpbmcpIHtcbiAgICAgIHRoaXMuaGFuZGxlTG9nKFwiQ2FuY2VsbGluZyBjdXJyZW50IGV4ZWN1dGlvbi4uLlwiLCBcImluZm9cIik7XG4gICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHQgPSBzY3JpcHRUZXh0LnRyaW0oKTtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHRoaXMuaGFuZGxlTG9nKFwiUGxlYXNlIGVudGVyIGEgc2NyaXB0XCIsIFwiZXJyb3JcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaXNFeGVjdXRpbmcgPSB0cnVlO1xuXG4gICAgICAvLyBDbGVhciBjYWNoZSBhdCBzdGFydCBvZiBhbnkgbmV3IGV4ZWN1dGlvblxuICAgICAgQ2xhdWRlQ2FjaGUuY2xlYXJDYWNoZSgpO1xuICAgICAgdGhpcy5oYW5kbGVMb2coXCJDYWNoZSBjbGVhcmVkXCIsIFwiaW5mb1wiKTtcblxuICAgICAgY29uc3Qgc2NyaXB0ID0gU2NyaXB0UGFyc2VyLnBhcnNlKHRleHQpO1xuICAgICAgYXdhaXQgdGhpcy5zdGF0dXNNYW5hZ2VyLnNldFN0YXR1cyhcIndvcmtpbmdcIiwgXCJSdW5uaW5nIHNjcmlwdC4uLlwiKTtcblxuICAgICAgYXdhaXQgdGhpcy5zY3JpcHRSdW5uZXIucnVuU2NyaXB0KHNjcmlwdCk7XG5cbiAgICAgIGF3YWl0IHRoaXMuc3RhdHVzTWFuYWdlci5zZXRTdGF0dXMoXCJyZWFkeVwiLCBcIkNvbXBsZXRlXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIjtcbiAgICAgIHRoaXMuaGFuZGxlTG9nKGBTY3JpcHQgZXJyb3I6ICR7bWVzc2FnZX1gLCBcImVycm9yXCIpO1xuICAgICAgYXdhaXQgdGhpcy5zdGF0dXNNYW5hZ2VyLnNldFN0YXR1cyhcImVycm9yXCIsIG1lc3NhZ2UpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnN0YXR1c01hbmFnZXIuc2V0U3RhdHVzKFwicmVhZHlcIiksIDIwMDApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzRXhlY3V0aW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgdGhlIGN1cnJlbnQgc2NyaXB0IGV4ZWN1dGlvblxuICAgKi9cbiAgcHVibGljIGNhbmNlbCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pc0V4ZWN1dGluZykge1xuICAgICAgdGhpcy5zY3JpcHRSdW5uZXIuY2FuY2VsKCk7XG4gICAgICB0aGlzLmlzRXhlY3V0aW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIHNjcmlwdCBpcyBjdXJyZW50bHkgZXhlY3V0aW5nXG4gICAqIEByZXR1cm5zIFRydWUgaWYgc2NyaXB0IGlzIGV4ZWN1dGluZ1xuICAgKi9cbiAgcHVibGljIGlzU2NyaXB0RXhlY3V0aW5nKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzRXhlY3V0aW5nO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogL1VzZXJzL21hcnRpbmJlY2hhcmQvZGV2L2NsYXVkZWV4dC9zcmMvc2VydmljZXMvU2NyaXB0UnVubmVyLnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBTY3JpcHQsIFNjcmlwdFN0YXRlbWVudCwgU3RvcENvbmRpdGlvbiB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgQ29tbWFuZEV4ZWN1dG9yIH0gZnJvbSBcIi4vQ29tbWFuZEV4ZWN1dG9yXCI7XG5cbi8qKlxuICogQ2FsbGJhY2sgdHlwZSBmb3IgbG9nZ2luZyBvdXRwdXQgZnJvbSB0aGUgc2NyaXB0IHJ1bm5lci5cbiAqL1xudHlwZSBMb2dDYWxsYmFjayA9IChcbiAgbWVzc2FnZTogc3RyaW5nLFxuICB0eXBlPzogXCJpbmZvXCIgfCBcImVycm9yXCIgfCBcInN1Y2Nlc3NcIlxuKSA9PiB2b2lkO1xuXG4vKipcbiAqIE1hbmFnZXMgc2NyaXB0IGV4ZWN1dGlvbiBhbmQgc3RyZWFtaW5nIHN0YXRlLlxuICovXG5leHBvcnQgY2xhc3MgU2NyaXB0UnVubmVyIHtcbiAgcHJpdmF0ZSBpc1J1bm5pbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSByZWFkb25seSBsb2dDYWxsYmFjazogTG9nQ2FsbGJhY2s7XG4gIHByaXZhdGUgcmVhZG9ubHkgTUFYX0FUVEVNUFRTX1dBSVRfUkVTUE9OU0U6IG51bWJlciA9IDMwMDtcbiAgcHJpdmF0ZSByZWFkb25seSBDSEVDS19JTlRFUlZBTDogbnVtYmVyID0gMTAwO1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbW1hbmRFeGVjdXRvcjogQ29tbWFuZEV4ZWN1dG9yO1xuXG4gIGNvbnN0cnVjdG9yKGxvZ0NhbGxiYWNrOiBMb2dDYWxsYmFjaywgY29tbWFuZEV4ZWN1dG9yOiBDb21tYW5kRXhlY3V0b3IpIHtcbiAgICB0aGlzLmxvZ0NhbGxiYWNrID0gbG9nQ2FsbGJhY2s7XG4gICAgdGhpcy5jb21tYW5kRXhlY3V0b3IgPSBjb21tYW5kRXhlY3V0b3I7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBjb21tYW5kIHNjcmlwdFxuICAgKiBAcGFyYW0gc2NyaXB0IC0gUGFyc2VkIGNvbW1hbmQgc2NyaXB0IHRvIGV4ZWN1dGVcbiAgICogQHRocm93cyBFcnJvciBpZiBjb21tYW5kIGV4ZWN1dGlvbiBmYWlsc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBleGVjdXRlQ29tbWFuZChzY3JpcHQ6IFNjcmlwdFN0YXRlbWVudCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIEhhbmRsZSBhbGlhcyBjb21tYW5kcyBmaXJzdFxuICAgIGlmIChzY3JpcHQuYWxpYXNDb21tYW5kKSB7XG4gICAgICBhd2FpdCB0aGlzLmNvbW1hbmRFeGVjdXRvci5oYW5kbGVBbGlhc0NvbW1hbmQoc2NyaXB0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgb3RoZXIgY29tbWFuZHNcbiAgICBpZiAoIXNjcmlwdC5jb21tYW5kKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjb21tYW5kIHNwZWNpZmllZFwiKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHNjcmlwdC5jb21tYW5kKSB7XG4gICAgICBjYXNlIFwiZG9jc1wiOlxuICAgICAgICBhd2FpdCB0aGlzLmNvbW1hbmRFeGVjdXRvci5oYW5kbGVEb2NzQ29tbWFuZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwcm9qZWN0XCI6XG4gICAgICAgIGF3YWl0IHRoaXMuY29tbWFuZEV4ZWN1dG9yLmhhbmRsZVByb2plY3RDb21tYW5kKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNlYXJjaF9wcm9qZWN0XCI6XG4gICAgICAgIGF3YWl0IHRoaXMuY29tbWFuZEV4ZWN1dG9yLmhhbmRsZVNlYXJjaFByb2plY3RDb21tYW5kKHNjcmlwdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInF1ZXJ5X3Byb2plY3RcIjpcbiAgICAgICAgYXdhaXQgdGhpcy5jb21tYW5kRXhlY3V0b3IuaGFuZGxlUXVlcnlQcm9qZWN0Q29tbWFuZChzY3JpcHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjb252ZXJzYXRpb25cIjpcbiAgICAgIGNhc2UgXCJhcnRpZmFjdHNcIjpcbiAgICAgICAgYXdhaXQgdGhpcy5jb21tYW5kRXhlY3V0b3IuaGFuZGxlQ29udmVyc2F0aW9uQ29tbWFuZChcbiAgICAgICAgICBzY3JpcHQub3B0aW9ucyB8fCB7fVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjb21tYW5kOiAke3NjcmlwdC5jb21tYW5kfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHNjcmlwdCB3aXRoIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0gc2NyaXB0IC0gU2NyaXB0IGNvbmZpZ3VyYXRpb24gdG8gZXhlY3V0ZVxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHNjcmlwdCBleGVjdXRpb24gZmFpbHNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBydW5TY3JpcHQoc2NyaXB0OiBTY3JpcHQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjcmlwdCBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgICAgLy8gRXhlY3V0ZSBlYWNoIHN0YXRlbWVudCBpbiBzZXF1ZW5jZVxuICAgICAgbGV0IHNob3VsZENvbnRpbnVlID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3Qgc3RhdGVtZW50IG9mIHNjcmlwdC5zdGF0ZW1lbnRzKSB7XG4gICAgICAgIGlmICghc2hvdWxkQ29udGludWUgfHwgIXRoaXMuaXNSdW5uaW5nKSBicmVhaztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzdGF0ZW1lbnQuaXNDb21tYW5kKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmV4ZWN1dGVDb21tYW5kKHN0YXRlbWVudCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXN0YXRlbWVudC5wcm9tcHQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlUHJvbXB0KHN0YXRlbWVudC5wcm9tcHQpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgYWxsIHN0b3AgY29uZGl0aW9uc1xuICAgICAgICAgIGlmIChzdGF0ZW1lbnQub3B0aW9ucz8uc3RvcENvbmRpdGlvbnM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcFJlYXNvbiA9IHRoaXMuY2hlY2tTdG9wQ29uZGl0aW9ucyhcbiAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgIHN0YXRlbWVudC5vcHRpb25zPy5zdG9wQ29uZGl0aW9uc1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHN0b3BSZWFzb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2dDYWxsYmFjayhgU3RvcCBjb25kaXRpb24gbWV0OiAke3N0b3BSZWFzb259YCwgXCJpbmZvXCIpO1xuICAgICAgICAgICAgICBzaG91bGRDb250aW51ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhpcy5sb2dDYWxsYmFjayhcbiAgICAgICAgICAgIGBTdGF0ZW1lbnQgZXhlY3V0aW9uIGZhaWxlZDogJHtcbiAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIlxuICAgICAgICAgICAgfWAsXG4gICAgICAgICAgICBcImVycm9yXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBhbGwgc3RhdGVtZW50cyBleGVjdXRlZCBhbmQgbm8gc3RvcCBjb25kaXRpb25zIG1ldCwgd2UncmUgZG9uZVxuICAgICAgaWYgKHNob3VsZENvbnRpbnVlKSB7XG4gICAgICAgIHRoaXMubG9nQ2FsbGJhY2soXCJTY3JpcHQgY29tcGxldGVkIHN1Y2Nlc3NmdWxseVwiLCBcInN1Y2Nlc3NcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5sb2dDYWxsYmFjayhcbiAgICAgICAgYFNjcmlwdCBleGVjdXRpb24gZmFpbGVkOiAke1xuICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCJcbiAgICAgICAgfWAsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgICAgKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHNpbmdsZSBzdGF0ZW1lbnQgYW5kIHdhaXRzIGZvciByZXNwb25zZVxuICAgKiBAcGFyYW0gcHJvbXB0IC0gUHJvbXB0IHRleHQgdG8gZXhlY3V0ZVxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgdGV4dFxuICAgKiBAdGhyb3dzIEVycm9yIGlmIGV4ZWN1dGlvbiBmYWlsc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBleGVjdXRlUHJvbXB0KHByb21wdDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCB0YXJnZXREaXYgPSBhd2FpdCB0aGlzLmZpbmRJbnB1dEVsZW1lbnQoKTtcbiAgICBhd2FpdCB0aGlzLmluc2VydFByb21wdChwcm9tcHQpO1xuICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVFbnRlcktleSh0YXJnZXREaXYpO1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNoZWNrU3RyZWFtaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHN0b3AgY29uZGl0aW9ucyBhZ2FpbnN0IGEgcmVzcG9uc2VcbiAgICogQHBhcmFtIHJlc3BvbnNlIC0gUmVzcG9uc2UgdGV4dCB0byBjaGVja1xuICAgKiBAcGFyYW0gc3RvcENvbmRpdGlvbnMgLSBBcnJheSBvZiBjb25kaXRpb25zIHRvIGNoZWNrXG4gICAqIEByZXR1cm5zIFRoZSBtYXRjaGluZyBjb25kaXRpb24gb3IgbnVsbCBpZiBub25lIG1hdGNoXG4gICAqL1xuICBwcml2YXRlIGNoZWNrU3RvcENvbmRpdGlvbnMoXG4gICAgcmVzcG9uc2U6IHN0cmluZyxcbiAgICBzdG9wQ29uZGl0aW9uczogU3RvcENvbmRpdGlvbltdXG4gICk6IHN0cmluZyB8IG51bGwge1xuICAgIGZvciAoY29uc3QgY29uZGl0aW9uIG9mIHN0b3BDb25kaXRpb25zKSB7XG4gICAgICBjb25zdCBjb250YWluZWQgPSByZXNwb25zZS5pbmNsdWRlcyhjb25kaXRpb24udGFyZ2V0KTtcbiAgICAgIGlmIChcbiAgICAgICAgKGNvbmRpdGlvbi50eXBlID09PSBcImlmXCIgJiYgY29udGFpbmVkKSB8fFxuICAgICAgICAoY29uZGl0aW9uLnR5cGUgPT09IFwiaWZfbm90XCIgJiYgIWNvbnRhaW5lZClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gYCR7Y29uZGl0aW9uLnR5cGV9ICR7Y29uZGl0aW9uLnRhcmdldH1gO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb25pdG9ycyB0aGUgc3RyZWFtaW5nIHN0YXRlIG9mIENsYXVkZSdzIHJlc3BvbnNlLlxuICAgKiBAcmV0dXJucyBUaGUgZmluYWwgcmVzcG9uc2UgdGV4dFxuICAgKiBAdGhyb3dzIEVycm9yIGlmIG1vbml0b3JpbmcgdGltZXMgb3V0XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNoZWNrU3RyZWFtaW5nKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgbGV0IHN0YWJsZUNvdW50ID0gMDtcbiAgICBsZXQgYXR0ZW1wdHMgPSAwO1xuICAgIGxldCBsYXN0Q29udGVudCA9IFwiXCI7XG4gICAgbGV0IGxhc3RTdHJlYW1pbmdEaXY6IEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuICAgIHdoaWxlIChhdHRlbXB0cyA8IHRoaXMuTUFYX0FUVEVNUFRTX1dBSVRfUkVTUE9OU0UgJiYgdGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIGNvbnN0IHN0cmVhbWluZ0RpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICdkaXZbZGF0YS1pcy1zdHJlYW1pbmc9XCJ0cnVlXCJdJ1xuICAgICAgKTtcblxuICAgICAgaWYgKHN0cmVhbWluZ0Rpdikge1xuICAgICAgICBpZiAoc3RyZWFtaW5nRGl2LnRleHRDb250ZW50ICE9PSBsYXN0Q29udGVudCkge1xuICAgICAgICAgIHN0YWJsZUNvdW50ID0gMDtcbiAgICAgICAgICBsYXN0Q29udGVudCA9IHN0cmVhbWluZ0Rpdi50ZXh0Q29udGVudCB8fCBcIlwiO1xuICAgICAgICAgIGxhc3RTdHJlYW1pbmdEaXYgPSBzdHJlYW1pbmdEaXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhYmxlQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsYXN0U3RyZWFtaW5nRGl2KSB7XG4gICAgICAgIHJldHVybiBsYXN0U3RyZWFtaW5nRGl2LnRleHRDb250ZW50IHx8IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFibGVDb3VudCsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhYmxlQ291bnQgPj0gMjApIHtcbiAgICAgICAgcmV0dXJuIGxhc3RDb250ZW50O1xuICAgICAgfVxuXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aGlzLkNIRUNLX0lOVEVSVkFMKSk7XG4gICAgICBhdHRlbXB0cysrO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wZXJhdGlvbiBjYW5jZWxsZWRcIik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIHRpbWVvdXRcIik7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgdGhlIGlucHV0IGVsZW1lbnQgZm9yIHNjcmlwdCBleGVjdXRpb24uXG4gICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBpbnB1dCBlbGVtZW50XG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgZWxlbWVudCBub3QgZm91bmRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZmluZElucHV0RWxlbWVudCgpOiBQcm9taXNlPEVsZW1lbnQ+IHtcbiAgICBjb25zdCB0YXJnZXREaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdkaXZbZW50ZXJrZXloaW50PVwiZW50ZXJcIl0nKTtcbiAgICBpZiAoIXRhcmdldERpdikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZWxlbWVudCBub3QgZm91bmRcIik7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXREaXY7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBvciB1cGRhdGVzIHByb21wdCB0ZXh0IGluIHRoZSBpbnB1dCBlbGVtZW50XG4gICAqIEBwYXJhbSB0ZXh0IC0gVGV4dCB0byBpbnNlcnRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaW5zZXJ0UHJvbXB0KHRleHQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHRhcmdldERpdiA9IGF3YWl0IHRoaXMuZmluZElucHV0RWxlbWVudCgpO1xuICAgIGNvbnN0IHBhcmFncmFwaHMgPSB0YXJnZXREaXYucXVlcnlTZWxlY3RvckFsbChcInBcIik7XG5cbiAgICBpZiAoXG4gICAgICBwYXJhZ3JhcGhzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgcGFyYWdyYXBoc1swXS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXBsYWNlaG9sZGVyXCIpXG4gICAgKSB7XG4gICAgICAvLyBFbXB0eSBzdGF0ZSAtIHJlcGxhY2UgY29udGVudFxuICAgICAgcGFyYWdyYXBoc1swXS5pbm5lckhUTUwgPSB0ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBIYXMgY29udGVudCAtIGFwcGVuZCBuZXcgcGFyYWdyYXBoXG4gICAgICBjb25zdCBuZXdQID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICBuZXdQLmlubmVySFRNTCA9IHRleHQ7XG4gICAgICB0YXJnZXREaXYuYXBwZW5kQ2hpbGQobmV3UCk7XG4gICAgfVxuXG4gICAgKHRhcmdldERpdiBhcyBIVE1MRWxlbWVudCkuZm9jdXMoKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgcHJlc3NpbmcgdGhlIEVudGVyIGtleS5cbiAgICogQHBhcmFtIGVsZW1lbnQgLSBFbGVtZW50IHRvIHJlY2VpdmUgdGhlIGtleSBldmVudFxuICAgKi9cbiAgcHJpdmF0ZSBzaW11bGF0ZUVudGVyS2V5KGVsZW1lbnQ6IEVsZW1lbnQpOiB2b2lkIHtcbiAgICBjb25zdCBldmVudHMgPSBbXG4gICAgICBuZXcgS2V5Ym9hcmRFdmVudChcImtleWRvd25cIiwge1xuICAgICAgICBrZXk6IFwiRW50ZXJcIixcbiAgICAgICAgY29kZTogXCJFbnRlclwiLFxuICAgICAgICBrZXlDb2RlOiAxMyxcbiAgICAgICAgd2hpY2g6IDEzLFxuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgfSksXG4gICAgICBuZXcgS2V5Ym9hcmRFdmVudChcImtleXByZXNzXCIsIHtcbiAgICAgICAga2V5OiBcIkVudGVyXCIsXG4gICAgICAgIGNvZGU6IFwiRW50ZXJcIixcbiAgICAgICAga2V5Q29kZTogMTMsXG4gICAgICAgIHdoaWNoOiAxMyxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIH0pLFxuICAgICAgbmV3IEtleWJvYXJkRXZlbnQoXCJrZXl1cFwiLCB7XG4gICAgICAgIGtleTogXCJFbnRlclwiLFxuICAgICAgICBjb2RlOiBcIkVudGVyXCIsXG4gICAgICAgIGtleUNvZGU6IDEzLFxuICAgICAgICB3aGljaDogMTMsXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICB9KSxcbiAgICBdO1xuXG4gICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIHRoZSBjdXJyZW50bHkgcnVubmluZyBzY3JpcHQuXG4gICAqL1xuICBwdWJsaWMgY2FuY2VsKCk6IHZvaWQge1xuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDI0IE1hcnRpbiBCZWNoYXJkIDxtYXJ0aW4uYmVjaGFyZEBEZXZDb25zdWx0LmNhPlxuICogVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBGaWxlOiBzcmMvc2VydmljZXMvU2V0dGluZ3NTZXJ2aWNlLnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBTZXR0aW5ncyB7XG4gIGFudGhyb3BpY0FwaUtleT86IHN0cmluZztcbiAgbW9kZWw/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogU2VydmljZSBmb3IgbWFuYWdpbmcgZXh0ZW5zaW9uIHNldHRpbmdzIHVzaW5nIENocm9tZSdzIHN0b3JhZ2Ugc3luYyBBUElcbiAqIHdpdGggbG9jYWwgc3RvcmFnZSBmYWxsYmFjayBpbiBkZXZlbG9wbWVudCBtb2RlXG4gKi9cbmV4cG9ydCBjbGFzcyBTZXR0aW5nc1NlcnZpY2Uge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTVE9SQUdFX0tFWSA9IFwiYW50aHJvcGljX2FwaV9zZXR0aW5nc1wiO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBJU19ERVZfTU9ERSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCI7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfTU9ERUwgPSBcImNsYXVkZS0zLTUtc29ubmV0LTIwMjQxMDIyXCI7XG5cbiAgLyoqXG4gICAqIEdldHMgc2V0dGluZ3MgZnJvbSBsb2NhbCBzdG9yYWdlIChkZXYgbW9kZSBvbmx5KVxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0TG9jYWxTZXR0aW5ncygpOiBTZXR0aW5ncyB7XG4gICAgaWYgKCF0aGlzLklTX0RFVl9NT0RFKSByZXR1cm4ge307XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5TVE9SQUdFX0tFWSk7XG4gICAgICBpZiAoIXN0b3JlZCkgcmV0dXJuIHt9O1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIGxvY2FsIHNldHRpbmdzOlwiLCBlKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2F2ZXMgc2V0dGluZ3MgdG8gbG9jYWwgc3RvcmFnZSAoZGV2IG1vZGUgb25seSlcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHNldExvY2FsU2V0dGluZ3Moc2V0dGluZ3M6IFNldHRpbmdzKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLklTX0RFVl9NT0RFKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiW0RldiBNb2RlXSBTYXZlZCBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2U6XCIsIHNldHRpbmdzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNhdmUgbG9jYWwgc2V0dGluZ3M6XCIsIGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCBzZXR0aW5ncyBmcm9tIENocm9tZSBzeW5jIHN0b3JhZ2VcbiAgICogRmFsbHMgYmFjayB0byBsb2NhbCBzdG9yYWdlIGluIGRldiBtb2RlIGlmIENocm9tZSBzdG9yYWdlIGlzIGVtcHR5XG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIGdldFNldHRpbmdzKCk6IFByb21pc2U8U2V0dGluZ3M+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNocm9tZS5zdG9yYWdlLnN5bmMuZ2V0KFt0aGlzLlNUT1JBR0VfS0VZXSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHJlc3VsdFt0aGlzLlNUT1JBR0VfS0VZXSB8fCB7fTtcblxuICAgICAgICAvLyBJbiBkZXYgbW9kZSwgbWVyZ2Ugd2l0aCBsb2NhbCBzdG9yYWdlIHNldHRpbmdzXG4gICAgICAgIGlmICh0aGlzLklTX0RFVl9NT0RFKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWxTZXR0aW5ncyA9IHRoaXMuZ2V0TG9jYWxTZXR0aW5ncygpO1xuICAgICAgICAgIGNvbnN0IG1lcmdlZFNldHRpbmdzID0geyAuLi5zZXR0aW5ncywgLi4ubG9jYWxTZXR0aW5ncyB9O1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0RldiBNb2RlXSBVc2luZyBtZXJnZWQgc2V0dGluZ3M6XCIsIG1lcmdlZFNldHRpbmdzKTtcbiAgICAgICAgICByZXNvbHZlKG1lcmdlZFNldHRpbmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIHNldHRpbmcgdmFsdWUgaW4gQ2hyb21lIHN5bmMgc3RvcmFnZVxuICAgKiBBbHNvIHNhdmVzIHRvIGxvY2FsIHN0b3JhZ2UgaW4gZGV2IG1vZGVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgc2V0U2V0dGluZyhcbiAgICBrZXk6IGtleW9mIFNldHRpbmdzLFxuICAgIHZhbHVlOiBzdHJpbmdcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCB0aGlzLmdldFNldHRpbmdzKCk7XG4gICAgc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuXG4gICAgLy8gSW4gZGV2IG1vZGUsIGFsc28gc2F2ZSB0byBsb2NhbCBzdG9yYWdlXG4gICAgaWYgKHRoaXMuSVNfREVWX01PREUpIHtcbiAgICAgIHRoaXMuc2V0TG9jYWxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIHNhdmUgdG8gY2hyb21lLnN0b3JhZ2Uuc3luY1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY2hyb21lLnN0b3JhZ2Uuc3luYy5zZXQoeyBbdGhpcy5TVE9SQUdFX0tFWV06IHNldHRpbmdzIH0sICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuSVNfREVWX01PREUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIltEZXYgTW9kZV0gU2F2ZWQgc2V0dGluZ3MgdG8gY2hyb21lLnN0b3JhZ2U6XCIsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgc2luZ2xlIHNldHRpbmcgdmFsdWVcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgZ2V0U2V0dGluZyhcbiAgICBrZXk6IGtleW9mIFNldHRpbmdzXG4gICk6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSBhd2FpdCB0aGlzLmdldFNldHRpbmdzKCk7XG4gICAgcmV0dXJuIHNldHRpbmdzW2tleV0gfHwgKGtleSA9PT0gXCJtb2RlbFwiID8gdGhpcy5ERUZBVUxUX01PREVMIDogdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYW4gQW50aHJvcGljIEFQSSBrZXkgZm9ybWF0XG4gICAqIEByZXR1cm5zIEVycm9yIG1lc3NhZ2UgaWYgaW52YWxpZCwgbnVsbCBpZiB2YWxpZFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB2YWxpZGF0ZUFwaUtleShrZXk6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICgha2V5KSB7XG4gICAgICByZXR1cm4gXCJBUEkga2V5IGlzIHJlcXVpcmVkXCI7XG4gICAgfVxuICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoXCJzay1hbnQtXCIpKSB7XG4gICAgICByZXR1cm4gJ0ludmFsaWQgQVBJIGtleSBmb3JtYXQuIE11c3Qgc3RhcnQgd2l0aCBcInNrLWFudC1cIic7XG4gICAgfVxuICAgIGlmIChrZXkubGVuZ3RoIDwgMzIpIHtcbiAgICAgIHJldHVybiBcIkFQSSBrZXkgYXBwZWFycyB0b28gc2hvcnRcIjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIGEgbW9kZWwgbmFtZSBmb3JtYXRcbiAgICogQHJldHVybnMgRXJyb3IgbWVzc2FnZSBpZiBpbnZhbGlkLCBudWxsIGlmIHZhbGlkXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHZhbGlkYXRlTW9kZWwobW9kZWw6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICghbW9kZWwpIHtcbiAgICAgIHJldHVybiBcIk1vZGVsIGlzIHJlcXVpcmVkXCI7XG4gICAgfVxuICAgIGlmICghbW9kZWwuc3RhcnRzV2l0aChcImNsYXVkZS1cIikpIHtcbiAgICAgIHJldHVybiAnSW52YWxpZCBtb2RlbCBmb3JtYXQuIE11c3Qgc3RhcnQgd2l0aCBcImNsYXVkZS1cIic7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGF0IHJlcXVpcmVkIHNldHRpbmdzIGFyZSBjb25maWd1cmVkXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIHZhbGlkYXRlU2V0dGluZ3MoKTogUHJvbWlzZTx7XG4gICAgdmFsaWQ6IGJvb2xlYW47XG4gICAgbWVzc2FnZT86IHN0cmluZztcbiAgfT4ge1xuICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgdGhpcy5nZXRTZXR0aW5ncygpO1xuXG4gICAgaWYgKCFzZXR0aW5ncy5hbnRocm9waWNBcGlLZXkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICBcIlBsZWFzZSBjb25maWd1cmUgeW91ciBBbnRocm9waWMgQVBJIGtleSBpbiB0aGUgZXh0ZW5zaW9uIHNldHRpbmdzXCIsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGtleUVycm9yID0gdGhpcy52YWxpZGF0ZUFwaUtleShzZXR0aW5ncy5hbnRocm9waWNBcGlLZXkpO1xuICAgIGlmIChrZXlFcnJvcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBBUEkga2V5OiAke2tleUVycm9yfWAsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlIH07XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDI0IE1hcnRpbiBCZWNoYXJkIDxtYXJ0aW4uYmVjaGFyZEBEZXZDb25zdWx0LmNhPlxuICogVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBGaWxlOiBzcmMvc2VydmljZXMvV2luZG93U3RhdGVTZXJ2aWNlLnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKlxuICogU2VydmljZSBmb3IgbWFuYWdpbmcgYW5kIHBlcnNpc3Rpbmcgd2luZG93IHN0YXRlXG4gKiBOb3RlOiBSZW1lbWJlcmluZyB5b3VyIHdpbmRvdyBwcmVmZXJlbmNlcywgc28geW91IGRvbid0IGhhdmUgdG8hXG4gKi9cblxuaW50ZXJmYWNlIFdpbmRvd0dlb21ldHJ5IHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIHdpZHRoOiBzdHJpbmc7XG4gIGhlaWdodDogc3RyaW5nO1xuICBpc01pbmltaXplZDogYm9vbGVhbjtcbiAgaXNDb2xsYXBzZWQ6IGJvb2xlYW47XG4gIGlzU2NyaXB0TW9kZTogYm9vbGVhbjtcbiAgc2NyaXB0SGVpZ2h0Pzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgV2luZG93U3RhdGVTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgU1RPUkFHRV9LRVkgPSBcImNsYXVkZV9leHRlbnNpb25fd2luZG93X3N0YXRlXCI7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfU1RBVEU6IFdpbmRvd0dlb21ldHJ5ID0ge1xuICAgIHg6IDIwLFxuICAgIHk6IDIwLFxuICAgIHdpZHRoOiBcIjQwMHB4XCIsXG4gICAgaGVpZ2h0OiBcIjUwMHB4XCIsXG4gICAgaXNNaW5pbWl6ZWQ6IGZhbHNlLFxuICAgIGlzQ29sbGFwc2VkOiBmYWxzZSxcbiAgICBzY3JpcHRIZWlnaHQ6IFwiMTAwcHhcIixcbiAgICBpc1NjcmlwdE1vZGU6IGZhbHNlLFxuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgc2F2ZWQgd2luZG93IHN0YXRlIGZyb20gc3RvcmFnZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBsb2FkU3RhdGUoKTogV2luZG93R2VvbWV0cnkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzYXZlZFN0YXRlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5TVE9SQUdFX0tFWSk7XG4gICAgICBpZiAoc2F2ZWRTdGF0ZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzYXZlZFN0YXRlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBsb2FkIHdpbmRvdyBzdGF0ZTpcIiwgZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4geyAuLi50aGlzLkRFRkFVTFRfU1RBVEUgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgY3VycmVudCB3aW5kb3cgc3RhdGUgdG8gc3RvcmFnZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzYXZlU3RhdGUoc3RhdGU6IFBhcnRpYWw8V2luZG93R2VvbWV0cnk+KTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMubG9hZFN0YXRlKCk7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHsgLi4uY3VycmVudFN0YXRlLCAuLi5zdGF0ZSB9O1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5TVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkobmV3U3RhdGUpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzYXZlIHdpbmRvdyBzdGF0ZTpcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBzdGF0aWMgc2F2ZU1vZGUoaXNTY3JpcHRNb2RlOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5zYXZlU3RhdGUoeyBpc1NjcmlwdE1vZGUgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB3aW5kb3cgcG9zaXRpb25cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc2F2ZVBvc2l0aW9uKHg6IG51bWJlciwgeTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zYXZlU3RhdGUoeyB4LCB5IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgd2luZG93IGRpbWVuc2lvbnNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgc2F2ZUdlb21ldHJ5KHdpZHRoOiBzdHJpbmcsIGhlaWdodDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5zYXZlU3RhdGUoeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgc2NyaXB0IHRleHRhcmVhIGhlaWdodFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzYXZlU2NyaXB0SGVpZ2h0KGhlaWdodDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5zYXZlU3RhdGUoeyBzY3JpcHRIZWlnaHQ6IGhlaWdodCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHdpbmRvdyBzdGF0ZSBmbGFnc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzYXZlV2luZG93U3RhdGUoXG4gICAgaXNNaW5pbWl6ZWQ6IGJvb2xlYW4sXG4gICAgaXNDb2xsYXBzZWQ6IGJvb2xlYW5cbiAgKTogdm9pZCB7XG4gICAgdGhpcy5zYXZlU3RhdGUoeyBpc01pbmltaXplZCwgaXNDb2xsYXBzZWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBzYXZlZCBzdGF0ZSB0byB3aW5kb3cgZWxlbWVudFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBhcHBseVN0YXRlKFxuICAgIHdpbmRvd0VsZW1lbnQ6IEhUTUxFbGVtZW50LFxuICAgIHNjcmlwdEVsZW1lbnQ/OiBIVE1MRWxlbWVudFxuICApOiB2b2lkIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMubG9hZFN0YXRlKCk7XG5cbiAgICAvLyBTZXQgYWJzb2x1dGUgcG9zaXRpb25pbmdcbiAgICB3aW5kb3dFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIHdpbmRvd0VsZW1lbnQuc3R5bGUucmlnaHQgPSBcImF1dG9cIjsgLy8gQ2xlYXIgYW55IHJpZ2h0IHBvc2l0aW9uaW5nXG5cbiAgICAvLyBBbHdheXMgYXBwbHkgcG9zaXRpb24sIGV2ZW4gd2hlbiBtaW5pbWl6ZWRcbiAgICB3aW5kb3dFbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtzdGF0ZS54fXB4YDtcbiAgICB3aW5kb3dFbGVtZW50LnN0eWxlLnRvcCA9IGAke3N0YXRlLnl9cHhgO1xuXG4gICAgLy8gQXBwbHkgZGltZW5zaW9ucyBpZiBub3QgbWluaW1pemVkXG4gICAgaWYgKCFzdGF0ZS5pc01pbmltaXplZCkge1xuICAgICAgd2luZG93RWxlbWVudC5zdHlsZS53aWR0aCA9IHN0YXRlLndpZHRoO1xuICAgICAgd2luZG93RWxlbWVudC5zdHlsZS5oZWlnaHQgPSBzdGF0ZS5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENsZWFyIGRpbWVuc2lvbnMgYnV0IG1haW50YWluIHBvc2l0aW9uIHdoZW4gbWluaW1pemVkXG4gICAgICB3aW5kb3dFbGVtZW50LnN0eWxlLndpZHRoID0gXCJcIjtcbiAgICAgIHdpbmRvd0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gXCJcIjtcbiAgICAgIHdpbmRvd0VsZW1lbnQuY2xhc3NMaXN0LmFkZChcIm1pbmltaXplZFwiKTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBzY3JpcHQgaGVpZ2h0IGlmIGVsZW1lbnQgcHJvdmlkZWRcbiAgICBpZiAoc2NyaXB0RWxlbWVudCAmJiBzdGF0ZS5zY3JpcHRIZWlnaHQpIHtcbiAgICAgIHNjcmlwdEVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gc3RhdGUuc2NyaXB0SGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb2xsYXBzZSBzdGF0ZVxuICAgIGlmIChzdGF0ZS5pc0NvbGxhcHNlZCkge1xuICAgICAgY29uc3Qgb3V0cHV0RGl2ID0gd2luZG93RWxlbWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBcIiNzY3JpcHRPdXRwdXRcIlxuICAgICAgKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgIGlmIChvdXRwdXREaXYpIHtcbiAgICAgICAgb3V0cHV0RGl2LnN0eWxlLm1heEhlaWdodCA9IFwiM2VtXCI7XG4gICAgICAgIG91dHB1dERpdi5zdHlsZS5vdmVyZmxvd1kgPSBcImhpZGRlblwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgPG1hcnRpbi5iZWNoYXJkQERldkNvbnN1bHQuY2E+XG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIEZpbGU6IHNyYy90eXBlcy9pbmRleC50c1xuICogVGhpcyB3YXMgZ2VuZXJhdGVkIGJ5IENsYXVkZSBTb25uZXQgMy41LCB3aXRoIHRoZSBhc3Npc3RhbmNlIG9mIG15IGh1bWFuIG1lbnRvclxuICovXG5cbmltcG9ydCB7IENvbW1hbmROYW1lIH0gZnJvbSBcIi4uL3V0aWxzL2NvbW1hbmRzL0NvbW1hbmRNYXBcIjtcblxuLyoqXG4gKiBTZWFyY2ggcmVzdWx0IGluZm9ybWF0aW9uIGZvciBjb252ZXJzYXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoUmVzdWx0SW5mbyB7XG4gIGNvbnZlcnNhdGlvbklkOiBzdHJpbmc7IC8vIElEIG9mIHRoZSBtYXRjaGluZyBjb252ZXJzYXRpb25cbiAgbWVzc2FnZUlkOiBzdHJpbmc7IC8vIFVVSUQgb2YgdGhlIHNwZWNpZmljIG1lc3NhZ2UgdGhhdCBtYXRjaGVzXG4gIG1hdGNoUmVhc29uOiBzdHJpbmc7IC8vIENsZWFyIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIGNvbnZlcnNhdGlvbiBtYXRjaGVzXG4gIHJlbGV2YW50U25pcHBldDogc3RyaW5nOyAvLyBUaGUgc3BlY2lmaWMgdGV4dCBzbmlwcGV0IHRoYXQgbWF0Y2hlcyAobWF4IDIwMCBjaGFycylcbn1cblxuLyoqXG4gKiBTdG9wIGNvbmRpdGlvbiBpbmZvcm1hdGlvbiBmb3Igc2NyaXB0IHBhcnNpbmdcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdG9wQ29uZGl0aW9uIHtcbiAgdGFyZ2V0OiBzdHJpbmc7XG4gIHR5cGU6IFwiaWZcIiB8IFwiaWZfbm90XCI7XG59XG5cbi8qKlxuICogUGFyc2VkIGNvbW1hbmQgbGluZSBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFBhcnNlZENvbW1hbmRMaW5lIHtcbiAgY29tbWFuZDogQ29tbWFuZE5hbWU7XG4gIHJhd0NvbW1hbmQ6IHN0cmluZztcbiAgb3B0aW9uczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgcHJvbXB0OiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHNpbmdsZSBzY3JpcHQgc3RhdGVtZW50IHdpdGggaXRzIHN0b3AgY29uZGl0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFNjcmlwdFN0YXRlbWVudFByb3BzIHtcbiAgcHJvbXB0Pzogc3RyaW5nO1xuICBpc0NvbW1hbmQ6IGJvb2xlYW47XG4gIGNvbW1hbmQ/OiBDb21tYW5kTmFtZSB8IG51bGw7XG4gIG9wdGlvbnM/OiBDb21tYW5kT3B0aW9uczsgLy8gSW5jbHVkZXMgbWF4VHJpZXNcbiAgc2VhcmNoVGV4dD86IHN0cmluZzsgLy8gT3B0aW9uYWwgc2VhcmNoIHRleHQgZm9yIHNlYXJjaCBjb21tYW5kc1xuICBhbGlhc0NvbW1hbmQ/OiBBbGlhc0NvbW1hbmQ7IC8vIE9wdGlvbmFsIGFsaWFzIGNvbW1hbmQgZGV0YWlsc1xufVxuXG5leHBvcnQgY2xhc3MgU2NyaXB0U3RhdGVtZW50IHtcbiAgcHVibGljIHJlYWRvbmx5IHByb21wdD86IHN0cmluZztcbiAgcHVibGljIHJlYWRvbmx5IGlzQ29tbWFuZDogYm9vbGVhbjtcbiAgcHVibGljIHJlYWRvbmx5IGNvbW1hbmQ/OiBDb21tYW5kTmFtZSB8IG51bGw7XG4gIHB1YmxpYyByZWFkb25seSBvcHRpb25zOiBDb21tYW5kT3B0aW9ucztcbiAgcHVibGljIHJlYWRvbmx5IHNlYXJjaFRleHQ/OiBzdHJpbmc7IC8vIE9wdGlvbmFsIHNlYXJjaCB0ZXh0IGZvciBzZWFyY2ggY29tbWFuZHNcbiAgcHVibGljIHJlYWRvbmx5IGFsaWFzQ29tbWFuZD86IEFsaWFzQ29tbWFuZDsgLy8gT3B0aW9uYWwgYWxpYXMgY29tbWFuZCBkZXRhaWxzXG5cbiAgY29uc3RydWN0b3IocHJvcHM6IFNjcmlwdFN0YXRlbWVudFByb3BzKSB7XG4gICAgdGhpcy5wcm9tcHQgPSBwcm9wcy5wcm9tcHQ7XG4gICAgdGhpcy5pc0NvbW1hbmQgPSBwcm9wcy5pc0NvbW1hbmQ7XG4gICAgdGhpcy5jb21tYW5kID0gcHJvcHMuY29tbWFuZDtcbiAgICB0aGlzLm9wdGlvbnMgPSBwcm9wcy5vcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuc2VhcmNoVGV4dCA9IHByb3BzLnNlYXJjaFRleHQ7XG4gICAgdGhpcy5hbGlhc0NvbW1hbmQgPSBwcm9wcy5hbGlhc0NvbW1hbmQ7XG4gIH1cblxuICBwdWJsaWMgYWRkU3RvcENvbmRpdGlvbihzdG9wQ29uZGl0aW9uOiBTdG9wQ29uZGl0aW9uKSB7XG4gICAgbGV0IGNvbmRpdGlvbnMgPSB0aGlzLm9wdGlvbnNbXCJzdG9wQ29uZGl0aW9uc1wiXTtcbiAgICBpZiAoIWNvbmRpdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9uc1tcInN0b3BDb25kaXRpb25zXCJdID0gY29uZGl0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBjb25kaXRpb25zLnB1c2goc3RvcENvbmRpdGlvbik7XG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBjb21tYW5kIGV4ZWN1dGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbW1hbmRPcHRpb25zIHtcbiAgaW5jbHVkZUFydGlmYWN0cz86IGJvb2xlYW47XG4gIGluY2x1ZGVDb252ZXJzYXRpb24/OiBib29sZWFuO1xuICBkb3dubG9hZE11bHRpcGxlPzogYm9vbGVhbjtcbiAgbWF4VHJpZXM/OiBudW1iZXI7IC8vIEZvciByZXBlYXQgY29tbWFuZFxuICBzdG9wQ29uZGl0aW9ucz86IFN0b3BDb25kaXRpb25bXTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFsaWFzIGNvbW1hbmQgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWxpYXNDb21tYW5kIHtcbiAgdHlwZTogXCJhbGlhc1wiIHwgXCJkZWxldGVfYWxpYXNcIiB8IFwibGlzdF9hbGlhc1wiO1xuICBuYW1lPzogc3RyaW5nOyAvLyBGb3Igc2V0IGFuZCBkZWxldGVcbiAgdGV4dD86IHN0cmluZzsgLy8gRm9yIHNldFxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzY3JpcHQgdG8gYmUgZXhlY3V0ZWRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTY3JpcHQge1xuICBzdGF0ZW1lbnRzOiBTY3JpcHRTdGF0ZW1lbnRbXTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayB0eXBlIGZvciBjdXN0b20gY29udGVudCByZXRyaWV2YWwgYmVmb3JlIGRvd25sb2FkXG4gKi9cbmV4cG9ydCB0eXBlIENvbnRlbnRDYWxsYmFjayA9IChkb2NJbmZvOiBEb2N1bWVudEluZm8pID0+IFByb21pc2U8c3RyaW5nPjtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGRvY3VtZW50IG1ldGFkYXRhIGFuZCBjb250ZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRJbmZvIHtcbiAgZmlsZU5hbWU6IHN0cmluZztcbiAgZmlsZVBhdGg6IHN0cmluZztcbiAgY29udGVudDogc3RyaW5nO1xuICBpc1NlbGVjdGVkPzogYm9vbGVhbjtcbiAgbWV0YWRhdGE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBjb250ZW50Q2FsbGJhY2s/OiBDb250ZW50Q2FsbGJhY2s7XG4gIHNlYXJjaFJlc3VsdD86IFNlYXJjaFJlc3VsdEluZm87XG59XG5cbi8qKlxuICogU3RhdHVzIHR5cGVzIGZvciBvcGVyYXRpb24gc3RhdGVzXG4gKi9cbmV4cG9ydCB0eXBlIFN0YXR1c1N0YXRlID0gXCJyZWFkeVwiIHwgXCJ3b3JraW5nXCIgfCBcImVycm9yXCI7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3Igc3RhdHVzIHN0YXRlcyBhbmQgdGhlaXIgZGlzcGxheSBwcm9wZXJ0aWVzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdHVzQ29uZmlnIHtcbiAgdGV4dDogc3RyaW5nO1xuICBjbGFzczogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcXVpcmVkIGVsZW1lbnRzIGZvciBzdGF0dXMgbWFuYWdlbWVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0YXR1c0VsZW1lbnRzIHtcbiAgc3RhdHVzRWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gIHN0YXR1c1RleHQ6IEhUTUxFbGVtZW50O1xuICBzdGF0dXNEZXRhaWxzOiBIVE1MRWxlbWVudDtcbiAgc2NyaXB0SW5wdXQ6IEhUTUxUZXh0QXJlYUVsZW1lbnQ7XG4gIHJ1bkJ1dHRvbjogSFRNTEJ1dHRvbkVsZW1lbnQ7XG59XG5cbi8qKlxuICogRWxlbWVudHMgbWFuYWdlZCBieSBmbG9hdGluZyB3aW5kb3cgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmxvYXRpbmdXaW5kb3dFbGVtZW50cyB7XG4gIHdpbmRvdzogSFRNTEVsZW1lbnQ7XG4gIHN0YXR1czogSFRNTEVsZW1lbnQ7XG4gIHN0YXR1c1RleHQ6IEhUTUxFbGVtZW50O1xuICBzdGF0dXNEZXRhaWxzOiBIVE1MRWxlbWVudDtcbiAgc2NyaXB0VGV4dDogSFRNTFRleHRBcmVhRWxlbWVudDtcbiAgcnVuQnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudDtcbiAgb3V0cHV0OiBIVE1MRWxlbWVudDtcbiAgaGVscEJ1dHRvbjogSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gIG1pbmltaXplQnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudDtcbiAgY29sbGFwc2VCdXR0b246IEhUTUxFbGVtZW50O1xuICBtb2RlVG9nZ2xlQnV0dG9uOiBIVE1MQnV0dG9uRWxlbWVudDtcbiAgc2NyaXB0TW9kZUNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gIHNpbXBsZU1vZGVDb250YWluZXI6IEhUTUxFbGVtZW50O1xufVxuXG4vKipcbiAqIFNldHRpbmdzIGZvciBhIGNvbnZlcnNhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnZlcnNhdGlvblNldHRpbmdzIHtcbiAgcHJldmlld19mZWF0dXJlX3VzZXNfYXJ0aWZhY3RzOiBib29sZWFuO1xuICBwcmV2aWV3X2ZlYXR1cmVfdXNlc19sYXRleDogYm9vbGVhbjtcbiAgZW5hYmxlZF9hcnRpZmFjdHNfYXR0YWNobWVudHM6IGJvb2xlYW47XG59XG5cbi8qKlxuICogUHJvamVjdCBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb2plY3Qge1xuICB1dWlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBGaWxlIGF0dGFjaG1lbnQgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBdHRhY2htZW50IHtcbiAgaWQ6IHN0cmluZztcbiAgZmlsZV9uYW1lOiBzdHJpbmc7XG4gIGZpbGVfc2l6ZTogbnVtYmVyO1xuICBmaWxlX3R5cGU6IHN0cmluZztcbiAgZXh0cmFjdGVkX2NvbnRlbnQ/OiBzdHJpbmc7XG4gIGNyZWF0ZWRfYXQ/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogVjIgRmlsZSBhdHRhY2htZW50IGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVYyIGV4dGVuZHMgQXR0YWNobWVudCB7XG4gIC8vIEFkZCBhbnkgdjItc3BlY2lmaWMgZmllbGRzIGhlcmUgaWYgdGhleSBleGlzdFxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIGNvbnRlbnQgaXRlbSBpbiB0aGUgY29udmVyc2F0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdE1lc3NhZ2VDb250ZW50IHtcbiAgdHlwZTogXCJ0ZXh0XCIgfCBcInRvb2xfdXNlXCIgfCBcInRvb2xfcmVzdWx0XCI7XG5cbiAgLy8gVHlwZSB0ZXh0XG4gIHRleHQ/OiBzdHJpbmc7XG5cbiAgLy8gVHlwZSB0b29sX3VzZVxuICBuYW1lPzogc3RyaW5nO1xuICBpbnB1dD86IENoYXRNZXNzYWdlSW5wdXQ7XG5cbiAgLy8gVHlwZSB0b29sX3Jlc3VsdFxuICBjb250ZW50PzogYW55W107XG4gIGlzX2Vycm9yPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGlucHV0IGZvciB0b29sLWJhc2VkIG1lc3NhZ2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdE1lc3NhZ2VJbnB1dCB7XG4gIGNvbW1hbmQ6IFwiY3JlYXRlXCIgfCBcInVwZGF0ZVwiO1xuICBpZDogc3RyaW5nO1xuICB0eXBlPzogXCJ0ZXh0XCIgfCBcImFwcGxpY2F0aW9uL3ZuZC5hbnQuY29kZVwiO1xuICB0aXRsZT86IHN0cmluZztcblxuICAvLyBGdWxsIGZpbGVcbiAgY29udGVudD86IHN0cmluZztcbiAgbGFuZ3VhZ2U/OiBzdHJpbmc7XG4gIHZlcnNpb25fdXVpZD86IHN0cmluZztcblxuICAvLyBVcGRhdGUgY29tbWFuZFxuICBvbGRfc3RyPzogc3RyaW5nO1xuICBuZXdfc3RyPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBtZXNzYWdlIGluIHRoZSBjb252ZXJzYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGF0TWVzc2FnZSB7XG4gIHV1aWQ6IHN0cmluZztcbiAgdGV4dDogc3RyaW5nO1xuICBjb250ZW50OiBDaGF0TWVzc2FnZUNvbnRlbnRbXTtcbiAgc2VuZGVyOiBcImh1bWFuXCIgfCBcImFzc2lzdGFudFwiO1xuICBpbmRleDogbnVtYmVyO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcbiAgdHJ1bmNhdGVkOiBib29sZWFuO1xuICBzdG9wX3JlYXNvbj86IHN0cmluZztcbiAgYXR0YWNobWVudHM6IEF0dGFjaG1lbnRbXTtcbiAgZmlsZXM6IEF0dGFjaG1lbnRbXTtcbiAgZmlsZXNfdjI6IEZpbGVWMltdO1xuICBzeW5jX3NvdXJjZXM6IGFueVtdO1xuICBwYXJlbnRfbWVzc2FnZV91dWlkOiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbnZlcnNhdGlvbiB3aXRoaW4gYSBwcm9qZWN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdENvbnZlcnNhdGlvbiB7XG4gIHV1aWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBzdW1tYXJ5Pzogc3RyaW5nO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcbiAgbWVzc2FnZV9jb3VudDogbnVtYmVyO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb21wbGV0ZSBjb252ZXJzYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb24ge1xuICB1dWlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgc3VtbWFyeTogc3RyaW5nO1xuICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcbiAgc2V0dGluZ3M6IENvbnZlcnNhdGlvblNldHRpbmdzO1xuICBpc19zdGFycmVkOiBib29sZWFuO1xuICBwcm9qZWN0X3V1aWQ6IHN0cmluZztcbiAgcHJvamVjdD86IFByb2plY3Q7XG4gIGN1cnJlbnRfbGVhZl9tZXNzYWdlX3V1aWQ6IHN0cmluZztcbiAgY2hhdF9tZXNzYWdlczogQ2hhdE1lc3NhZ2VbXTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGFydGlmYWN0IGV4dHJhY3RlZCBmcm9tIGEgY29udmVyc2F0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udmVyc2F0aW9uQXJ0aWZhY3Qge1xuICBpZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICBsYW5ndWFnZT86IHN0cmluZztcbiAgY29udGVudD86IHN0cmluZztcbiAgZGVsdGE/OiB7IG9sZDogc3RyaW5nOyBuZXc6IHN0cmluZyB9O1xuICBmaWxlUGF0aD86IHN0cmluZztcbiAgY3JlYXRlZF9hdDogc3RyaW5nOyAvLyBBZGQgdGhpc1xuICB1cGRhdGVkX2F0OiBzdHJpbmc7IC8vIEFkZCB0aGlzXG59XG5cbi8qKlxuICogUmVzcG9uc2UgZnJvbSB0aGUgQ2xhdWRlIEFQSSBmb3IgY29tcGxldGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb21wbGV0aW9uUmVzcG9uc2Uge1xuICBjb21wbGV0aW9uOiBzdHJpbmc7XG4gIHN0b3BfcmVhc29uOiBzdHJpbmc7XG4gIG1vZGVsOiBzdHJpbmc7XG4gIHN0b3A6IHN0cmluZyB8IG51bGw7XG4gIGxvZ19pZDogc3RyaW5nO1xuICBtZXNzYWdlTGltaXQ6IHtcbiAgICB0eXBlOiBzdHJpbmc7XG4gICAgcmVtYWluaW5nOiBudW1iZXI7XG4gIH07XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogc3JjL3R5cGVzL3N0b3JhZ2UudHNcbiAqIFRoaXMgd2FzIGdlbmVyYXRlZCBieSBDbGF1ZGUgU29ubmV0IDMuNSwgd2l0aCB0aGUgYXNzaXN0YW5jZSBvZiBteSBodW1hbiBtZW50b3JcbiAqL1xuXG4vKipcbiAqIEFic3RyYWN0IHN0b3JhZ2UgaW50ZXJmYWNlIHRvIHN1cHBvcnQgYm90aCBicm93c2VyIGFuZCB0ZXN0IGVudmlyb25tZW50c1xuICovXG5leHBvcnQgaW50ZXJmYWNlIElTdG9yYWdlIHtcbiAgZ2V0SXRlbShrZXk6IHN0cmluZyk6IHN0cmluZyB8IG51bGw7XG4gIHNldEl0ZW0oa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xuICByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogdm9pZDtcbn1cblxuLyoqXG4gKiBCcm93c2VyIGxvY2FsU3RvcmFnZSBpbXBsZW1lbnRhdGlvbiBvZiBJU3RvcmFnZVxuICovXG5leHBvcnQgY2xhc3MgQnJvd3NlclN0b3JhZ2UgaW1wbGVtZW50cyBJU3RvcmFnZSB7XG4gIGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgfVxuXG4gIHNldEl0ZW0oa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgfVxuXG4gIHJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICB9XG59XG5cbi8qKlxuICogSW4tbWVtb3J5IHN0b3JhZ2UgaW1wbGVtZW50YXRpb24gZm9yIHRlc3RpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIE1lbW9yeVN0b3JhZ2UgaW1wbGVtZW50cyBJU3RvcmFnZSB7XG4gIHByaXZhdGUgc3RvcmFnZTogTWFwPHN0cmluZywgc3RyaW5nPiA9IG5ldyBNYXAoKTtcblxuICBnZXRJdGVtKGtleTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXQoa2V5KSB8fCBudWxsO1xuICB9XG5cbiAgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuc3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIH1cblxuICByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5zdG9yYWdlLmRlbGV0ZShrZXkpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogL1VzZXJzL21hcnRpbmJlY2hhcmQvZGV2L2NsYXVkZWV4dC9zcmMvdWkvY29tcG9uZW50cy9Db250ZW50UHJldmlldy50c1xuICogVGhpcyB3YXMgZ2VuZXJhdGVkIGJ5IENsYXVkZSBTb25uZXQgMy41LCB3aXRoIHRoZSBhc3Npc3RhbmNlIG9mIG15IGh1bWFuIG1lbnRvclxuICovXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgUHJpc20/OiB7XG4gICAgICBoaWdobGlnaHQ6IChjb2RlOiBzdHJpbmcsIGdyYW1tYXI6IGFueSwgbGFuZ3VhZ2U6IHN0cmluZykgPT4gc3RyaW5nO1xuICAgICAgbGFuZ3VhZ2VzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuICAgIH07XG4gIH1cbn1cblxuY29uc3Qgc3R5bGVzID0ge1xuICBjb2xvcnM6IHtcbiAgICBwcmltYXJ5OiBcIiMwMDY2Y2NcIixcbiAgICBib3JkZXI6IFwiI2NjY1wiLFxuICAgIHRleHQ6IFwiIzMzM1wiLFxuICAgIGJhY2tncm91bmQ6IFwiI2ZmZlwiLFxuICAgIG92ZXJsYXk6IFwicmdiYSgwLCAwLCAwLCAwLjUpXCIsXG4gICAgY29kZUJnOiBcIiNmNWY1ZjVcIixcbiAgfSxcbiAgc3BhY2luZzoge1xuICAgIHNtOiBcIjhweFwiLFxuICAgIG1kOiBcIjE2cHhcIixcbiAgICBsZzogXCIyNHB4XCIsXG4gIH0sXG4gIGJvcmRlclJhZGl1czogXCI4cHhcIixcbiAgZm9udFNpemU6IHtcbiAgICBzbTogXCIxNHB4XCIsXG4gICAgbWQ6IFwiMTZweFwiLFxuICAgIGxnOiBcIjE4cHhcIixcbiAgfSxcbn07XG5cbmV4cG9ydCBjbGFzcyBDb250ZW50UHJldmlldyB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGlhbG9nOiBIVE1MRWxlbWVudDtcbiAgcHJpdmF0ZSByZWFkb25seSBjb250ZW50OiBIVE1MRWxlbWVudDtcbiAgcHJpdmF0ZSBpc09wZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBJbml0aWFsaXplIGVsZW1lbnRzIGluIGNvbnN0cnVjdG9yXG4gICAgdGhpcy5kaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5jcmVhdGVEaWFsb2coKTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRGlhbG9nKCk6IHZvaWQge1xuICAgIC8vIENyZWF0ZSBvdmVybGF5IGNvbnRhaW5lclxuICAgIHRoaXMuZGlhbG9nLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kOiAke3N0eWxlcy5jb2xvcnMub3ZlcmxheX07XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICB6LWluZGV4OiAxMDAwMDAwO1xuICAgICAgYDtcblxuICAgIC8vIENyZWF0ZSBjb250ZW50IGNvbnRhaW5lclxuICAgIHRoaXMuY29udGVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBiYWNrZ3JvdW5kOiAke3N0eWxlcy5jb2xvcnMuYmFja2dyb3VuZH07XG4gICAgICAgIGJvcmRlci1yYWRpdXM6ICR7c3R5bGVzLmJvcmRlclJhZGl1c307XG4gICAgICAgIHdpZHRoOiA4MDBweDtcbiAgICAgICAgbWF4LXdpZHRoOiA5MCU7XG4gICAgICAgIG1heC1oZWlnaHQ6IDgwdmg7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGJveC1zaGFkb3c6IDAgNHB4IDEycHggcmdiYSgwLCAwLCAwLCAwLjE1KTtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgYDtcblxuICAgIHRoaXMuZGlhbG9nLmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmRpYWxvZyk7XG5cbiAgICAvLyBDbG9zZSBvbiBiYWNrZ3JvdW5kIGNsaWNrXG4gICAgdGhpcy5kaWFsb2cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMuZGlhbG9nKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsb3NlIG9uIGVzY2FwZSBrZXlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiICYmIHRoaXMuaXNPcGVuKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TGFuZ3VhZ2VGcm9tRmlsZU5hbWUoZmlsZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZXh0ID0gZmlsZU5hbWUuc3BsaXQoXCIuXCIpLnBvcCgpPy50b0xvd2VyQ2FzZSgpIHx8IFwiXCI7XG4gICAgY29uc3QgbGFuZ3VhZ2VNYXA6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0gPSB7XG4gICAgICBqczogXCJqYXZhc2NyaXB0XCIsXG4gICAgICB0czogXCJ0eXBlc2NyaXB0XCIsXG4gICAgICBqc3g6IFwiamF2YXNjcmlwdFwiLFxuICAgICAgdHN4OiBcInR5cGVzY3JpcHRcIixcbiAgICAgIHB5OiBcInB5dGhvblwiLFxuICAgICAgamF2YTogXCJqYXZhXCIsXG4gICAgICByYjogXCJydWJ5XCIsXG4gICAgICBnbzogXCJnb1wiLFxuICAgICAgcnM6IFwicnVzdFwiLFxuICAgICAgY3BwOiBcImNwcFwiLFxuICAgICAgYzogXCJjXCIsXG4gICAgICBjczogXCJjc2hhcnBcIixcbiAgICAgIHBocDogXCJwaHBcIixcbiAgICAgIGh0bWw6IFwiaHRtbFwiLFxuICAgICAgY3NzOiBcImNzc1wiLFxuICAgICAganNvbjogXCJqc29uXCIsXG4gICAgICBtZDogXCJtYXJrZG93blwiLFxuICAgICAgeW1sOiBcInlhbWxcIixcbiAgICAgIHlhbWw6IFwieWFtbFwiLFxuICAgICAgeG1sOiBcInhtbFwiLFxuICAgICAgc3FsOiBcInNxbFwiLFxuICAgICAgc2g6IFwiYmFzaFwiLFxuICAgICAgYmFzaDogXCJiYXNoXCIsXG4gICAgfTtcbiAgICByZXR1cm4gbGFuZ3VhZ2VNYXBbZXh0XSB8fCBcInBsYWludGV4dFwiO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVDbG9zZUJ1dHRvbigpOiBIVE1MQnV0dG9uRWxlbWVudCB7XG4gICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uaW5uZXJIVE1MID0gXCLDl1wiO1xuICAgIGJ1dHRvbi5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogJHtzdHlsZXMuc3BhY2luZy5zbX07XG4gICAgICAgIHJpZ2h0OiAke3N0eWxlcy5zcGFjaW5nLnNtfTtcbiAgICAgICAgZm9udC1zaXplOiAke3N0eWxlcy5mb250U2l6ZS5sZ307XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgYmFja2dyb3VuZDogbm9uZTtcbiAgICAgICAgY29sb3I6ICR7c3R5bGVzLmNvbG9ycy50ZXh0fTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICBwYWRkaW5nOiAke3N0eWxlcy5zcGFjaW5nLnNtfTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgYDtcblxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsICgpID0+IHtcbiAgICAgIGJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBzdHlsZXMuY29sb3JzLmNvZGVCZztcbiAgICB9KTtcblxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgKCkgPT4ge1xuICAgICAgYnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB9KTtcblxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5jbG9zZSgpKTtcbiAgICByZXR1cm4gYnV0dG9uO1xuICB9XG5cbiAgcHVibGljIHNob3codGl0bGU6IHN0cmluZywgY29udGVudDogc3RyaW5nLCBmaWxlTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gUmVzZXQgY29udGVudFxuICAgIHRoaXMuY29udGVudC5pbm5lckhUTUwgPSBcIlwiO1xuXG4gICAgLy8gQ3JlYXRlIGhlYWRlclxuICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgaGVhZGVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBhZGRpbmc6ICR7c3R5bGVzLnNwYWNpbmcubWR9ICR7c3R5bGVzLnNwYWNpbmcubGd9O1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgJHtzdHlsZXMuY29sb3JzLmJvcmRlcn07XG4gICAgICBgO1xuXG4gICAgY29uc3QgdGl0bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgyXCIpO1xuICAgIHRpdGxlRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIGZvbnQtc2l6ZTogJHtzdHlsZXMuZm9udFNpemUubGd9O1xuICAgICAgICBmb250LXdlaWdodDogNjAwO1xuICAgICAgICBjb2xvcjogJHtzdHlsZXMuY29sb3JzLnRleHR9O1xuICAgICAgYDtcbiAgICB0aXRsZUVsZW1lbnQudGV4dENvbnRlbnQgPSB0aXRsZTtcbiAgICBoZWFkZXIuYXBwZW5kQ2hpbGQodGl0bGVFbGVtZW50KTtcblxuICAgIC8vIENyZWF0ZSBjb250ZW50IGNvbnRhaW5lclxuICAgIGNvbnN0IGNvbnRlbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnRlbnRDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcGFkZGluZzogJHtzdHlsZXMuc3BhY2luZy5tZH07XG4gICAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIG1pbi1oZWlnaHQ6IDIwMHB4O1xuICAgICAgICBtYXgtaGVpZ2h0OiBjYWxjKDgwdmggLSAxMDBweCk7XG4gICAgICAgIGJhY2tncm91bmQ6ICR7c3R5bGVzLmNvbG9ycy5jb2RlQmd9O1xuICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICB3aGl0ZS1zcGFjZTogcHJlO1xuICAgICAgICBmb250LXNpemU6ICR7c3R5bGVzLmZvbnRTaXplLnNtfTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDEuNTtcbiAgICAgIGA7XG5cbiAgICAvLyBBZGQgY29udGVudCBhcyBjb2RlIGJsb2NrIGlmIGFwcGxpY2FibGVcbiAgICBjb25zdCBsYW5ndWFnZSA9IHRoaXMuZ2V0TGFuZ3VhZ2VGcm9tRmlsZU5hbWUoZmlsZU5hbWUpO1xuICAgIGlmIChsYW5ndWFnZSAhPT0gXCJwbGFpbnRleHRcIikge1xuICAgICAgY29udGVudENvbnRhaW5lci5jbGFzc05hbWUgPSBgbGFuZ3VhZ2UtJHtsYW5ndWFnZX1gO1xuXG4gICAgICAvLyBBcHBseSBzeW50YXggaGlnaGxpZ2h0aW5nIGlmIFByaXNtIGlzIGF2YWlsYWJsZVxuICAgICAgaWYgKHdpbmRvdy5QcmlzbSAmJiB3aW5kb3cuUHJpc20ubGFuZ3VhZ2VzW2xhbmd1YWdlXSkge1xuICAgICAgICBjb250ZW50Q29udGFpbmVyLmlubmVySFRNTCA9IHdpbmRvdy5QcmlzbS5oaWdobGlnaHQoXG4gICAgICAgICAgY29udGVudCxcbiAgICAgICAgICB3aW5kb3cuUHJpc20ubGFuZ3VhZ2VzW2xhbmd1YWdlXSxcbiAgICAgICAgICBsYW5ndWFnZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudENvbnRhaW5lci50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRlbnRDb250YWluZXIudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cblxuICAgIC8vIEFkZCBjbG9zZSBidXR0b25cbiAgICBjb25zdCBjbG9zZUJ1dHRvbiA9IHRoaXMuY3JlYXRlQ2xvc2VCdXR0b24oKTtcblxuICAgIC8vIEFzc2VtYmxlIGRpYWxvZ1xuICAgIHRoaXMuY29udGVudC5hcHBlbmRDaGlsZChjbG9zZUJ1dHRvbik7XG4gICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKGhlYWRlcik7XG4gICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKGNvbnRlbnRDb250YWluZXIpO1xuXG4gICAgLy8gU2hvdyBkaWFsb2cgd2l0aCBhbmltYXRpb25cbiAgICB0aGlzLmRpYWxvZy5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gICAgdGhpcy5kaWFsb2cuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kaWFsb2cuc3R5bGUudHJhbnNpdGlvbiA9IFwib3BhY2l0eSAwLjJzIGVhc2Utb3V0XCI7XG4gICAgICB0aGlzLmRpYWxvZy5zdHlsZS5vcGFjaXR5ID0gXCIxXCI7XG4gICAgfSwgMCk7XG5cbiAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgY2xvc2UoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzT3BlbikgcmV0dXJuO1xuXG4gICAgdGhpcy5kaWFsb2cuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kaWFsb2cuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgdGhpcy5jb250ZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgfSwgMjAwKTtcblxuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmRpYWxvZy5yZW1vdmUoKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgPG1hcnRpbi5iZWNoYXJkQERldkNvbnN1bHQuY2E+XG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIEZpbGU6IC9Vc2Vycy9tYXJ0aW5iZWNoYXJkL2Rldi9jbGF1ZGVleHQvc3JjL3VpL2NvbXBvbmVudHMvQ29udmVyc2F0aW9uUHJldmlldy50c1xuICovXG5cbmltcG9ydCB0eXBlIHsgQ2hhdE1lc3NhZ2UsIENoYXRNZXNzYWdlSW5wdXQgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IENvbnRlbnRQcmV2aWV3IH0gZnJvbSBcIi4vQ29udGVudFByZXZpZXdcIjtcblxuZXhwb3J0IGNsYXNzIENvbnZlcnNhdGlvblByZXZpZXcge1xuICBwcml2YXRlIGRpYWxvZzogSFRNTEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBwcml2YXRlIGNvbnRlbnQ6IEhUTUxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcHJpdmF0ZSBtZXNzYWdlc0NvbnRhaW5lcjogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpc09wZW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBjb250ZW50UHJldmlldzogQ29udGVudFByZXZpZXc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jcmVhdGVEaWFsb2coKTtcbiAgICB0aGlzLmNvbnRlbnRQcmV2aWV3ID0gbmV3IENvbnRlbnRQcmV2aWV3KCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgZGlhbG9nIHN0cnVjdHVyZVxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVEaWFsb2coKTogdm9pZCB7XG4gICAgLy8gQ3JlYXRlIGZsb2F0aW5nIGNvbnRhaW5lclxuICAgIHRoaXMuZGlhbG9nLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICB0b3A6IDUwJTtcbiAgICAgIGxlZnQ6IDUwJTtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgIHotaW5kZXg6IDEwMDAwMDM7XG4gICAgICBwb2ludGVyLWV2ZW50czogYXV0bztcbiAgICBgO1xuXG4gICAgLy8gQ3JlYXRlIGRpYWxvZyBjb250ZW50IGNvbnRhaW5lclxuICAgIHRoaXMuY29udGVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICB3aWR0aDogOTAlO1xuICAgICAgbWF4LXdpZHRoOiA4MDBweDtcbiAgICAgIG1heC1oZWlnaHQ6IDgwdmg7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgIGJveC1zaGFkb3c6IDAgNHB4IDEycHggcmdiYSgwLCAwLCAwLCAwLjE1KTtcbiAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIG1hcmdpbjogMjBweDtcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgIGA7XG5cbiAgICB0aGlzLmRpYWxvZy5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnQpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kaWFsb2cpO1xuXG4gICAgLy8gQ2xvc2Ugb24gZXNjYXBlIGtleVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgICBpZiAoZS5rZXkgPT09IFwiRXNjYXBlXCIgJiYgdGhpcy5pc09wZW4pIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBwcmV2aWV3IGRpYWxvZyB3aXRoIGNvbnZlcnNhdGlvbiBjb250ZW50XG4gICAqL1xuICBwdWJsaWMgc2hvdyhcbiAgICB0aXRsZTogc3RyaW5nLFxuICAgIG1lc3NhZ2VzOiBDaGF0TWVzc2FnZVtdLFxuICAgIGNvbnZlcnNhdGlvblVybD86IHN0cmluZyxcbiAgICBzY3JvbGxUb01lc3NhZ2VJZD86IHN0cmluZ1xuICApOiB2b2lkIHtcbiAgICAvLyBSZXNldCBjb250ZW50XG4gICAgdGhpcy5jb250ZW50LmlubmVySFRNTCA9IFwiXCI7XG5cbiAgICAvLyBDcmVhdGUgaGVhZGVyXG4gICAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBoZWFkZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBhZGRpbmc6IDE2cHggMjBweDtcbiAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZTVlNWU1O1xuICAgIGA7XG5cbiAgICBjb25zdCB0aXRsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDJcIik7XG4gICAgdGl0bGVFbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBtYXJnaW46IDA7XG4gICAgICBmb250LXNpemU6IDE4cHg7XG4gICAgICBmb250LXdlaWdodDogNjAwO1xuICAgICAgY29sb3I6ICMzMzM7XG4gICAgYDtcblxuICAgIC8vIE1ha2UgdGl0bGUgYSBsaW5rIGlmIFVSTCBpcyBwcm92aWRlZFxuICAgIGlmIChjb252ZXJzYXRpb25VcmwpIHtcbiAgICAgIGNvbnN0IHRpdGxlTGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgdGl0bGVMaW5rLmhyZWYgPSBjb252ZXJzYXRpb25Vcmw7XG4gICAgICB0aXRsZUxpbmsudGFyZ2V0ID0gXCJfYmxhbmtcIjtcbiAgICAgIHRpdGxlTGluay50ZXh0Q29udGVudCA9IHRpdGxlO1xuICAgICAgdGl0bGVMaW5rLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGNvbG9yOiBpbmhlcml0O1xuICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG4gICAgICAgIHRyYW5zaXRpb246IGNvbG9yIDAuMnMgZWFzZTtcbiAgICAgIGA7XG4gICAgICB0aXRsZUxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCAoKSA9PiB7XG4gICAgICAgIHRpdGxlTGluay5zdHlsZS5jb2xvciA9IFwiIzAwNjZjY1wiO1xuICAgICAgfSk7XG4gICAgICB0aXRsZUxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsICgpID0+IHtcbiAgICAgICAgdGl0bGVMaW5rLnN0eWxlLmNvbG9yID0gXCIjMzMzXCI7XG4gICAgICB9KTtcbiAgICAgIHRpdGxlRWxlbWVudC5hcHBlbmRDaGlsZCh0aXRsZUxpbmspO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZUVsZW1lbnQudGV4dENvbnRlbnQgPSB0aXRsZTtcbiAgICB9XG5cbiAgICAvLyBDb3VudCBhcnRpZmFjdHNcbiAgICBsZXQgYXJ0aWZhY3RDb3VudCA9IDA7XG4gICAgbWVzc2FnZXMuZm9yRWFjaCgobWVzc2FnZSkgPT4ge1xuICAgICAgbWVzc2FnZS5jb250ZW50LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJ0b29sX3VzZVwiICYmIGl0ZW0uaW5wdXQpIHtcbiAgICAgICAgICBhcnRpZmFjdENvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc3VidGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHN1YnRpdGxlLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICBjb2xvcjogIzY2NjtcbiAgICAgIG1hcmdpbi10b3A6IDRweDtcbiAgICBgO1xuICAgIHN1YnRpdGxlLnRleHRDb250ZW50ID0gYCR7bWVzc2FnZXMubGVuZ3RofSBtZXNzYWdlcywgJHthcnRpZmFjdENvdW50fSBhcnRpZmFjdHMgaW4gY29udmVyc2F0aW9uYDtcblxuICAgIGhlYWRlci5hcHBlbmRDaGlsZCh0aXRsZUVsZW1lbnQpO1xuICAgIGhlYWRlci5hcHBlbmRDaGlsZChzdWJ0aXRsZSk7XG5cbiAgICAvLyBDcmVhdGUgY2xvc2UgYnV0dG9uXG4gICAgY29uc3QgY2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGNsb3NlQnV0dG9uLmlubmVySFRNTCA9IFwiw5dcIjtcbiAgICBjbG9zZUJ1dHRvbi5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAxMnB4O1xuICAgICAgcmlnaHQ6IDEycHg7XG4gICAgICBmb250LXNpemU6IDI0cHg7XG4gICAgICBib3JkZXI6IG5vbmU7XG4gICAgICBiYWNrZ3JvdW5kOiBub25lO1xuICAgICAgY29sb3I6ICM2NjY7XG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICBwYWRkaW5nOiA0cHggOHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIGA7XG4gICAgY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCAoKSA9PiB7XG4gICAgICBjbG9zZUJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNmMGYwZjBcIjtcbiAgICB9KTtcbiAgICBjbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgKCkgPT4ge1xuICAgICAgY2xvc2VCdXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgIH0pO1xuICAgIGNsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLmNsb3NlKCkpO1xuXG4gICAgLy8gQ3JlYXRlIG1lc3NhZ2VzIGNvbnRhaW5lclxuICAgIHRoaXMubWVzc2FnZXNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMubWVzc2FnZXNDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgICAgZmxleDogMTtcbiAgICAgIG1pbi1oZWlnaHQ6IDIwMHB4O1xuICAgICAgbWF4LWhlaWdodDogY2FsYyg4MHZoIC0gMTAwcHgpO1xuICAgICAgc2Nyb2xsLWJlaGF2aW9yOiBzbW9vdGg7XG4gICAgYDtcblxuICAgIC8vIEFkZCBtZXNzYWdlc1xuICAgIG1lc3NhZ2VzLmZvckVhY2goKG1lc3NhZ2UpID0+IHtcbiAgICAgIGlmICh0aGlzLm1lc3NhZ2VzQ29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVNZXNzYWdlQnViYmxlKG1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEFzc2VtYmxlIGRpYWxvZ1xuICAgIHRoaXMuY29udGVudC5hcHBlbmRDaGlsZChjbG9zZUJ1dHRvbik7XG4gICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKGhlYWRlcik7XG4gICAgaWYgKHRoaXMubWVzc2FnZXNDb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLm1lc3NhZ2VzQ29udGFpbmVyKTtcbiAgICB9XG5cbiAgICAvLyBTaG93IGRpYWxvZyB3aXRoIGFuaW1hdGlvblxuICAgIHRoaXMuZGlhbG9nLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICB0aGlzLmRpYWxvZy5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmRpYWxvZy5zdHlsZS50cmFuc2l0aW9uID0gXCJvcGFjaXR5IDAuMnMgZWFzZS1vdXRcIjtcbiAgICAgIHRoaXMuZGlhbG9nLnN0eWxlLm9wYWNpdHkgPSBcIjFcIjtcblxuICAgICAgLy8gU2Nyb2xsIHRvIG1lc3NhZ2UgaWYgSUQgaXMgcHJvdmlkZWRcbiAgICAgIGlmIChzY3JvbGxUb01lc3NhZ2VJZCAmJiB0aGlzLm1lc3NhZ2VzQ29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VFbGVtZW50ID0gdGhpcy5tZXNzYWdlc0NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGAjbWVzc2FnZS0ke3Njcm9sbFRvTWVzc2FnZUlkfWBcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VFbGVtZW50KSB7XG4gICAgICAgICAgY29uc3QgaHRtbE1lc3NhZ2VFbGVtZW50ID0gbWVzc2FnZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgaHRtbE1lc3NhZ2VFbGVtZW50LnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgICAgIGJlaGF2aW9yOiBcInNtb290aFwiLFxuICAgICAgICAgICAgYmxvY2s6IFwiY2VudGVyXCIsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBIaWdobGlnaHQgdGhlIG1lc3NhZ2UgYnJpZWZseVxuICAgICAgICAgIGh0bWxNZXNzYWdlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gXCJiYWNrZ3JvdW5kLWNvbG9yIDAuNXMgZWFzZVwiO1xuICAgICAgICAgIGh0bWxNZXNzYWdlRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoMCwgMTAyLCAyMDQsIDAuMSlcIjtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGh0bWxNZXNzYWdlRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgICAgfSwgMTUwMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERlZmF1bHQ6IHNjcm9sbCB0byBib3R0b20gb2YgbWVzc2FnZXNcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZXNDb250YWluZXIpIHtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2VzQ29udGFpbmVyLnNjcm9sbFRvcCA9XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VzQ29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDApO1xuXG4gICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBtZXNzYWdlIGJ1YmJsZSBlbGVtZW50XG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZU1lc3NhZ2VCdWJibGUobWVzc2FnZTogQ2hhdE1lc3NhZ2UpOiBIVE1MRWxlbWVudCB7XG4gICAgY29uc3QgaXNIdW1hbiA9IG1lc3NhZ2Uuc2VuZGVyID09PSBcImh1bWFuXCI7XG5cbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICBhbGlnbi1pdGVtczogJHtpc0h1bWFuID8gXCJmbGV4LWVuZFwiIDogXCJmbGV4LXN0YXJ0XCJ9O1xuICAgICAgbWFyZ2luLWJvdHRvbTogMTZweDtcbiAgICBgO1xuICAgIGNvbnRhaW5lci5pZCA9IGBtZXNzYWdlLSR7bWVzc2FnZS51dWlkfWA7IC8vIEFkZCBtZXNzYWdlIElEXG5cbiAgICBjb25zdCBidWJibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJ1YmJsZS5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgbWF4LXdpZHRoOiA4MCU7XG4gICAgICBwYWRkaW5nOiA4cHggMTZweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAke1xuICAgICAgICBpc0h1bWFuXG4gICAgICAgICAgPyBgXG4gICAgICAgIGJhY2tncm91bmQ6ICMwMDY2Y2M7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6IDRweDtcbiAgICAgIGBcbiAgICAgICAgICA6IGBcbiAgICAgICAgYmFja2dyb3VuZDogI2YwZjBmMDtcbiAgICAgICAgY29sb3I6ICMzMzM7XG4gICAgICAgIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDRweDtcbiAgICAgIGBcbiAgICAgIH1cbiAgICBgO1xuXG4gICAgLy8gQWRkIG1lc3NhZ2UgY29udGVudFxuICAgIG1lc3NhZ2UuY29udGVudC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpZiAoaXRlbS50eXBlID09PSBcInRleHRcIiAmJiBpdGVtLnRleHQpIHtcbiAgICAgICAgY29uc3QgdGV4dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRleHREaXYuc3R5bGUud2hpdGVTcGFjZSA9IFwicHJlLXdyYXBcIjtcbiAgICAgICAgdGV4dERpdi50ZXh0Q29udGVudCA9IGl0ZW0udGV4dDtcbiAgICAgICAgYnViYmxlLmFwcGVuZENoaWxkKHRleHREaXYpO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLnR5cGUgPT09IFwidG9vbF91c2VcIiAmJiBpdGVtLmlucHV0KSB7XG4gICAgICAgIGNvbnN0IGFydGlmYWN0QnViYmxlID0gdGhpcy5jcmVhdGVBcnRpZmFjdEJ1YmJsZShpdGVtLmlucHV0KTtcbiAgICAgICAgYnViYmxlLmFwcGVuZENoaWxkKGFydGlmYWN0QnViYmxlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChidWJibGUpO1xuXG4gICAgLy8gQWRkIHRpbWVzdGFtcFxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGltZXN0YW1wLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBmb250LXNpemU6IDAuOGVtO1xuICAgICAgY29sb3I6ICM2NjY7XG4gICAgICBtYXJnaW4tdG9wOiA0cHg7XG4gICAgICAke2lzSHVtYW4gPyBcInRleHQtYWxpZ246IHJpZ2h0O1wiIDogXCJ0ZXh0LWFsaWduOiBsZWZ0O1wifVxuICAgIGA7XG5cbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUobWVzc2FnZS5jcmVhdGVkX2F0KTtcbiAgICB0aW1lc3RhbXAudGV4dENvbnRlbnQgPSBkYXRlLnRvTG9jYWxlU3RyaW5nKHVuZGVmaW5lZCwge1xuICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCJzaG9ydFwiLFxuICAgICAgZGF5OiBcIm51bWVyaWNcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICB9KTtcblxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aW1lc3RhbXApO1xuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc3VtbWFyeSBvZiBjaGFuZ2VzIGZvciB1cGRhdGUgYXJ0aWZhY3RzXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZUNoYW5nZXNTdW1tYXJ5KG9sZFN0cjogc3RyaW5nLCBuZXdTdHI6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgbWFyZ2luLXRvcDogOHB4O1xuICAgICAgZm9udC1zaXplOiAwLjllbTtcbiAgICAgIGNvbG9yOiAjNjY2O1xuICAgIGA7XG5cbiAgICBjb25zdCBvbGRMaW5lcyA9IG9sZFN0ci5zcGxpdChcIlxcblwiKTtcbiAgICBjb25zdCBuZXdMaW5lcyA9IG5ld1N0ci5zcGxpdChcIlxcblwiKTtcblxuICAgIGNvbnN0IHJlbW92ZWQgPSBvbGRMaW5lcy5maWx0ZXIoKGxpbmUpID0+ICFuZXdMaW5lcy5pbmNsdWRlcyhsaW5lKSkubGVuZ3RoO1xuICAgIGNvbnN0IGFkZGVkID0gbmV3TGluZXMuZmlsdGVyKChsaW5lKSA9PiAhb2xkTGluZXMuaW5jbHVkZXMobGluZSkpLmxlbmd0aDtcblxuICAgIGNvbnN0IHN1bW1hcnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHN1bW1hcnkuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDE2cHg7XG4gICAgICBtYXJnaW4tdG9wOiA4cHg7XG4gICAgYDtcblxuICAgIGlmIChhZGRlZCA+IDApIHtcbiAgICAgIGNvbnN0IGFkZGVkRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGFkZGVkRGl2LnN0eWxlLmNzc1RleHQgPSBcImNvbG9yOiAjMjhhNzQ1O1wiO1xuICAgICAgYWRkZWREaXYudGV4dENvbnRlbnQgPSBgKyR7YWRkZWR9IGFkZGVkYDtcbiAgICAgIHN1bW1hcnkuYXBwZW5kQ2hpbGQoYWRkZWREaXYpO1xuICAgIH1cblxuICAgIGlmIChyZW1vdmVkID4gMCkge1xuICAgICAgY29uc3QgcmVtb3ZlZERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICByZW1vdmVkRGl2LnN0eWxlLmNzc1RleHQgPSBcImNvbG9yOiAjZGMzNTQ1O1wiO1xuICAgICAgcmVtb3ZlZERpdi50ZXh0Q29udGVudCA9IGAke3JlbW92ZWR9IHJlbW92ZWRgO1xuICAgICAgc3VtbWFyeS5hcHBlbmRDaGlsZChyZW1vdmVkRGl2KTtcbiAgICB9XG5cbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc3VtbWFyeSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93cyBhcnRpZmFjdCBjb250ZW50IGluIGEgc2VwYXJhdGUgcHJldmlldyB3aW5kb3dcbiAgICovXG4gIHByaXZhdGUgc2hvd0FydGlmYWN0Q29udGVudChpbnB1dDogQ2hhdE1lc3NhZ2VJbnB1dCk6IHZvaWQge1xuICAgIGNvbnN0IGlzVXBkYXRlID0gaW5wdXQuY29tbWFuZCA9PT0gXCJ1cGRhdGVcIjtcblxuICAgIGlmIChpc1VwZGF0ZSkge1xuICAgICAgLy8gRm9yIHVwZGF0ZXMsIHNob3cgYSBkaWZmIHZpZXdcbiAgICAgIGNvbnN0IGRpZmZDb250ZW50ID0gdGhpcy5jcmVhdGVEaWZmRGlzcGxheShcbiAgICAgICAgaW5wdXQub2xkX3N0ciB8fCBcIlwiLFxuICAgICAgICBpbnB1dC5uZXdfc3RyIHx8IFwiXCJcbiAgICAgICk7XG4gICAgICBjb25zdCBmaWxlTmFtZSA9IGlucHV0LnRpdGxlXG4gICAgICAgID8gaW5wdXQudGl0bGUgKyBcIiAoVXBkYXRlKVwiXG4gICAgICAgIDogXCJhcnRpZmFjdC11cGRhdGVcIjtcblxuICAgICAgdGhpcy5jb250ZW50UHJldmlldy5zaG93KGZpbGVOYW1lLCBkaWZmQ29udGVudCwgZmlsZU5hbWUgKyBcIi5kaWZmXCIpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQuY29udGVudCkge1xuICAgICAgLy8gRm9yIHJlZ3VsYXIgYXJ0aWZhY3RzLCBzaG93IHRoZSBjb250ZW50XG4gICAgICBjb25zdCBleHRlbnNpb24gPSBpbnB1dC5sYW5ndWFnZVxuICAgICAgICA/IHRoaXMuZ2V0RmlsZUV4dGVuc2lvbihpbnB1dC5sYW5ndWFnZSlcbiAgICAgICAgOiBcIi50eHRcIjtcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gaW5wdXQudGl0bGVcbiAgICAgICAgPyBpbnB1dC50aXRsZS5lbmRzV2l0aChleHRlbnNpb24pXG4gICAgICAgICAgPyBpbnB1dC50aXRsZVxuICAgICAgICAgIDogaW5wdXQudGl0bGUgKyBleHRlbnNpb25cbiAgICAgICAgOiBcImFydGlmYWN0XCIgKyBleHRlbnNpb247XG5cbiAgICAgIHRoaXMuY29udGVudFByZXZpZXcuc2hvdyhmaWxlTmFtZSwgaW5wdXQuY29udGVudCwgZmlsZU5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZGlmZiBkaXNwbGF5IGZvciB1cGRhdGUgYXJ0aWZhY3RzXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZURpZmZEaXNwbGF5KG9sZFN0cjogc3RyaW5nLCBuZXdTdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3Qgb2xkTGluZXMgPSBvbGRTdHIuc3BsaXQoXCJcXG5cIik7XG4gICAgY29uc3QgbmV3TGluZXMgPSBuZXdTdHIuc3BsaXQoXCJcXG5cIik7XG4gICAgY29uc3QgZGlmZjogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFNpbXBsZSBkaWZmIGRpc3BsYXlcbiAgICBkaWZmLnB1c2goXCItLS0gUHJldmlvdXMgdmVyc2lvblwiKTtcbiAgICBkaWZmLnB1c2goXCIrKysgTmV3IHZlcnNpb25cIik7XG4gICAgZGlmZi5wdXNoKFwiXCIpO1xuXG4gICAgLy8gU2hvdyByZW1vdmVkIGxpbmVzXG4gICAgb2xkTGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgaWYgKCFuZXdMaW5lcy5pbmNsdWRlcyhsaW5lKSkge1xuICAgICAgICBkaWZmLnB1c2goXCItIFwiICsgbGluZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaG93IGFkZGVkIGxpbmVzXG4gICAgbmV3TGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgaWYgKCFvbGRMaW5lcy5pbmNsdWRlcyhsaW5lKSkge1xuICAgICAgICBkaWZmLnB1c2goXCIrIFwiICsgbGluZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZGlmZi5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYXBwcm9wcmlhdGUgZmlsZSBleHRlbnNpb24gYmFzZWQgb24gbGFuZ3VhZ2VcbiAgICovXG4gIHByaXZhdGUgZ2V0RmlsZUV4dGVuc2lvbihsYW5ndWFnZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBleHRlbnNpb25NYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICB0eXBlc2NyaXB0OiBcIi50c1wiLFxuICAgICAgamF2YXNjcmlwdDogXCIuanNcIixcbiAgICAgIHB5dGhvbjogXCIucHlcIixcbiAgICAgIGphdmE6IFwiLmphdmFcIixcbiAgICAgIFwidGV4dC9tYXJrZG93blwiOiBcIi5tZFwiLFxuICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IFwiLmpzb25cIixcbiAgICAgIGh0bWw6IFwiLmh0bWxcIixcbiAgICAgIGNzczogXCIuY3NzXCIsXG4gICAgICBcInRleHQvaHRtbFwiOiBcIi5odG1sXCIsXG4gICAgICBcImFwcGxpY2F0aW9uL3ZuZC5hbnQuY29kZVwiOiBcIi50eHRcIixcbiAgICAgIFwiYXBwbGljYXRpb24vdm5kLmFudC5yZWFjdFwiOiBcIi50c3hcIixcbiAgICAgIFwiYXBwbGljYXRpb24vdm5kLmFudC5tZXJtYWlkXCI6IFwiLm1tZFwiLFxuICAgICAgXCJpbWFnZS9zdmcreG1sXCI6IFwiLnN2Z1wiLFxuICAgIH07XG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uTWFwW2xhbmd1YWdlLnRvTG93ZXJDYXNlKCldIHx8IFwiLnR4dFwiO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJ0aWZhY3QgYnViYmxlIGZvciBtZXNzYWdlc1xuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVBcnRpZmFjdEJ1YmJsZShpbnB1dDogQ2hhdE1lc3NhZ2VJbnB1dCk6IEhUTUxFbGVtZW50IHtcbiAgICBjb25zdCBhcnRpZmFjdENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgYXJ0aWZhY3RDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGJhY2tncm91bmQ6ICNmOGY4Zjg7XG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgcGFkZGluZzogMTJweDtcbiAgICAgIG1hcmdpbjogOHB4IDA7XG4gICAgYDtcblxuICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aXRsZS5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICBjb2xvcjogIzMzMztcbiAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgZ2FwOiA4cHg7XG4gICAgYDtcblxuICAgIGNvbnN0IGlzVXBkYXRlID0gaW5wdXQuY29tbWFuZCA9PT0gXCJ1cGRhdGVcIjtcblxuICAgIGNvbnN0IHRpdGxlVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHRpdGxlVGV4dC50ZXh0Q29udGVudCA9IGBBcnRpZmFjdDogJHtpbnB1dC50aXRsZSB8fCBcIlVudGl0bGVkXCJ9YDtcbiAgICB0aXRsZS5hcHBlbmRDaGlsZCh0aXRsZVRleHQpO1xuXG4gICAgaWYgKGlzVXBkYXRlKSB7XG4gICAgICBjb25zdCB1cGRhdGVCYWRnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgdXBkYXRlQmFkZ2Uuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgYmFja2dyb3VuZDogIzAwNjZjYztcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBwYWRkaW5nOiAycHggNnB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMC44ZW07XG4gICAgICBgO1xuICAgICAgdXBkYXRlQmFkZ2UudGV4dENvbnRlbnQgPSBcIlVQREFURVwiO1xuICAgICAgdGl0bGUuYXBwZW5kQ2hpbGQodXBkYXRlQmFkZ2UpO1xuICAgIH1cblxuICAgIGFydGlmYWN0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRpdGxlKTtcblxuICAgIGlmIChpbnB1dC5sYW5ndWFnZSkge1xuICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgbGFuZ3VhZ2Uuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgY29sb3I6ICM2NjY7XG4gICAgICAgIGZvbnQtc2l6ZTogMC45ZW07XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcbiAgICAgIGA7XG4gICAgICBsYW5ndWFnZS50ZXh0Q29udGVudCA9IGBMYW5ndWFnZTogJHtpbnB1dC5sYW5ndWFnZX1gO1xuICAgICAgYXJ0aWZhY3RDb250YWluZXIuYXBwZW5kQ2hpbGQobGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGJ1dHRvbi1saWtlIGNvbnRhaW5lciBmb3IgdGhlIGFydGlmYWN0IHByZXZpZXdcbiAgICBjb25zdCBwcmV2aWV3QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBwcmV2aWV3QnV0dG9uLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBiYWNrZ3JvdW5kOiAjZWVlO1xuICAgICAgcGFkZGluZzogMTJweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XG4gICAgICBmb250LXNpemU6IDAuOWVtO1xuICAgICAgY29sb3I6ICM2NjY7XG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICB0cmFuc2l0aW9uOiBhbGwgMC4ycyBlYXNlO1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIGdhcDogOHB4O1xuICAgICAgYm9yZGVyOiAxcHggc29saWQgI2RkZDtcbiAgICBgO1xuXG4gICAgLy8gQWRkIGFuIGljb25cbiAgICBjb25zdCBpY29uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgaWNvbi50ZXh0Q29udGVudCA9IGlzVXBkYXRlID8gXCLwn5SEXCIgOiBcIvCfkYHvuI9cIjsgLy8gVXBkYXRlIG9yIGV5ZSBpY29uXG4gICAgaWNvbi5zdHlsZS5mb250U2l6ZSA9IFwiMS4xZW1cIjtcbiAgICBwcmV2aWV3QnV0dG9uLmFwcGVuZENoaWxkKGljb24pO1xuXG4gICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHRleHQudGV4dENvbnRlbnQgPSBpc1VwZGF0ZVxuICAgICAgPyBcIkNsaWNrIHRvIHZpZXcgY2hhbmdlc1wiXG4gICAgICA6IFwiQ2xpY2sgdG8gdmlldyBhcnRpZmFjdCBjb250ZW50XCI7XG4gICAgcHJldmlld0J1dHRvbi5hcHBlbmRDaGlsZCh0ZXh0KTtcblxuICAgIC8vIEFkZCBob3ZlciBlZmZlY3RcbiAgICBwcmV2aWV3QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgKCkgPT4ge1xuICAgICAgcHJldmlld0J1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNlMGUwZTBcIjtcbiAgICAgIHByZXZpZXdCdXR0b24uc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKC0xcHgpXCI7XG4gICAgfSk7XG4gICAgcHJldmlld0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgKCkgPT4ge1xuICAgICAgcHJldmlld0J1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNlZWVcIjtcbiAgICAgIHByZXZpZXdCdXR0b24uc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGVZKDApXCI7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgY2xpY2sgaGFuZGxlclxuICAgIHByZXZpZXdCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpOyAvLyBQcmV2ZW50IGV2ZW50IGJ1YmJsaW5nXG4gICAgICB0aGlzLnNob3dBcnRpZmFjdENvbnRlbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYXJ0aWZhY3RDb250YWluZXIuYXBwZW5kQ2hpbGQocHJldmlld0J1dHRvbik7XG5cbiAgICAvLyBGb3IgdXBkYXRlcywgc2hvdyBhIHN1bW1hcnkgb2YgY2hhbmdlc1xuICAgIGlmIChpc1VwZGF0ZSAmJiBpbnB1dC5vbGRfc3RyICYmIGlucHV0Lm5ld19zdHIpIHtcbiAgICAgIGNvbnN0IGNoYW5nZXNTdW1tYXJ5ID0gdGhpcy5jcmVhdGVDaGFuZ2VzU3VtbWFyeShcbiAgICAgICAgaW5wdXQub2xkX3N0cixcbiAgICAgICAgaW5wdXQubmV3X3N0clxuICAgICAgKTtcbiAgICAgIGFydGlmYWN0Q29udGFpbmVyLmFwcGVuZENoaWxkKGNoYW5nZXNTdW1tYXJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJ0aWZhY3RDb250YWluZXI7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBwcmV2aWV3IGRpYWxvZ1xuICAgKi9cbiAgcHVibGljIGNsb3NlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc09wZW4pIHJldHVybjtcblxuICAgIHRoaXMuZGlhbG9nLnN0eWxlLm9wYWNpdHkgPSBcIjBcIjtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZGlhbG9nLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIHRoaXMuY29udGVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgdGhpcy5tZXNzYWdlc0NvbnRhaW5lciA9IG51bGw7XG4gICAgfSwgMjAwKTtcblxuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW5zIHVwIHRoZSBjb21wb25lbnRcbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuZGlhbG9nLnJlbW92ZSgpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogL1VzZXJzL21hcnRpbmJlY2hhcmQvZGV2L2NsYXVkZWV4dC9zcmMvdWkvY29tcG9uZW50cy9Eb3dubG9hZFRhYmxlLnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKlxuICogQSByZXVzYWJsZSBjb21wb25lbnQgZm9yIGRpc3BsYXlpbmcgYW5kIG1hbmFnaW5nIGRvd25sb2FkYWJsZSBkb2N1bWVudHMgd2l0aCBwYXRoIGVkaXRpbmdcbiAqIE5vdGU6IE1ha2luZyBkb2N1bWVudCBtYW5hZ2VtZW50IGEgYnJlZXplIHNpbmNlIDIwMjQhXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBEb2N1bWVudEluZm8sIFNlYXJjaFJlc3VsdEluZm8gfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IERvY3VtZW50RG93bmxvYWQgfSBmcm9tIFwiLi4vLi4vc2VydmljZXMvRG9jdW1lbnREb3dubG9hZFwiO1xuaW1wb3J0IHsgQ29udmVyc2F0aW9uUHJldmlldyB9IGZyb20gXCIuL0NvbnZlcnNhdGlvblByZXZpZXdcIjtcbmltcG9ydCB7IENvbnRlbnRQcmV2aWV3IH0gZnJvbSBcIi4vQ29udGVudFByZXZpZXdcIjtcbmltcG9ydCB7IENvbnZlcnNhdGlvblJldHJpZXZhbCB9IGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9Db252ZXJzYXRpb25SZXRyaWV2YWxcIjtcbmltcG9ydCB7IGdldE9yZ2FuaXphdGlvbklkIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2dldENsYXVkZUlkc1wiO1xuaW1wb3J0IHsgUHJvamVjdFNlYXJjaFNlcnZpY2UgfSBmcm9tIFwiLi4vLi4vc2VydmljZXMvUHJvamVjdFNlYXJjaFNlcnZpY2VcIjtcbmltcG9ydCB7IFNlYXJjaFJlc3VsdFByZXZpZXcgfSBmcm9tIFwiLi9TZWFyY2hSZXN1bHRQcmV2aWV3XCI7XG5pbXBvcnQge1xuICBjcmVhdGVCdXR0b24sXG4gIGNyZWF0ZUJ1dHRvbkNvbnRhaW5lcixcbiAgY3JlYXRlVGFibGVDZWxsLFxuICBjcmVhdGVDaGVja2JveENlbGwsXG4gIGNyZWF0ZUVtcHR5U3RhdGUsXG4gIGNyZWF0ZU5hbWVDZWxsLFxuICBjcmVhdGVTZWFyY2hSZXN1bHRDZWxsLFxuICBjcmVhdGVEYXRlQ2VsbCxcbn0gZnJvbSBcIi4vRG93bmxvYWRXaWRnZXRzXCI7XG5cbi8qKlxuICogU29ydCBkaXJlY3Rpb24gZm9yIHRhYmxlIGNvbHVtbnNcbiAqL1xudHlwZSBTb3J0RGlyZWN0aW9uID0gXCJhc2NcIiB8IFwiZGVzY1wiIHwgbnVsbDtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciB0YWJsZSBjb2x1bW5zXG4gKi9cbnR5cGUgVGFibGVDb25maWcgPSB7XG4gIGlkOiBzdHJpbmc7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIHdpZHRoPzogc3RyaW5nO1xuICBzb3J0YWJsZT86IGJvb2xlYW47XG59O1xuXG4vKipcbiAqIENvbXBvbmVudCBmb3IgZGlzcGxheWluZyBhbmQgbWFuYWdpbmcgZG93bmxvYWRhYmxlIGRvY3VtZW50cyBpbiBhIHRhYmxlIGZvcm1hdFxuICovXG5leHBvcnQgY2xhc3MgRG93bmxvYWRUYWJsZSB7XG4gIHByaXZhdGUgaXRlbXM6IERvY3VtZW50SW5mb1tdO1xuICBwcml2YXRlIHJlYWRvbmx5IGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgcHJldmlld0RpYWxvZzogQ29udmVyc2F0aW9uUHJldmlldztcbiAgcHJpdmF0ZSByZWFkb25seSBjb250ZW50UHJldmlldzogQ29udGVudFByZXZpZXc7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2VhcmNoUmVzdWx0UHJldmlldzogU2VhcmNoUmVzdWx0UHJldmlldztcbiAgcHJpdmF0ZSByZWFkb25seSBzaG93UmVzdWx0czogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBzaG93Q2FuY2VsQnV0dG9uOiBib29sZWFuO1xuICBwcml2YXRlIGN1cnJlbnRUYWJsZTogSFRNTFRhYmxlRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGN1cnJlbnRTb3J0Q29sdW1uOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBjdXJyZW50U29ydERpcmVjdGlvbjogU29ydERpcmVjdGlvbiA9IG51bGw7XG4gIHByaXZhdGUgdGJvZHk6IEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgcHJvY2Vzc2VkUm93czogU2V0PHN0cmluZz4gPSBuZXcgU2V0KCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgICBpdGVtc09yU2hvd1Jlc3VsdHM6IERvY3VtZW50SW5mb1tdIHwgYm9vbGVhbiA9IGZhbHNlLFxuICAgIHNob3dDYW5jZWxCdXR0b246IGJvb2xlYW4gPSB0cnVlXG4gICkge1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgLy8gSGFuZGxlIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtc09yU2hvd1Jlc3VsdHMpKSB7XG4gICAgICB0aGlzLml0ZW1zID0gaXRlbXNPclNob3dSZXN1bHRzO1xuICAgICAgdGhpcy5zaG93UmVzdWx0cyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICB0aGlzLnNob3dSZXN1bHRzID0gaXRlbXNPclNob3dSZXN1bHRzO1xuICAgIH1cblxuICAgIHRoaXMuc2hvd0NhbmNlbEJ1dHRvbiA9IHNob3dDYW5jZWxCdXR0b247XG4gICAgdGhpcy5wcmV2aWV3RGlhbG9nID0gbmV3IENvbnZlcnNhdGlvblByZXZpZXcoKTtcbiAgICB0aGlzLmNvbnRlbnRQcmV2aWV3ID0gbmV3IENvbnRlbnRQcmV2aWV3KCk7XG5cbiAgICAvLyBJbml0aWFsaXplIFNlYXJjaFJlc3VsdFByZXZpZXcgd2l0aCBjb252ZXJzYXRpb24gcHJldmlldyBjYWxsYmFja1xuICAgIHRoaXMuc2VhcmNoUmVzdWx0UHJldmlldyA9IG5ldyBTZWFyY2hSZXN1bHRQcmV2aWV3KFxuICAgICAgYXN5bmMgKGNvbnZlcnNhdGlvbklkLCBtZXNzYWdlSWQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBvcmdJZCA9IGdldE9yZ2FuaXphdGlvbklkKCk7XG4gICAgICAgICAgaWYgKCFvcmdJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGdldCBvcmdhbml6YXRpb24gSURcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IGF3YWl0IENvbnZlcnNhdGlvblJldHJpZXZhbC5nZXRDb252ZXJzYXRpb24oXG4gICAgICAgICAgICBvcmdJZCxcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbklkLFxuICAgICAgICAgICAgdHJ1ZSAvLyBGb3JjZSByZWZyZXNoXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLnByZXZpZXdEaWFsb2cuc2hvdyhcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5uYW1lIHx8IFwiQ29udmVyc2F0aW9uIFByZXZpZXdcIixcbiAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5jaGF0X21lc3NhZ2VzLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWVzc2FnZUlkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgY29udmVyc2F0aW9uOlwiLCBlcnJvcik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy5pbml0aWFsaXplVGFibGUoKTtcblxuICAgIC8vIElmIGl0ZW1zIHdlcmUgcHJvdmlkZWQsIGFkZCB0aGVtIGFsbCBhdCBvbmNlXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXNPclNob3dSZXN1bHRzKSkge1xuICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLmNyZWF0ZUl0ZW1Sb3coaXRlbSwgaW5kZXgpO1xuICAgICAgICB0aGlzLnRib2R5Py5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIHJvdyBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICovXG4gIHB1YmxpYyBpc1Jvd1Byb2Nlc3NlZChjb252ZXJzYXRpb25JZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc2VkUm93cy5oYXMoY29udmVyc2F0aW9uSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSB0YWJsZSB3aXRoIGp1c3QgdGhlIGhlYWRlcnNcbiAgICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZVRhYmxlKCk6IHZvaWQge1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG5cbiAgICAvLyBBZGQgY2FuY2VsIGJ1dHRvbiBiZWZvcmUgdGhlIHRhYmxlIGlmIHNob3dpbmcgcmVzdWx0cyBhbmQgY2FuY2VsIGJ1dHRvbiBpcyBlbmFibGVkXG4gICAgaWYgKHRoaXMuc2hvd1Jlc3VsdHMgJiYgdGhpcy5zaG93Q2FuY2VsQnV0dG9uKSB7XG4gICAgICBjb25zdCBjYW5jZWxCdXR0b24gPSBjcmVhdGVCdXR0b24oXG4gICAgICAgIFwiQ2FuY2VsXCIsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBQcm9qZWN0U2VhcmNoU2VydmljZS5hYm9ydFNlYXJjaCgpO1xuICAgICAgICB9LFxuICAgICAgICB7IHZhcmlhbnQ6IFwiZGFuZ2VyXCIgfVxuICAgICAgKTtcbiAgICAgIGNhbmNlbEJ1dHRvbi5zdHlsZS5tYXJnaW5Cb3R0b20gPSBcIjEwcHhcIjtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbmNlbEJ1dHRvbik7XG4gICAgfVxuXG4gICAgY29uc3QgdGFibGUgPSB0aGlzLmNyZWF0ZVRhYmxlKCk7XG4gICAgY29uc3QgaGVhZGVyUm93ID0gdGhpcy5jcmVhdGVUYWJsZUhlYWRlcih0YWJsZSk7XG4gICAgdGFibGUuYXBwZW5kQ2hpbGQoaGVhZGVyUm93KTtcbiAgICB0aGlzLnRib2R5ID0gdGFibGUuY3JlYXRlVEJvZHkoKTtcbiAgICB0YWJsZS5hcHBlbmRDaGlsZCh0aGlzLnRib2R5KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0YWJsZSk7XG4gICAgdGhpcy5jdXJyZW50VGFibGUgPSB0YWJsZTtcbiAgICB0aGlzLmFkZERvd25sb2FkQnV0dG9ucygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgcm93IHRvIHRoZSB0YWJsZVxuICAgKi9cbiAgcHVibGljIGFkZFJvdyhpdGVtOiBEb2N1bWVudEluZm8pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMudGJvZHkpIHJldHVybjtcblxuICAgIHRoaXMuaXRlbXMucHVzaChpdGVtKTtcbiAgICBjb25zdCByb3cgPSB0aGlzLmNyZWF0ZUl0ZW1Sb3coaXRlbSwgdGhpcy5pdGVtcy5sZW5ndGggLSAxKTtcbiAgICB0aGlzLnRib2R5LmFwcGVuZENoaWxkKHJvdyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBhIHNpbmdsZSByb3cncyBzZWFyY2ggcmVzdWx0IGNlbGxcbiAgICovXG4gIHB1YmxpYyB1cGRhdGVTZWFyY2hSZXN1bHQoXG4gICAgY29udmVyc2F0aW9uSWQ6IHN0cmluZyxcbiAgICBzZWFyY2hSZXN1bHQ6IFNlYXJjaFJlc3VsdEluZm8gfCB1bmRlZmluZWQsXG4gICAgZXJyb3I/OiBzdHJpbmcsXG4gICAgc2VsZWN0OiBib29sZWFuID0gZmFsc2VcbiAgKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnRUYWJsZSkgcmV0dXJuO1xuXG4gICAgLy8gTWFyayByb3cgYXMgcHJvY2Vzc2VkIHVubGVzcyBpdCdzIGluIFwiV29ya2luZy4uLlwiIHN0YXRlXG4gICAgaWYgKGVycm9yICE9PSBcIldvcmtpbmcuLi5cIikge1xuICAgICAgdGhpcy5wcm9jZXNzZWRSb3dzLmFkZChjb252ZXJzYXRpb25JZCk7XG4gICAgfVxuXG4gICAgY29uc3Qgcm93ID0gdGhpcy5jdXJyZW50VGFibGUucXVlcnlTZWxlY3RvcihcbiAgICAgIGB0cltkYXRhLWNvbnZlcnNhdGlvbi1pZD1cIiR7Y29udmVyc2F0aW9uSWR9XCJdYFxuICAgICk7XG4gICAgaWYgKCFyb3cpIHJldHVybjtcblxuICAgIC8vIEZpbmQgdGhlIHNlYXJjaCByZXN1bHQgY2VsbCAodGhpcmQgY2VsbCwgaW5kZXggMilcbiAgICBjb25zdCBvbGRDZWxsID0gcm93LmNoaWxkcmVuWzJdIGFzIEhUTUxUYWJsZUNlbGxFbGVtZW50O1xuICAgIGlmICghb2xkQ2VsbCkgcmV0dXJuO1xuXG4gICAgLy8gQ3JlYXRlIG5ldyBjZWxsIHdpdGggZXJyb3IgaWYgcHJvdmlkZWRcbiAgICBjb25zdCBuZXdDZWxsID0gZXJyb3JcbiAgICAgID8gY3JlYXRlU2VhcmNoUmVzdWx0Q2VsbCh1bmRlZmluZWQsIGVycm9yLCB0aGlzLnNlYXJjaFJlc3VsdFByZXZpZXcpXG4gICAgICA6IGNyZWF0ZVNlYXJjaFJlc3VsdENlbGwoXG4gICAgICAgICAgc2VhcmNoUmVzdWx0LFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB0aGlzLnNlYXJjaFJlc3VsdFByZXZpZXdcbiAgICAgICAgKTtcbiAgICBvbGRDZWxsLnJlcGxhY2VXaXRoKG5ld0NlbGwpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSBpdGVtIGluIG91ciBpdGVtcyBhcnJheVxuICAgIGNvbnN0IGl0ZW1JbmRleCA9IHRoaXMuaXRlbXMuZmluZEluZGV4KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0ubWV0YWRhdGE/LmNvbnZlcnNhdGlvbklkID09PSBjb252ZXJzYXRpb25JZFxuICAgICk7XG4gICAgaWYgKGl0ZW1JbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuaXRlbXNbaXRlbUluZGV4XSA9IHtcbiAgICAgICAgLi4udGhpcy5pdGVtc1tpdGVtSW5kZXhdLFxuICAgICAgICBzZWFyY2hSZXN1bHQsXG4gICAgICAgIGlzU2VsZWN0ZWQ6IHNlbGVjdCAmJiAhIXNlYXJjaFJlc3VsdCxcbiAgICAgIH07XG5cbiAgICAgIC8vIFVwZGF0ZSBjaGVja2JveCBpZiB0aGVyZSdzIGEgcmVzdWx0XG4gICAgICBjb25zdCBjaGVja2JveCA9IHJvdy5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJ1xuICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgaWYgKGNoZWNrYm94KSB7XG4gICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSBzZWxlY3QgJiYgISFzZWFyY2hSZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY29uZmlndXJhdGlvbiBmb3IgdGFibGUgaGVhZGVyc1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRUYWJsZUhlYWRlcnMoKTogVGFibGVDb25maWdbXSB7XG4gICAgY29uc3QgYmFzZUhlYWRlcnM6IFRhYmxlQ29uZmlnW10gPSBbXG4gICAgICB7IGlkOiBcImNoZWNrYm94XCIsIGxhYmVsOiBcIlwiLCB3aWR0aDogXCI0MHB4XCIsIHNvcnRhYmxlOiBmYWxzZSB9LFxuICAgICAgeyBpZDogXCJmaWxlTmFtZVwiLCBsYWJlbDogXCJOYW1lXCIsIHdpZHRoOiBcIjI1JVwiLCBzb3J0YWJsZTogdHJ1ZSB9LFxuICAgIF07XG5cbiAgICBpZiAodGhpcy5zaG93UmVzdWx0cykge1xuICAgICAgYmFzZUhlYWRlcnMucHVzaCh7XG4gICAgICAgIGlkOiBcInNlYXJjaFJlc3VsdFwiLFxuICAgICAgICBsYWJlbDogXCJSZXN1bHRzXCIsXG4gICAgICAgIHNvcnRhYmxlOiBmYWxzZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGJhc2VIZWFkZXJzLnB1c2goXG4gICAgICB7IGlkOiBcImNyZWF0ZWRcIiwgbGFiZWw6IFwiQ3JlYXRlZFwiLCB3aWR0aDogXCIxODBweFwiLCBzb3J0YWJsZTogdHJ1ZSB9LFxuICAgICAgeyBpZDogXCJ1cGRhdGVkXCIsIGxhYmVsOiBcIlVwZGF0ZWRcIiwgd2lkdGg6IFwiMTgwcHhcIiwgc29ydGFibGU6IHRydWUgfSxcbiAgICAgIHsgaWQ6IFwiZmlsZVBhdGhcIiwgbGFiZWw6IFwiUGF0aFwiLCBzb3J0YWJsZTogdHJ1ZSB9XG4gICAgKTtcblxuICAgIHJldHVybiBiYXNlSGVhZGVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHRhYmxlIGVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlVGFibGUoKTogSFRNTFRhYmxlRWxlbWVudCB7XG4gICAgY29uc3QgdGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGFibGVcIik7XG4gICAgdGFibGUuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICB0YWJsZS5zdHlsZS5ib3JkZXJDb2xsYXBzZSA9IFwiY29sbGFwc2VcIjtcbiAgICB0YWJsZS5zdHlsZS5tYXJnaW5Ub3AgPSBcIjEwcHhcIjtcbiAgICByZXR1cm4gdGFibGU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgdGFibGUgaGVhZGVyIHNlY3Rpb24gd2l0aCBzb3J0aW5nXG4gICAqL1xuICBwcml2YXRlIGNyZWF0ZVRhYmxlSGVhZGVyKHRhYmxlOiBIVE1MVGFibGVFbGVtZW50KTogSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQge1xuICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0aGVhZFwiKTtcbiAgICBjb25zdCBoZWFkZXJSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidHJcIik7XG5cbiAgICB0aGlzLmdldFRhYmxlSGVhZGVycygpLmZvckVhY2goKGNvbmZpZykgPT4ge1xuICAgICAgY29uc3QgdGggPSBjcmVhdGVUYWJsZUNlbGwodHJ1ZSk7XG4gICAgICBpZiAoY29uZmlnLndpZHRoKSB7XG4gICAgICAgIHRoLnN0eWxlLndpZHRoID0gY29uZmlnLndpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLmlkID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgY29uc3QgY2hlY2tib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGNoZWNrYm94LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+XG4gICAgICAgICAgdGhpcy5oYW5kbGVIZWFkZXJDaGVja2JveChlLCB0YWJsZSlcbiAgICAgICAgKTtcbiAgICAgICAgdGguYXBwZW5kQ2hpbGQoY2hlY2tib3gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3JlYXRlIGhlYWRlciBjb250ZW50IGNvbnRhaW5lclxuICAgICAgICBjb25zdCBoZWFkZXJDb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgaGVhZGVyQ29udGVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICBnYXA6IDRweDtcbiAgICAgICAgICAke2NvbmZpZy5zb3J0YWJsZSA/IFwiY3Vyc29yOiBwb2ludGVyO1wiIDogXCJcIn1cbiAgICAgICAgICBwYWRkaW5nOiA0cHg7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4ycyBlYXNlO1xuICAgICAgICBgO1xuXG4gICAgICAgIC8vIEFkZCBsYWJlbFxuICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBsYWJlbC50ZXh0Q29udGVudCA9IGNvbmZpZy5sYWJlbDtcbiAgICAgICAgaGVhZGVyQ29udGVudC5hcHBlbmRDaGlsZChsYWJlbCk7XG5cbiAgICAgICAgLy8gQWRkIHNvcnQgaW5kaWNhdG9yIGlmIHNvcnRhYmxlXG4gICAgICAgIGlmIChjb25maWcuc29ydGFibGUpIHtcbiAgICAgICAgICBjb25zdCBzb3J0SW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgc29ydEluZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgICAgZm9udC1zaXplOiAwLjhlbTtcbiAgICAgICAgICAgIG9wYWNpdHk6ICR7dGhpcy5jdXJyZW50U29ydENvbHVtbiA9PT0gY29uZmlnLmlkID8gXCIxXCIgOiBcIjAuM1wifTtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBlYXNlO1xuICAgICAgICAgIGA7XG4gICAgICAgICAgc29ydEluZGljYXRvci50ZXh0Q29udGVudCA9IHRoaXMuZ2V0U29ydEluZGljYXRvcihjb25maWcuaWQpO1xuICAgICAgICAgIGhlYWRlckNvbnRlbnQuYXBwZW5kQ2hpbGQoc29ydEluZGljYXRvcik7XG5cbiAgICAgICAgICAvLyBBZGQgY2xpY2sgaGFuZGxlciBmb3Igc29ydGluZ1xuICAgICAgICAgIGhlYWRlckNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNvcnQoY29uZmlnLmlkKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBBZGQgaG92ZXIgZWZmZWN0XG4gICAgICAgICAgaGVhZGVyQ29udGVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsICgpID0+IHtcbiAgICAgICAgICAgIGhlYWRlckNvbnRlbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjZjBmMGYwXCI7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaGVhZGVyQ29udGVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgaGVhZGVyQ29udGVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aC5hcHBlbmRDaGlsZChoZWFkZXJDb250ZW50KTtcbiAgICAgIH1cblxuICAgICAgaGVhZGVyUm93LmFwcGVuZENoaWxkKHRoKTtcbiAgICB9KTtcblxuICAgIGhlYWRlci5hcHBlbmRDaGlsZChoZWFkZXJSb3cpO1xuICAgIHJldHVybiBoZWFkZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc29ydCBpbmRpY2F0b3Igc3ltYm9sIGJhc2VkIG9uIGN1cnJlbnQgc29ydCBzdGF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBnZXRTb3J0SW5kaWNhdG9yKGNvbHVtbklkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTb3J0Q29sdW1uICE9PSBjb2x1bW5JZCkgcmV0dXJuIFwi4oaVXCI7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNvcnREaXJlY3Rpb24gPT09IFwiYXNjXCIgPyBcIuKGkVwiIDogXCLihpNcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHNvcnRpbmcgd2hlbiBhIGhlYWRlciBpcyBjbGlja2VkXG4gICAqL1xuICBwcml2YXRlIGhhbmRsZVNvcnQoY29sdW1uSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIElmIGNsaWNraW5nIGEgZGlmZmVyZW50IGNvbHVtbiwgcmVzZXQgc29ydCBkaXJlY3Rpb25cbiAgICBpZiAodGhpcy5jdXJyZW50U29ydENvbHVtbiAhPT0gY29sdW1uSWQpIHtcbiAgICAgIHRoaXMuY3VycmVudFNvcnREaXJlY3Rpb24gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzb3J0IHN0YXRlXG4gICAgdGhpcy5jdXJyZW50U29ydENvbHVtbiA9IGNvbHVtbklkO1xuICAgIHRoaXMuY3VycmVudFNvcnREaXJlY3Rpb24gPSB0aGlzLmdldE5leHRTb3J0RGlyZWN0aW9uKFxuICAgICAgdGhpcy5jdXJyZW50U29ydERpcmVjdGlvblxuICAgICk7XG5cbiAgICAvLyBTb3J0IGl0ZW1zXG4gICAgaWYgKHRoaXMuY3VycmVudFNvcnREaXJlY3Rpb24pIHtcbiAgICAgIHRoaXMuaXRlbXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICBjb25zdCBjb21wYXJpc29uID0gdGhpcy5jb21wYXJlSXRlbXMoYSwgYiwgY29sdW1uSWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U29ydERpcmVjdGlvbiA9PT0gXCJhc2NcIiA/IGNvbXBhcmlzb24gOiAtY29tcGFyaXNvbjtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJlLXJlbmRlciB0YWJsZVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbmV4dCBzb3J0IGRpcmVjdGlvbiBpbiB0aGUgY3ljbGVcbiAgICovXG4gIHByaXZhdGUgZ2V0TmV4dFNvcnREaXJlY3Rpb24oY3VycmVudDogU29ydERpcmVjdGlvbik6IFNvcnREaXJlY3Rpb24ge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSByZXR1cm4gXCJhc2NcIjtcbiAgICBpZiAoY3VycmVudCA9PT0gXCJhc2NcIikgcmV0dXJuIFwiZGVzY1wiO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHR3byBpdGVtcyBmb3Igc29ydGluZ1xuICAgKi9cbiAgcHJpdmF0ZSBjb21wYXJlSXRlbXMoXG4gICAgYTogRG9jdW1lbnRJbmZvLFxuICAgIGI6IERvY3VtZW50SW5mbyxcbiAgICBjb2x1bW5JZDogc3RyaW5nXG4gICk6IG51bWJlciB7XG4gICAgc3dpdGNoIChjb2x1bW5JZCkge1xuICAgICAgY2FzZSBcImZpbGVOYW1lXCI6XG4gICAgICAgIHJldHVybiBhLmZpbGVOYW1lLmxvY2FsZUNvbXBhcmUoYi5maWxlTmFtZSk7XG4gICAgICBjYXNlIFwiZmlsZVBhdGhcIjpcbiAgICAgICAgcmV0dXJuIGEuZmlsZVBhdGgubG9jYWxlQ29tcGFyZShiLmZpbGVQYXRoKTtcbiAgICAgIGNhc2UgXCJjcmVhdGVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVEYXRlcyhcbiAgICAgICAgICBhLm1ldGFkYXRhPy5jcmVhdGVkX2F0LFxuICAgICAgICAgIGIubWV0YWRhdGE/LmNyZWF0ZWRfYXRcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgXCJ1cGRhdGVkXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVEYXRlcyhcbiAgICAgICAgICBhLm1ldGFkYXRhPy51cGRhdGVkX2F0LFxuICAgICAgICAgIGIubWV0YWRhdGE/LnVwZGF0ZWRfYXRcbiAgICAgICAgKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0d28gZGF0ZSBzdHJpbmdzXG4gICAqL1xuICBwcml2YXRlIGNvbXBhcmVEYXRlcyhhOiBzdHJpbmcgfCB1bmRlZmluZWQsIGI6IHN0cmluZyB8IHVuZGVmaW5lZCk6IG51bWJlciB7XG4gICAgLy8gSGFuZGxlIHVuZGVmaW5lZCBkYXRlc1xuICAgIGlmICghYSAmJiAhYikgcmV0dXJuIDA7XG4gICAgaWYgKCFhKSByZXR1cm4gLTE7XG4gICAgaWYgKCFiKSByZXR1cm4gMTtcblxuICAgIC8vIENvbXBhcmUgZGF0ZXNcbiAgICByZXR1cm4gbmV3IERhdGUoYSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYikuZ2V0VGltZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgaGVhZGVyIGNoZWNrYm94IGNoYW5nZXNcbiAgICovXG4gIHByaXZhdGUgaGFuZGxlSGVhZGVyQ2hlY2tib3goZTogRXZlbnQsIHRhYmxlOiBIVE1MVGFibGVFbGVtZW50KTogdm9pZCB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICBjb25zdCBjaGVja2JveGVzID0gdGFibGUucXVlcnlTZWxlY3RvckFsbCgndGJvZHkgaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJyk7XG4gICAgY2hlY2tib3hlcy5mb3JFYWNoKFxuICAgICAgKGNiKSA9PiAoKGNiIGFzIEhUTUxJbnB1dEVsZW1lbnQpLmNoZWNrZWQgPSB0YXJnZXQuY2hlY2tlZClcbiAgICApO1xuXG4gICAgLy8gVXBkYXRlIGl0ZW0gc2VsZWN0aW9uIHN0YXRlXG4gICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpdGVtLmlzU2VsZWN0ZWQgPSB0YXJnZXQuY2hlY2tlZDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHByZXZpZXcgcmVxdWVzdHMgZm9yIGZpbGVzIGFuZCBjb252ZXJzYXRpb25zXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGhhbmRsZVByZXZpZXcoaXRlbTogRG9jdW1lbnRJbmZvKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gSWYgaXQncyBhIGNvbnZlcnNhdGlvbiwgdXNlIGNvbnZlcnNhdGlvbiBwcmV2aWV3XG4gICAgaWYgKGl0ZW0ubWV0YWRhdGE/LmNvbnZlcnNhdGlvbklkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBvcmdJZCA9IGdldE9yZ2FuaXphdGlvbklkKCk7XG4gICAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IGF3YWl0IENvbnZlcnNhdGlvblJldHJpZXZhbC5nZXRDb252ZXJzYXRpb24oXG4gICAgICAgICAgb3JnSWQsXG4gICAgICAgICAgaXRlbS5tZXRhZGF0YS5jb252ZXJzYXRpb25JZFxuICAgICAgICApO1xuICAgICAgICB0aGlzLnByZXZpZXdEaWFsb2cuc2hvdyhcbiAgICAgICAgICBpdGVtLmZpbGVOYW1lLFxuICAgICAgICAgIGNvbnZlcnNhdGlvbi5jaGF0X21lc3NhZ2VzLFxuICAgICAgICAgIGl0ZW0ubWV0YWRhdGEudXJsXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgY29udmVyc2F0aW9uIHByZXZpZXc6XCIsIGVycm9yKTtcbiAgICAgICAgYWxlcnQoXCJGYWlsZWQgdG8gbG9hZCBjb252ZXJzYXRpb24gcHJldmlld1wiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2Ugc2hvdyBjb250ZW50IHByZXZpZXdcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGVudCA9IGl0ZW0uY29udGVudENhbGxiYWNrXG4gICAgICAgID8gYXdhaXQgaXRlbS5jb250ZW50Q2FsbGJhY2soaXRlbSlcbiAgICAgICAgOiBpdGVtLmNvbnRlbnQ7XG5cbiAgICAgIHRoaXMuY29udGVudFByZXZpZXcuc2hvdyhpdGVtLmZpbGVOYW1lLCBjb250ZW50LCBpdGVtLmZpbGVOYW1lKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBsb2FkIGNvbnRlbnQgcHJldmlldzpcIiwgZXJyb3IpO1xuICAgICAgYWxlcnQoXCJGYWlsZWQgdG8gbG9hZCBjb250ZW50IHByZXZpZXdcIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdXBkYXRpbmcgYSBmaWxlIHBhdGhcbiAgICovXG4gIHByaXZhdGUgaGFuZGxlUGF0aFVwZGF0ZShpbmRleDogbnVtYmVyLCBuZXdQYXRoOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLml0ZW1zW2luZGV4XSA9IHtcbiAgICAgIC4uLnRoaXMuaXRlbXNbaW5kZXhdLFxuICAgICAgZmlsZVBhdGg6IG5ld1BhdGgsXG4gICAgfTtcblxuICAgIC8vIFJlLXJlbmRlciB0YWJsZVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRhYmxlIHJvdyBmb3IgYW4gaXRlbVxuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVJdGVtUm93KFxuICAgIGl0ZW06IERvY3VtZW50SW5mbyxcbiAgICBpbmRleDogbnVtYmVyXG4gICk6IEhUTUxUYWJsZVJvd0VsZW1lbnQge1xuICAgIGNvbnN0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0clwiKTtcbiAgICByb3cuc3R5bGUuYm9yZGVyQm90dG9tID0gXCIxcHggc29saWQgI2NjY1wiO1xuICAgIHJvdy5kYXRhc2V0LmNvbnZlcnNhdGlvbklkID0gaXRlbS5tZXRhZGF0YT8uY29udmVyc2F0aW9uSWQ7XG5cbiAgICAvLyBDaGVja2JveCBjZWxsXG4gICAgY29uc3QgY2hlY2tib3hDZWxsID0gY3JlYXRlQ2hlY2tib3hDZWxsKGl0ZW0uaXNTZWxlY3RlZCk7XG4gICAgY2hlY2tib3hDZWxsLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKT8uYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCAoZSkgPT4ge1xuICAgICAgY29uc3QgY2hlY2tib3ggPSBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgdGhpcy5pdGVtc1tpbmRleF0uaXNTZWxlY3RlZCA9IGNoZWNrYm94LmNoZWNrZWQ7XG4gICAgfSk7XG4gICAgcm93LmFwcGVuZENoaWxkKGNoZWNrYm94Q2VsbCk7XG5cbiAgICAvLyBOYW1lIGNlbGwgd2l0aCBwcmV2aWV3IGZvciBib3RoIGNvbnZlcnNhdGlvbnMgYW5kIGNvbnRlbnRcbiAgICBjb25zdCBvblByZXZpZXcgPSAoKSA9PiB0aGlzLmhhbmRsZVByZXZpZXcoaXRlbSk7XG4gICAgcm93LmFwcGVuZENoaWxkKFxuICAgICAgY3JlYXRlTmFtZUNlbGwoaXRlbS5maWxlTmFtZSwgaXRlbS5tZXRhZGF0YT8udXJsLCBvblByZXZpZXcpXG4gICAgKTtcblxuICAgIC8vIFJlc3VsdHMgY2VsbCAoaWYgZW5hYmxlZClcbiAgICBpZiAodGhpcy5zaG93UmVzdWx0cykge1xuICAgICAgcm93LmFwcGVuZENoaWxkKFxuICAgICAgICBjcmVhdGVTZWFyY2hSZXN1bHRDZWxsKFxuICAgICAgICAgIGl0ZW0uc2VhcmNoUmVzdWx0LFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB0aGlzLnNlYXJjaFJlc3VsdFByZXZpZXdcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGVkIGRhdGUgY2VsbFxuICAgIHJvdy5hcHBlbmRDaGlsZChjcmVhdGVEYXRlQ2VsbChpdGVtLm1ldGFkYXRhPy5jcmVhdGVkX2F0KSk7XG5cbiAgICAvLyBVcGRhdGVkIGRhdGUgY2VsbFxuICAgIHJvdy5hcHBlbmRDaGlsZChjcmVhdGVEYXRlQ2VsbChpdGVtLm1ldGFkYXRhPy51cGRhdGVkX2F0KSk7XG5cbiAgICAvLyBQYXRoIGNlbGwgd2l0aCBlZGl0IGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBvblBhdGhVcGRhdGUgPSAobmV3UGF0aDogc3RyaW5nKSA9PlxuICAgICAgdGhpcy5oYW5kbGVQYXRoVXBkYXRlKGluZGV4LCBuZXdQYXRoKTtcbiAgICByb3cuYXBwZW5kQ2hpbGQoXG4gICAgICBjcmVhdGVOYW1lQ2VsbChpdGVtLmZpbGVQYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb25QYXRoVXBkYXRlKVxuICAgICk7XG5cbiAgICByZXR1cm4gcm93O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGFkZHMgZG93bmxvYWQgYnV0dG9uc1xuICAgKi9cbiAgcHJpdmF0ZSBhZGREb3dubG9hZEJ1dHRvbnMoKTogdm9pZCB7XG4gICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBidXR0b24gY29udGFpbmVyXG4gICAgY29uc3QgZXhpc3RpbmdDb250YWluZXIgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLmRvd25sb2FkLWJ1dHRvbnNcIik7XG4gICAgaWYgKGV4aXN0aW5nQ29udGFpbmVyKSB7XG4gICAgICBleGlzdGluZ0NvbnRhaW5lci5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBidXR0b25Db250YWluZXIgPSBjcmVhdGVCdXR0b25Db250YWluZXIoKTtcbiAgICBidXR0b25Db250YWluZXIuY2xhc3NMaXN0LmFkZChcImRvd25sb2FkLWJ1dHRvbnNcIik7XG5cbiAgICBjb25zdCBkb3dubG9hZFNlbGVjdGVkQnV0dG9uID0gY3JlYXRlQnV0dG9uKFwiRG93bmxvYWQgU2VsZWN0ZWRcIiwgKCkgPT5cbiAgICAgIHRoaXMuaGFuZGxlRG93bmxvYWQoZmFsc2UpXG4gICAgKTtcblxuICAgIGNvbnN0IGRvd25sb2FkQnVuZGxlQnV0dG9uID0gY3JlYXRlQnV0dG9uKFwiRG93bmxvYWQgYXMgQnVuZGxlXCIsICgpID0+XG4gICAgICB0aGlzLmhhbmRsZURvd25sb2FkKHRydWUpXG4gICAgKTtcblxuICAgIGJ1dHRvbkNvbnRhaW5lci5hcHBlbmRDaGlsZChkb3dubG9hZFNlbGVjdGVkQnV0dG9uKTtcbiAgICBidXR0b25Db250YWluZXIuYXBwZW5kQ2hpbGQoZG93bmxvYWRCdW5kbGVCdXR0b24pO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGJ1dHRvbkNvbnRhaW5lcik7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBkb3dubG9hZCByZXF1ZXN0c1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVEb3dubG9hZChhc0J1bmRsZTogYm9vbGVhbik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHNlbGVjdGVkSXRlbXMgPSB0aGlzLml0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5pc1NlbGVjdGVkKTtcblxuICAgIGlmIChzZWxlY3RlZEl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYWxlcnQoXCJQbGVhc2Ugc2VsZWN0IGl0ZW1zIHRvIGRvd25sb2FkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAoYXNCdW5kbGUpIHtcbiAgICAgICAgYXdhaXQgRG9jdW1lbnREb3dubG9hZC5oYW5kbGVTaW5nbGVEb3dubG9hZChzZWxlY3RlZEl0ZW1zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF3YWl0IERvY3VtZW50RG93bmxvYWQuaGFuZGxlTXVsdGlwbGVEb3dubG9hZChzZWxlY3RlZEl0ZW1zKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkRvd25sb2FkIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgYWxlcnQoXG4gICAgICAgIFwiRG93bmxvYWQgZmFpbGVkOiBcIiArXG4gICAgICAgICAgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCIpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0YWJsZSB3aXRoIG5ldyBpdGVtcyB3aGlsZSBwcmVzZXJ2aW5nIHNlbGVjdGlvbiBzdGF0ZVxuICAgKi9cbiAgcHVibGljIHVwZGF0ZUl0ZW1zKG5ld0l0ZW1zOiBEb2N1bWVudEluZm9bXSk6IHZvaWQge1xuICAgIC8vIFN0b3JlIGN1cnJlbnQgc2VsZWN0aW9uIHN0YXRlXG4gICAgY29uc3Qgc2VsZWN0aW9uTWFwID0gbmV3IE1hcDxzdHJpbmcsIGJvb2xlYW4+KCk7XG4gICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpZiAoaXRlbS5tZXRhZGF0YT8uY29udmVyc2F0aW9uSWQpIHtcbiAgICAgICAgc2VsZWN0aW9uTWFwLnNldChcbiAgICAgICAgICBpdGVtLm1ldGFkYXRhLmNvbnZlcnNhdGlvbklkLFxuICAgICAgICAgIGl0ZW0uaXNTZWxlY3RlZCB8fCBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIGl0ZW1zIHdoaWxlIHByZXNlcnZpbmcgc2VsZWN0aW9uXG4gICAgdGhpcy5pdGVtcyA9IG5ld0l0ZW1zLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0ubWV0YWRhdGE/LmNvbnZlcnNhdGlvbklkKSB7XG4gICAgICAgIGNvbnN0IHdhc1NlbGVjdGVkID0gc2VsZWN0aW9uTWFwLmdldChpdGVtLm1ldGFkYXRhLmNvbnZlcnNhdGlvbklkKTtcbiAgICAgICAgaWYgKHdhc1NlbGVjdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4geyAuLi5pdGVtLCBpc1NlbGVjdGVkOiB3YXNTZWxlY3RlZCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9KTtcblxuICAgIC8vIFJlLXJlbmRlciB0YWJsZVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgdGFibGUgd2l0aCBjdXJyZW50IGl0ZW1zXG4gICAqL1xuICBwdWJsaWMgcmVuZGVyKCk6IHZvaWQge1xuICAgIHRoaXMuY29udGFpbmVyLmlubmVySFRNTCA9IFwiXCI7XG5cbiAgICBpZiAodGhpcy5pdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGNyZWF0ZUVtcHR5U3RhdGUoXCJObyBkb2N1bWVudHMgZm91bmRcIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFkZCBjYW5jZWwgYnV0dG9uIGJlZm9yZSB0aGUgdGFibGUgaWYgc2hvd2luZyByZXN1bHRzIGFuZCBjYW5jZWwgYnV0dG9uIGlzIGVuYWJsZWRcbiAgICBpZiAodGhpcy5zaG93UmVzdWx0cyAmJiB0aGlzLnNob3dDYW5jZWxCdXR0b24pIHtcbiAgICAgIGNvbnN0IGNhbmNlbEJ1dHRvbiA9IGNyZWF0ZUJ1dHRvbihcbiAgICAgICAgXCJDYW5jZWxcIixcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIFByb2plY3RTZWFyY2hTZXJ2aWNlLmFib3J0U2VhcmNoKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHsgdmFyaWFudDogXCJkYW5nZXJcIiB9XG4gICAgICApO1xuICAgICAgY2FuY2VsQnV0dG9uLnN0eWxlLm1hcmdpbkJvdHRvbSA9IFwiMTBweFwiO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoY2FuY2VsQnV0dG9uKTtcbiAgICB9XG5cbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuY3JlYXRlVGFibGUoKTtcbiAgICBjb25zdCBoZWFkZXJSb3cgPSB0aGlzLmNyZWF0ZVRhYmxlSGVhZGVyKHRhYmxlKTtcbiAgICB0YWJsZS5hcHBlbmRDaGlsZChoZWFkZXJSb3cpO1xuXG4gICAgY29uc3QgdGJvZHkgPSB0YWJsZS5jcmVhdGVUQm9keSgpO1xuICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHJvdyA9IHRoaXMuY3JlYXRlSXRlbVJvdyhpdGVtLCBpbmRleCk7XG4gICAgICB0Ym9keS5hcHBlbmRDaGlsZChyb3cpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGFibGUpO1xuICAgIHRoaXMuY3VycmVudFRhYmxlID0gdGFibGU7XG4gICAgdGhpcy5hZGREb3dubG9hZEJ1dHRvbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgdGhlIGNvbXBvbmVudFxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5jb250YWluZXIuaW5uZXJIVE1MID0gXCJcIjtcbiAgICB0aGlzLnByZXZpZXdEaWFsb2cuZGVzdHJveSgpO1xuICAgIHRoaXMuY29udGVudFByZXZpZXcuZGVzdHJveSgpO1xuICAgIHRoaXMuc2VhcmNoUmVzdWx0UHJldmlldy5kZXN0cm95KCk7XG4gICAgdGhpcy5jdXJyZW50VGFibGUgPSBudWxsO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogL1VzZXJzL21hcnRpbmJlY2hhcmQvZGV2L2NsYXVkZWV4dC9zcmMvdWkvY29tcG9uZW50cy9Eb3dubG9hZFdpZGdldHMudHNcbiAqIFRoaXMgd2FzIGdlbmVyYXRlZCBieSBDbGF1ZGUgU29ubmV0IDMuNSwgd2l0aCB0aGUgYXNzaXN0YW5jZSBvZiBteSBodW1hbiBtZW50b3JcbiAqXG4gKiBVSSB3aWRnZXQgdXRpbGl0aWVzIGZvciB0aGUgZG93bmxvYWQgdGFibGUgY29tcG9uZW50c1xuICogTm90ZTogTWFraW5nIFVJIGVsZW1lbnRzIGFzIHJldXNhYmxlIGFzIExlZ28gYmxvY2tzIVxuICovXG5cbmltcG9ydCB0eXBlIHsgU2VhcmNoUmVzdWx0SW5mbyB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgRWRpdGFibGVDZWxsIH0gZnJvbSBcIi4vRWRpdGFibGVDZWxsXCI7XG5pbXBvcnQgeyBQcm9qZWN0U2VhcmNoU2VydmljZSB9IGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9Qcm9qZWN0U2VhcmNoU2VydmljZVwiO1xuaW1wb3J0IHsgU2VhcmNoUmVzdWx0UHJldmlldyB9IGZyb20gXCIuL1NlYXJjaFJlc3VsdFByZXZpZXdcIjtcblxuLy8gQmFzZSBzdHlsZXMgdGhhdCBjYW4gYmUgdXNlZCBhY3Jvc3MgY29tcG9uZW50c1xuY29uc3Qgc3R5bGVzID0ge1xuICBjb2xvcnM6IHtcbiAgICBwcmltYXJ5OiBcIiMwMDY2Y2NcIixcbiAgICBwcmltYXJ5SG92ZXI6IFwiIzAwNTJhM1wiLFxuICAgIGJvcmRlcjogXCIjY2NjXCIsXG4gICAgdGV4dDogXCIjMzMzXCIsXG4gICAgdGV4dE11dGVkOiBcIiM2NjZcIixcbiAgICBiYWNrZ3JvdW5kOiBcIiNmOGY5ZmFcIixcbiAgICBiYWNrZ3JvdW5kTXV0ZWQ6IFwiI2RlZTJlNlwiLFxuICAgIGVycm9yOiBcIiNkYzM1NDVcIixcbiAgICBlcnJvckJhY2tncm91bmQ6IFwiI2Y4ZDdkYVwiLFxuICAgIHdhcm5pbmc6IFwiI2ZmYzEwN1wiLFxuICAgIHdhcm5pbmdCYWNrZ3JvdW5kOiBcIiNmZmYzY2RcIixcbiAgICB3b3JraW5nOiBcIiM2Yzc1N2RcIixcbiAgICB3b3JraW5nQmFja2dyb3VuZDogXCIjZTllY2VmXCIsXG4gICAgY2FuY2VsbGluZzogXCIjZmQ3ZTE0XCIsXG4gICAgY2FuY2VsbGluZ0JhY2tncm91bmQ6IFwiI2ZmZjNlNlwiLFxuICB9LFxuICBzcGFjaW5nOiB7XG4gICAgc206IFwiNHB4XCIsXG4gICAgbWQ6IFwiOHB4XCIsXG4gICAgbGc6IFwiMTJweFwiLFxuICAgIHhsOiBcIjE2cHhcIixcbiAgfSxcbiAgYm9yZGVyUmFkaXVzOiBcIjRweFwiLFxuICBmb250U2l6ZToge1xuICAgIHNtOiBcIjEycHhcIixcbiAgICBtZDogXCIxNHB4XCIsXG4gICAgbGc6IFwiMTZweFwiLFxuICB9LFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3R5bGVkIHRhYmxlIGNlbGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhYmxlQ2VsbChpc0hlYWRlciA9IGZhbHNlKTogSFRNTFRhYmxlQ2VsbEVsZW1lbnQge1xuICBjb25zdCBjZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpc0hlYWRlciA/IFwidGhcIiA6IFwidGRcIik7XG4gIGNlbGwuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICBwYWRkaW5nOiAke3N0eWxlcy5zcGFjaW5nLm1kfTtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAke3N0eWxlcy5jb2xvcnMuYm9yZGVyfTtcbiAgICBmb250LXNpemU6ICR7c3R5bGVzLmZvbnRTaXplLnNtfTtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgJHtcbiAgICAgIGlzSGVhZGVyXG4gICAgICAgID8gYFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3N0eWxlcy5jb2xvcnMuYmFja2dyb3VuZH07XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICBgXG4gICAgICAgIDogXCJcIlxuICAgIH1cbiAgYDtcbiAgcmV0dXJuIGNlbGw7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNoZWNrYm94IGNlbGwgd2l0aCBjb25zaXN0ZW50IHN0eWxpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNoZWNrYm94Q2VsbChcbiAgaXNTZWxlY3RlZDogYm9vbGVhbiA9IGZhbHNlXG4pOiBIVE1MVGFibGVDZWxsRWxlbWVudCB7XG4gIGNvbnN0IGNlbGwgPSBjcmVhdGVUYWJsZUNlbGwoKTtcbiAgY2VsbC5zdHlsZS50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuXG4gIGNvbnN0IGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICBjaGVja2JveC50eXBlID0gXCJjaGVja2JveFwiO1xuICBjaGVja2JveC5jaGVja2VkID0gaXNTZWxlY3RlZCB8fCBmYWxzZTsgLy8gRW5zdXJlIGJvb2xlYW4gdmFsdWVcblxuICBjZWxsLmFwcGVuZENoaWxkKGNoZWNrYm94KTtcbiAgcmV0dXJuIGNlbGw7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0eWxlZCBlbXB0eSBzdGF0ZSBtZXNzYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbXB0eVN0YXRlKG1lc3NhZ2U6IHN0cmluZyk6IEhUTUxEaXZFbGVtZW50IHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIHBhZGRpbmc6ICR7c3R5bGVzLnNwYWNpbmcueGx9O1xuICAgIGNvbG9yOiAke3N0eWxlcy5jb2xvcnMudGV4dE11dGVkfTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3N0eWxlcy5jb2xvcnMuYmFja2dyb3VuZH07XG4gICAgYm9yZGVyOiAxcHggc29saWQgJHtzdHlsZXMuY29sb3JzLmJhY2tncm91bmRNdXRlZH07XG4gICAgYm9yZGVyLXJhZGl1czogJHtzdHlsZXMuYm9yZGVyUmFkaXVzfTtcbiAgICBtYXJnaW4tdG9wOiAke3N0eWxlcy5zcGFjaW5nLmxnfTtcbiAgYDtcbiAgY29udGFpbmVyLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgcmV0dXJuIGNvbnRhaW5lcjtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3R5bGVkIGxpbmsgZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGluayh0ZXh0OiBzdHJpbmcsIHVybDogc3RyaW5nKTogSFRNTEFuY2hvckVsZW1lbnQge1xuICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gIGxpbmsuaHJlZiA9IHVybDtcbiAgbGluay50ZXh0Q29udGVudCA9IHRleHQ7XG4gIGxpbmsudGFyZ2V0ID0gXCJfYmxhbmtcIjtcbiAgbGluay5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIGNvbG9yOiAke3N0eWxlcy5jb2xvcnMucHJpbWFyeX07XG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xuICAgIG1hcmdpbi1yaWdodDogJHtzdHlsZXMuc3BhY2luZy5tZH07XG4gICAgZm9udC1zaXplOiAke3N0eWxlcy5mb250U2l6ZS5tZH07XG4gIGA7XG5cbiAgbGluay5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsICgpID0+IHtcbiAgICBsaW5rLnN0eWxlLnRleHREZWNvcmF0aW9uID0gXCJ1bmRlcmxpbmVcIjtcbiAgfSk7XG5cbiAgbGluay5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgKCkgPT4ge1xuICAgIGxpbmsuc3R5bGUudGV4dERlY29yYXRpb24gPSBcIm5vbmVcIjtcbiAgfSk7XG5cbiAgcmV0dXJuIGxpbms7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0eWxlZCBidXR0b24gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQnV0dG9uKFxuICB0ZXh0OiBzdHJpbmcsXG4gIG9uQ2xpY2s6ICgpID0+IHZvaWQsXG4gIG9wdGlvbnM6IHsgdmFyaWFudD86IFwicHJpbWFyeVwiIHwgXCJzZWNvbmRhcnlcIiB8IFwiaWNvblwiIHwgXCJkYW5nZXJcIiB9ID0ge31cbik6IEhUTUxCdXR0b25FbGVtZW50IHtcbiAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgYnV0dG9uLnRleHRDb250ZW50ID0gdGV4dDtcblxuICBjb25zdCBiYXNlU3R5bGVzID0gYFxuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgZm9udC1zaXplOiAke3N0eWxlcy5mb250U2l6ZS5tZH07XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuMnMgZWFzZTtcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBgO1xuXG4gIGxldCB2YXJpYW50U3R5bGVzID0gXCJcIjtcbiAgc3dpdGNoIChvcHRpb25zLnZhcmlhbnQpIHtcbiAgICBjYXNlIFwic2Vjb25kYXJ5XCI6XG4gICAgICB2YXJpYW50U3R5bGVzID0gYFxuICAgICAgICBiYWNrZ3JvdW5kOiAke3N0eWxlcy5jb2xvcnMuYmFja2dyb3VuZH07XG4gICAgICAgIGNvbG9yOiAke3N0eWxlcy5jb2xvcnMudGV4dH07XG4gICAgICAgIHBhZGRpbmc6ICR7c3R5bGVzLnNwYWNpbmcubWR9ICR7c3R5bGVzLnNwYWNpbmcueGx9O1xuICAgICAgICBib3JkZXItcmFkaXVzOiAke3N0eWxlcy5ib3JkZXJSYWRpdXN9O1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAke3N0eWxlcy5jb2xvcnMuYm9yZGVyfTtcbiAgICAgIGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaWNvblwiOlxuICAgICAgdmFyaWFudFN0eWxlcyA9IGBcbiAgICAgICAgYmFja2dyb3VuZDogbm9uZTtcbiAgICAgICAgY29sb3I6ICR7c3R5bGVzLmNvbG9ycy50ZXh0TXV0ZWR9O1xuICAgICAgICBwYWRkaW5nOiAke3N0eWxlcy5zcGFjaW5nLnNtfTtcbiAgICAgIGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZGFuZ2VyXCI6XG4gICAgICB2YXJpYW50U3R5bGVzID0gYFxuICAgICAgICBiYWNrZ3JvdW5kOiAke3N0eWxlcy5jb2xvcnMuZXJyb3J9O1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIHBhZGRpbmc6ICR7c3R5bGVzLnNwYWNpbmcubWR9ICR7c3R5bGVzLnNwYWNpbmcueGx9O1xuICAgICAgICBib3JkZXItcmFkaXVzOiAke3N0eWxlcy5ib3JkZXJSYWRpdXN9O1xuICAgICAgYDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIHByaW1hcnlcbiAgICAgIHZhcmlhbnRTdHlsZXMgPSBgXG4gICAgICAgIGJhY2tncm91bmQ6ICR7c3R5bGVzLmNvbG9ycy5wcmltYXJ5fTtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBwYWRkaW5nOiAke3N0eWxlcy5zcGFjaW5nLm1kfSAke3N0eWxlcy5zcGFjaW5nLnhsfTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogJHtzdHlsZXMuYm9yZGVyUmFkaXVzfTtcbiAgICAgIGA7XG4gIH1cblxuICBidXR0b24uc3R5bGUuY3NzVGV4dCA9IGJhc2VTdHlsZXMgKyB2YXJpYW50U3R5bGVzO1xuXG4gIC8vIEFkZCBob3ZlciBlZmZlY3RzXG4gIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsICgpID0+IHtcbiAgICBpZiAob3B0aW9ucy52YXJpYW50ID09PSBcImljb25cIikge1xuICAgICAgYnV0dG9uLnN0eWxlLmNvbG9yID0gc3R5bGVzLmNvbG9ycy5wcmltYXJ5O1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy52YXJpYW50ID09PSBcInNlY29uZGFyeVwiKSB7XG4gICAgICBidXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gc3R5bGVzLmNvbG9ycy5iYWNrZ3JvdW5kTXV0ZWQ7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnZhcmlhbnQgPT09IFwiZGFuZ2VyXCIpIHtcbiAgICAgIGJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBzdHlsZXMuY29sb3JzLmVycm9yQmFja2dyb3VuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgYnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHN0eWxlcy5jb2xvcnMucHJpbWFyeUhvdmVyO1xuICAgIH1cbiAgfSk7XG5cbiAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCAoKSA9PiB7XG4gICAgaWYgKG9wdGlvbnMudmFyaWFudCA9PT0gXCJpY29uXCIpIHtcbiAgICAgIGJ1dHRvbi5zdHlsZS5jb2xvciA9IHN0eWxlcy5jb2xvcnMudGV4dE11dGVkO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy52YXJpYW50ID09PSBcInNlY29uZGFyeVwiKSB7XG4gICAgICBidXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gc3R5bGVzLmNvbG9ycy5iYWNrZ3JvdW5kO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy52YXJpYW50ID09PSBcImRhbmdlclwiKSB7XG4gICAgICBidXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gc3R5bGVzLmNvbG9ycy5lcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgYnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHN0eWxlcy5jb2xvcnMucHJpbWFyeTtcbiAgICB9XG4gIH0pO1xuXG4gIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbGljayk7XG4gIHJldHVybiBidXR0b247XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNvbnRhaW5lciBmb3IgYnV0dG9ucyB3aXRoIGNvbnNpc3RlbnQgc3R5bGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQnV0dG9uQ29udGFpbmVyKCk6IEhUTUxEaXZFbGVtZW50IHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBnYXA6ICR7c3R5bGVzLnNwYWNpbmcubWR9O1xuICAgIG1hcmdpbi10b3A6ICR7c3R5bGVzLnNwYWNpbmcubGd9O1xuICBgO1xuICByZXR1cm4gY29udGFpbmVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBkYXRlIGNlbGwgd2l0aCBjb25zaXN0ZW50IGZvcm1hdHRpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURhdGVDZWxsKGRhdGU6IHN0cmluZyB8IHVuZGVmaW5lZCk6IEhUTUxUYWJsZUNlbGxFbGVtZW50IHtcbiAgY29uc3QgY2VsbCA9IGNyZWF0ZVRhYmxlQ2VsbCgpO1xuXG4gIGlmIChkYXRlKSB7XG4gICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9IG5ldyBEYXRlKGRhdGUpLnRvTG9jYWxlU3RyaW5nKHVuZGVmaW5lZCwge1xuICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCJzaG9ydFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICB9KTtcbiAgICBjZWxsLnRleHRDb250ZW50ID0gZm9ybWF0dGVkRGF0ZTtcbiAgICBjZWxsLnRpdGxlID0gbmV3IERhdGUoZGF0ZSkudG9Mb2NhbGVTdHJpbmcodW5kZWZpbmVkLCB7XG4gICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgIG1vbnRoOiBcImxvbmdcIixcbiAgICAgIGRheTogXCJudW1lcmljXCIsXG4gICAgICBob3VyOiBcIjItZGlnaXRcIixcbiAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICBzZWNvbmQ6IFwiMi1kaWdpdFwiLFxuICAgICAgdGltZVpvbmVOYW1lOiBcInNob3J0XCIsXG4gICAgfSk7XG4gIH1cblxuICBjZWxsLnN0eWxlLmNzc1RleHQgKz0gYFxuICAgIGNvbG9yOiAke3N0eWxlcy5jb2xvcnMudGV4dE11dGVkfTtcbiAgICBmb250LXNpemU6ICR7c3R5bGVzLmZvbnRTaXplLnNtfTtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIGA7XG5cbiAgcmV0dXJuIGNlbGw7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByZXZpZXcgKGV5ZSkgaWNvbiBTVkcgZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJldmlld0ljb24oe1xuICBzaXplID0gMTYsXG4gIGNvbG9yID0gc3R5bGVzLmNvbG9ycy50ZXh0TXV0ZWQsXG59OiB7XG4gIHNpemU/OiBudW1iZXI7XG4gIGNvbG9yPzogc3RyaW5nO1xufSA9IHt9KTogU1ZHRWxlbWVudCB7XG4gIGNvbnN0IHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgc2l6ZS50b1N0cmluZygpKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBzaXplLnRvU3RyaW5nKCkpO1xuICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBcIjAgMCAyNCAyNFwiKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJub25lXCIpO1xuICBzdmcuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIGNvbG9yKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBcIjJcIik7XG4gIHN2Zy5pbm5lckhUTUwgPSBgXG4gICAgPHBhdGggZD1cIk0xIDEyczQtOCAxMS04IDExIDggMTEgOC00IDgtMTEgOC0xMS04LTExLTh6XCI+PC9wYXRoPlxuICAgIDxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiM1wiPjwvY2lyY2xlPlxuICBgO1xuICByZXR1cm4gc3ZnO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3IgaWNvbiBTVkcgZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVFcnJvckljb24oe1xuICBzaXplID0gMTYsXG4gIGNvbG9yID0gc3R5bGVzLmNvbG9ycy5lcnJvcixcbn06IHtcbiAgc2l6ZT86IG51bWJlcjtcbiAgY29sb3I/OiBzdHJpbmc7XG59ID0ge30pOiBTVkdFbGVtZW50IHtcbiAgY29uc3Qgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJzdmdcIik7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBzaXplLnRvU3RyaW5nKCkpO1xuICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHNpemUudG9TdHJpbmcoKSk7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIFwiMCAwIDI0IDI0XCIpO1xuICBzdmcuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgY29sb3IpO1xuICBzdmcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIFwiMlwiKTtcbiAgc3ZnLmlubmVySFRNTCA9IGBcbiAgICA8Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjEyXCIgcj1cIjEwXCI+PC9jaXJjbGU+XG4gICAgPGxpbmUgeDE9XCIxMlwiIHkxPVwiOFwiIHgyPVwiMTJcIiB5Mj1cIjEyXCI+PC9saW5lPlxuICAgIDxsaW5lIHgxPVwiMTJcIiB5MT1cIjE2XCIgeDI9XCIxMi4wMVwiIHkyPVwiMTZcIj48L2xpbmU+XG4gIGA7XG4gIHJldHVybiBzdmc7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHByZXZpZXcgYnV0dG9uIHdpdGggaWNvblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJldmlld0J1dHRvbihvbkNsaWNrOiAoKSA9PiB2b2lkKTogSFRNTEJ1dHRvbkVsZW1lbnQge1xuICBjb25zdCBidXR0b24gPSBjcmVhdGVCdXR0b24oXCJcIiwgb25DbGljaywgeyB2YXJpYW50OiBcImljb25cIiB9KTtcbiAgYnV0dG9uLnRpdGxlID0gXCJQcmV2aWV3IGNvbnZlcnNhdGlvblwiO1xuICBidXR0b24uYXBwZW5kQ2hpbGQoY3JlYXRlUHJldmlld0ljb24oKSk7XG4gIHJldHVybiBidXR0b247XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5hbWUgY2VsbCB3aXRoIHByZXZpZXcgYW5kIGVkaXQgZnVuY3Rpb25hbGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTmFtZUNlbGwoXG4gIG5hbWU6IHN0cmluZyxcbiAgdXJsPzogc3RyaW5nLFxuICBvblByZXZpZXc/OiAoKSA9PiB2b2lkLFxuICBvblJlbmFtZT86IChuZXdOYW1lOiBzdHJpbmcpID0+IHZvaWRcbik6IEhUTUxUYWJsZUNlbGxFbGVtZW50IHtcbiAgY29uc3QgY2VsbCA9IGNyZWF0ZVRhYmxlQ2VsbCgpO1xuICBsZXQgY3VycmVudENvbnRlbnQ6IEhUTUxFbGVtZW50O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vcm1hbFZpZXcoKTogSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGdhcDogJHtzdHlsZXMuc3BhY2luZy5tZH07XG4gICAgYDtcblxuICAgIGlmICh1cmwpIHtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVMaW5rKG5hbWUsIHVybCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICB0ZXh0LnRleHRDb250ZW50ID0gbmFtZTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAob25QcmV2aWV3KSB7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY3JlYXRlUHJldmlld0J1dHRvbihvblByZXZpZXcpKTtcbiAgICB9XG5cbiAgICBpZiAob25SZW5hbWUpIHtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVFZGl0QnV0dG9uKCgpID0+IHN3aXRjaFRvRWRpdE1vZGUoKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cblxuICBmdW5jdGlvbiBzd2l0Y2hUb0VkaXRNb2RlKCk6IHZvaWQge1xuICAgIGNvbnN0IGVkaXRhYmxlQ2VsbCA9IG5ldyBFZGl0YWJsZUNlbGwoe1xuICAgICAgaW5pdGlhbFZhbHVlOiBuYW1lLFxuICAgICAgdmFsaWRhdG9yOiB2YWxpZGF0ZUZpbGVQYXRoLFxuICAgICAgb25TYXZlOiAobmV3VmFsdWUpID0+IHtcbiAgICAgICAgb25SZW5hbWU/LihuZXdWYWx1ZSk7XG4gICAgICAgIHN3aXRjaFRvTm9ybWFsTW9kZSgpO1xuICAgICAgfSxcbiAgICAgIG9uQ2FuY2VsOiAoKSA9PiBzd2l0Y2hUb05vcm1hbE1vZGUoKSxcbiAgICB9KTtcblxuICAgIGN1cnJlbnRDb250ZW50LnJlcGxhY2VXaXRoKGVkaXRhYmxlQ2VsbC5nZXRFbGVtZW50KCkpO1xuICAgIGN1cnJlbnRDb250ZW50ID0gZWRpdGFibGVDZWxsLmdldEVsZW1lbnQoKTtcbiAgICBlZGl0YWJsZUNlbGwuZm9jdXMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN3aXRjaFRvTm9ybWFsTW9kZSgpOiB2b2lkIHtcbiAgICBjb25zdCBub3JtYWxWaWV3ID0gY3JlYXRlTm9ybWFsVmlldygpO1xuICAgIGN1cnJlbnRDb250ZW50LnJlcGxhY2VXaXRoKG5vcm1hbFZpZXcpO1xuICAgIGN1cnJlbnRDb250ZW50ID0gbm9ybWFsVmlldztcbiAgfVxuXG4gIC8vIFN0YXJ0IHdpdGggbm9ybWFsIHZpZXdcbiAgY3VycmVudENvbnRlbnQgPSBjcmVhdGVOb3JtYWxWaWV3KCk7XG4gIGNlbGwuYXBwZW5kQ2hpbGQoY3VycmVudENvbnRlbnQpO1xuXG4gIHJldHVybiBjZWxsO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjZWxsIGRpc3BsYXlpbmcgc2VhcmNoIHJlc3VsdCBpbmZvcm1hdGlvbiB3aXRoIGV4cGFuZGFibGUgY29udGVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VhcmNoUmVzdWx0Q2VsbChcbiAgc2VhcmNoUmVzdWx0PzogU2VhcmNoUmVzdWx0SW5mbyxcbiAgZXJyb3I/OiBzdHJpbmcsXG4gIHByZXZpZXc/OiBTZWFyY2hSZXN1bHRQcmV2aWV3XG4pOiBIVE1MVGFibGVDZWxsRWxlbWVudCB7XG4gIGNvbnN0IGNlbGwgPSBjcmVhdGVUYWJsZUNlbGwoKTtcblxuICAvLyBIYW5kbGUgd29ya2luZyBzdGF0ZVxuICBpZiAoZXJyb3IgPT09IFwiV29ya2luZy4uLlwiIHx8IGVycm9yID09PSBcIkNhbmNlbGxpbmcuLi5cIikge1xuICAgIGNvbnN0IHdvcmtpbmdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnN0IGlzV29ya2luZyA9IGVycm9yID09PSBcIldvcmtpbmcuLi5cIjtcbiAgICB3b3JraW5nQ29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwYWRkaW5nOiAke3N0eWxlcy5zcGFjaW5nLm1kfTtcbiAgICAgIGNvbG9yOiAke2lzV29ya2luZyA/IHN0eWxlcy5jb2xvcnMud29ya2luZyA6IHN0eWxlcy5jb2xvcnMuY2FuY2VsbGluZ307XG4gICAgICBmb250LXNpemU6ICR7c3R5bGVzLmZvbnRTaXplLnNtfTtcbiAgICAgIGJhY2tncm91bmQ6ICR7XG4gICAgICAgIGlzV29ya2luZ1xuICAgICAgICAgID8gc3R5bGVzLmNvbG9ycy53b3JraW5nQmFja2dyb3VuZFxuICAgICAgICAgIDogc3R5bGVzLmNvbG9ycy5jYW5jZWxsaW5nQmFja2dyb3VuZFxuICAgICAgfTtcbiAgICAgIGJvcmRlci1yYWRpdXM6ICR7c3R5bGVzLmJvcmRlclJhZGl1c307XG4gICAgICBib3JkZXItbGVmdDogM3B4IHNvbGlkICR7XG4gICAgICAgIGlzV29ya2luZyA/IHN0eWxlcy5jb2xvcnMud29ya2luZyA6IHN0eWxlcy5jb2xvcnMuY2FuY2VsbGluZ1xuICAgICAgfTtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgZ2FwOiAke3N0eWxlcy5zcGFjaW5nLm1kfTtcbiAgICBgO1xuXG4gICAgY29uc3Qgc3RhdHVzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBzdGF0dXNDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgZ2FwOiAke3N0eWxlcy5zcGFjaW5nLm1kfTtcbiAgICBgO1xuXG4gICAgLy8gQWRkIGxvYWRpbmcgc3Bpbm5lclxuICAgIGNvbnN0IHNwaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHNwaW5uZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHdpZHRoOiAxMnB4O1xuICAgICAgaGVpZ2h0OiAxMnB4O1xuICAgICAgYm9yZGVyOiAycHggc29saWQgJHtcbiAgICAgICAgaXNXb3JraW5nID8gc3R5bGVzLmNvbG9ycy53b3JraW5nIDogc3R5bGVzLmNvbG9ycy5jYW5jZWxsaW5nXG4gICAgICB9O1xuICAgICAgYm9yZGVyLXRvcC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICBhbmltYXRpb246IHNwaW4gMXMgbGluZWFyIGluZmluaXRlO1xuICAgIGA7XG4gICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgc3R5bGUudGV4dENvbnRlbnQgPSBgXG4gICAgICBAa2V5ZnJhbWVzIHNwaW4ge1xuICAgICAgICB0byB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cbiAgICAgIH1cbiAgICBgO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXG4gICAgc3RhdHVzQ29udGFpbmVyLmFwcGVuZENoaWxkKHNwaW5uZXIpO1xuICAgIHN0YXR1c0NvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlcnJvcikpO1xuICAgIHdvcmtpbmdDb250YWluZXIuYXBwZW5kQ2hpbGQoc3RhdHVzQ29udGFpbmVyKTtcblxuICAgIGNlbGwuYXBwZW5kQ2hpbGQod29ya2luZ0NvbnRhaW5lcik7XG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cblxuICAvLyBIYW5kbGUgZXJyb3Igc3RhdGVcbiAgaWYgKGVycm9yICYmIGVycm9yICE9PSBcIk5vIG1hdGNoIGZvdW5kXCIpIHtcbiAgICBjb25zdCBlcnJvckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZXJyb3JDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBhZGRpbmc6ICR7c3R5bGVzLnNwYWNpbmcubWR9O1xuICAgICAgY29sb3I6ICR7c3R5bGVzLmNvbG9ycy5lcnJvcn07XG4gICAgICBmb250LXNpemU6ICR7c3R5bGVzLmZvbnRTaXplLnNtfTtcbiAgICAgIGJhY2tncm91bmQ6ICR7c3R5bGVzLmNvbG9ycy5lcnJvckJhY2tncm91bmR9O1xuICAgICAgYm9yZGVyLXJhZGl1czogJHtzdHlsZXMuYm9yZGVyUmFkaXVzfTtcbiAgICAgIGJvcmRlci1sZWZ0OiAzcHggc29saWQgJHtzdHlsZXMuY29sb3JzLmVycm9yfTtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgZ2FwOiAke3N0eWxlcy5zcGFjaW5nLm1kfTtcbiAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBgO1xuXG4gICAgLy8gQWRkIGVycm9yIGljb24gdGhhdCBzaG93cyBkZXRhaWxzIG9uIGNsaWNrXG4gICAgY29uc3QgZXJyb3JCdXR0b24gPSBjcmVhdGVCdXR0b24oXG4gICAgICBcIlwiLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBwcmV2aWV3Py5zaG93KGVycm9yKTtcbiAgICAgIH0sXG4gICAgICB7IHZhcmlhbnQ6IFwiaWNvblwiIH1cbiAgICApO1xuICAgIGVycm9yQnV0dG9uLnRpdGxlID0gXCJWaWV3IGVycm9yIGRldGFpbHNcIjtcbiAgICBlcnJvckJ1dHRvbi5hcHBlbmRDaGlsZChjcmVhdGVFcnJvckljb24oKSk7XG5cbiAgICBlcnJvckNvbnRhaW5lci5hcHBlbmRDaGlsZChlcnJvckJ1dHRvbik7XG4gICAgZXJyb3JDb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZXJyb3IpKTtcblxuICAgIGNlbGwuYXBwZW5kQ2hpbGQoZXJyb3JDb250YWluZXIpO1xuICAgIHJldHVybiBjZWxsO1xuICB9XG5cbiAgLy8gSGFuZGxlIFwiTm8gbWF0Y2ggZm91bmRcIiBzdGF0ZVxuICBpZiAoZXJyb3IgPT09IFwiTm8gbWF0Y2ggZm91bmRcIikge1xuICAgIGNvbnN0IG5vTWF0Y2hDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG5vTWF0Y2hDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBhZGRpbmc6ICR7c3R5bGVzLnNwYWNpbmcubWR9O1xuICAgICAgY29sb3I6ICR7c3R5bGVzLmNvbG9ycy53YXJuaW5nfTtcbiAgICAgIGZvbnQtc2l6ZTogJHtzdHlsZXMuZm9udFNpemUuc219O1xuICAgICAgYmFja2dyb3VuZDogJHtzdHlsZXMuY29sb3JzLndhcm5pbmdCYWNrZ3JvdW5kfTtcbiAgICAgIGJvcmRlci1yYWRpdXM6ICR7c3R5bGVzLmJvcmRlclJhZGl1c307XG4gICAgICBib3JkZXItbGVmdDogM3B4IHNvbGlkICR7c3R5bGVzLmNvbG9ycy53YXJuaW5nfTtcbiAgICBgO1xuICAgIG5vTWF0Y2hDb250YWluZXIudGV4dENvbnRlbnQgPSBcIk5vIG1hdGNoIGZvdW5kXCI7XG4gICAgY2VsbC5hcHBlbmRDaGlsZChub01hdGNoQ29udGFpbmVyKTtcbiAgICByZXR1cm4gY2VsbDtcbiAgfVxuXG4gIGlmICghc2VhcmNoUmVzdWx0KSB7XG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cblxuICAvLyBDcmVhdGUgY2xpY2thYmxlIGNvbnRhaW5lciBmb3Igc2VhcmNoIHJlc3VsdFxuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgZ2FwOiAke3N0eWxlcy5zcGFjaW5nLnNtfTtcbiAgICBtYXgtd2lkdGg6IDQwMHB4O1xuICAgIG1pbi13aWR0aDogMjAwcHg7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIHBhZGRpbmc6ICR7c3R5bGVzLnNwYWNpbmcubWR9O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7c3R5bGVzLmJvcmRlclJhZGl1c307XG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjJzIGVhc2U7XG4gIGA7XG5cbiAgLy8gQWRkIGhvdmVyIGVmZmVjdFxuICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCAoKSA9PiB7XG4gICAgY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHN0eWxlcy5jb2xvcnMuYmFja2dyb3VuZDtcbiAgfSk7XG4gIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgKCkgPT4ge1xuICAgIGNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInRyYW5zcGFyZW50XCI7XG4gIH0pO1xuXG4gIC8vIEFkZCBjbGljayBoYW5kbGVyIHRvIHNob3cgcHJldmlld1xuICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICBwcmV2aWV3Py5zaG93KHNlYXJjaFJlc3VsdCk7XG4gIH0pO1xuXG4gIC8vIEFkZCBtYXRjaCByZWFzb24gd2l0aCB0cnVuY2F0aW9uXG4gIGNvbnN0IHJlYXNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIHJlYXNvbi50ZXh0Q29udGVudCA9IHNlYXJjaFJlc3VsdC5tYXRjaFJlYXNvbjtcbiAgcmVhc29uLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgZm9udC1zaXplOiAke3N0eWxlcy5mb250U2l6ZS5zbX07XG4gICAgY29sb3I6ICR7c3R5bGVzLmNvbG9ycy50ZXh0fTtcbiAgICBsaW5lLWhlaWdodDogMS40O1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XG4gICAgLXdlYmtpdC1saW5lLWNsYW1wOiAyO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gIGA7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChyZWFzb24pO1xuXG4gIC8vIEFkZCBzbmlwcGV0IHByZXZpZXcgd2l0aCB0cnVuY2F0aW9uXG4gIGNvbnN0IHNuaXBwZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBzbmlwcGV0LnRleHRDb250ZW50ID0gc2VhcmNoUmVzdWx0LnJlbGV2YW50U25pcHBldDtcbiAgc25pcHBldC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIGZvbnQtc2l6ZTogJHtzdHlsZXMuZm9udFNpemUuc219O1xuICAgIGNvbG9yOiAke3N0eWxlcy5jb2xvcnMudGV4dE11dGVkfTtcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gICAgYmFja2dyb3VuZDogJHtzdHlsZXMuY29sb3JzLmJhY2tncm91bmR9O1xuICAgIHBhZGRpbmc6ICR7c3R5bGVzLnNwYWNpbmcubWR9O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7c3R5bGVzLmJvcmRlclJhZGl1c307XG4gICAgYm9yZGVyLWxlZnQ6IDNweCBzb2xpZCAke3N0eWxlcy5jb2xvcnMucHJpbWFyeX07XG4gICAgbGluZS1oZWlnaHQ6IDEuNDtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xuICAgIC13ZWJraXQtbGluZS1jbGFtcDogMjtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICBgO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc25pcHBldCk7XG5cbiAgLy8gQWRkIFwiQ2xpY2sgdG8gdmlldyBkZXRhaWxzXCIgaGludFxuICBjb25zdCBoaW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgaGludC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIGZvbnQtc2l6ZTogJHtzdHlsZXMuZm9udFNpemUuc219O1xuICAgIGNvbG9yOiAke3N0eWxlcy5jb2xvcnMucHJpbWFyeX07XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGdhcDogJHtzdHlsZXMuc3BhY2luZy5zbX07XG4gIGA7XG4gIGhpbnQuYXBwZW5kQ2hpbGQoY3JlYXRlUHJldmlld0ljb24oeyBjb2xvcjogc3R5bGVzLmNvbG9ycy5wcmltYXJ5IH0pKTtcbiAgaGludC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkNsaWNrIHRvIHZpZXcgZGV0YWlsc1wiKSk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChoaW50KTtcblxuICBjZWxsLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gIHJldHVybiBjZWxsO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZWRpdCBpY29uIFNWRyBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRJY29uKHtcbiAgc2l6ZSA9IDE2LFxuICBjb2xvciA9IHN0eWxlcy5jb2xvcnMudGV4dE11dGVkLFxufToge1xuICBzaXplPzogbnVtYmVyO1xuICBjb2xvcj86IHN0cmluZztcbn0gPSB7fSk6IFNWR0VsZW1lbnQge1xuICBjb25zdCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHNpemUudG9TdHJpbmcoKSk7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgc2l6ZS50b1N0cmluZygpKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgXCIwIDAgMjQgMjRcIik7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBjb2xvcik7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgXCIyXCIpO1xuICBzdmcuaW5uZXJIVE1MID0gYFxuICAgIDxwYXRoIGQ9XCJNMTEgNEg0YTIgMiAwIDAgMC0yIDJ2MTRhMiAyIDAgMCAwIDIgMmgxNGEyIDIgMCAwIDAgMi0ydi03XCI+PC9wYXRoPlxuICAgIDxwYXRoIGQ9XCJNMTguNSAyLjVhMi4xMjEgMi4xMjEgMCAwIDEgMyAzTDEyIDE1bC00IDEgMS00IDkuNS05LjV6XCI+PC9wYXRoPlxuICBgO1xuICByZXR1cm4gc3ZnO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZWRpdCBidXR0b24gd2l0aCBpY29uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRCdXR0b24ob25DbGljazogKCkgPT4gdm9pZCk6IEhUTUxCdXR0b25FbGVtZW50IHtcbiAgY29uc3QgYnV0dG9uID0gY3JlYXRlQnV0dG9uKFwiXCIsIG9uQ2xpY2ssIHsgdmFyaWFudDogXCJpY29uXCIgfSk7XG4gIGJ1dHRvbi50aXRsZSA9IFwiRWRpdCBuYW1lXCI7XG4gIGJ1dHRvbi5hcHBlbmRDaGlsZChjcmVhdGVFZGl0SWNvbigpKTtcbiAgcmV0dXJuIGJ1dHRvbjtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBmaWxlIHBhdGhcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGaWxlUGF0aCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gXCJQYXRoIGNhbm5vdCBiZSBlbXB0eVwiO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGludmFsaWQgY2hhcmFjdGVyc1xuICBjb25zdCBpbnZhbGlkQ2hhcnMgPSAvW1xceDAwLVxceDFGXS9nOyAvLyBBbGxvdyBzbGFzaGVzIGFuZCBvdGhlciBwYXRoIGNoYXJzXG4gIGlmIChpbnZhbGlkQ2hhcnMudGVzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gXCJQYXRoIGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVyc1wiO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogc3JjL3VpL2NvbXBvbmVudHMvRHJhZ2dhYmxlTWFuYWdlci50c1xuICogVGhpcyB3YXMgZ2VuZXJhdGVkIGJ5IENsYXVkZSBTb25uZXQgMy41LCB3aXRoIHRoZSBhc3Npc3RhbmNlIG9mIG15IGh1bWFuIG1lbnRvclxuICovXG5cbmltcG9ydCB7IFdpbmRvd1N0YXRlU2VydmljZSB9IGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9XaW5kb3dTdGF0ZVNlcnZpY2VcIjtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBkcmFnZ2FibGUgYm91bmRzLlxuICovXG50eXBlIERyYWdnYWJsZUJvdW5kcyA9IHtcbiAgbWluWDogbnVtYmVyO1xuICBtYXhYOiBudW1iZXI7XG4gIG1pblk6IG51bWJlcjtcbiAgbWF4WTogbnVtYmVyO1xufTtcblxuLyoqXG4gKiBNYW5hZ2VzIGRyYWdnYWJsZSBiZWhhdmlvciBmb3IgSFRNTCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGNsYXNzIERyYWdnYWJsZU1hbmFnZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IHdpbmRvdzogSFRNTEVsZW1lbnQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgaGFuZGxlOiBIVE1MRWxlbWVudDtcbiAgcHJpdmF0ZSBpc0RyYWdnaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgY3VycmVudFg6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgY3VycmVudFk6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgaW5pdGlhbFg6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgaW5pdGlhbFk6IG51bWJlciA9IDA7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRHJhZ2dhYmxlTWFuYWdlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHdpbmRvdyAtIEVsZW1lbnQgdG8gbWFrZSBkcmFnZ2FibGVcbiAgICogQHBhcmFtIGhhbmRsZSAtIEVsZW1lbnQgdGhhdCB0cmlnZ2VycyBkcmFnZ2luZ1xuICAgKi9cbiAgY29uc3RydWN0b3Iod2luZG93OiBIVE1MRWxlbWVudCwgaGFuZGxlOiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgIHRoaXMuaGFuZGxlID0gaGFuZGxlO1xuICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgZXZlbnQgbGlzdGVuZXJzIGZvciBkcmFnIGJlaGF2aW9yLlxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIHRoaXMuaGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5oYW5kbGVNb3VzZURvd24uYmluZCh0aGlzKSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLmhhbmRsZU1vdXNlTW92ZS5iaW5kKHRoaXMpKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmhhbmRsZU1vdXNlVXAuYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgc3RhcnQgb2YgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIGUgLSBNb3VzZSBldmVudFxuICAgKi9cbiAgcHJpdmF0ZSBoYW5kbGVNb3VzZURvd24oZTogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy5oYW5kbGUgfHwgdGhpcy5oYW5kbGUuY29udGFpbnMoZS50YXJnZXQgYXMgTm9kZSkpIHtcbiAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICB0aGlzLmluaXRpYWxYID0gZS5jbGllbnRYIC0gdGhpcy53aW5kb3cub2Zmc2V0TGVmdDtcbiAgICAgIHRoaXMuaW5pdGlhbFkgPSBlLmNsaWVudFkgLSB0aGlzLndpbmRvdy5vZmZzZXRUb3A7XG4gICAgICB0aGlzLndpbmRvdy5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIHRoaXMud2luZG93LnN0eWxlLnJpZ2h0ID0gXCJhdXRvXCI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGRyYWcgbW92ZW1lbnQuXG4gICAqIEBwYXJhbSBlIC0gTW91c2UgZXZlbnRcbiAgICovXG4gIHByaXZhdGUgaGFuZGxlTW91c2VNb3ZlKGU6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykgcmV0dXJuO1xuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuY3VycmVudFggPSBlLmNsaWVudFggLSB0aGlzLmluaXRpYWxYO1xuICAgIHRoaXMuY3VycmVudFkgPSBlLmNsaWVudFkgLSB0aGlzLmluaXRpYWxZO1xuXG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICB0aGlzLmNvbnN0cmFpblRvQm91bmRzKGJvdW5kcyk7XG5cbiAgICB0aGlzLndpbmRvdy5zdHlsZS5sZWZ0ID0gYCR7dGhpcy5jdXJyZW50WH1weGA7XG4gICAgdGhpcy53aW5kb3cuc3R5bGUudG9wID0gYCR7dGhpcy5jdXJyZW50WX1weGA7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgYm91bmRzIGZvciBkcmFnZ2luZy5cbiAgICogQHJldHVybnMgQm91bmRzIG9iamVjdCB3aXRoIG1pbi9tYXggdmFsdWVzXG4gICAqL1xuICBwcml2YXRlIGNhbGN1bGF0ZUJvdW5kcygpOiBEcmFnZ2FibGVCb3VuZHMge1xuICAgIHJldHVybiB7XG4gICAgICBtaW5YOiAwLFxuICAgICAgbWF4WDogd2luZG93LmlubmVyV2lkdGggLSB0aGlzLndpbmRvdy5vZmZzZXRXaWR0aCxcbiAgICAgIG1pblk6IDAsXG4gICAgICBtYXhZOiB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0aGlzLndpbmRvdy5vZmZzZXRIZWlnaHQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJhaW5zIHRoZSBjdXJyZW50IHBvc2l0aW9uIHRvIHRoZSBzcGVjaWZpZWQgYm91bmRzLlxuICAgKiBAcGFyYW0gYm91bmRzIC0gQm91bmRzIHRvIGNvbnN0cmFpbiB0b1xuICAgKi9cbiAgcHJpdmF0ZSBjb25zdHJhaW5Ub0JvdW5kcyhib3VuZHM6IERyYWdnYWJsZUJvdW5kcyk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFggPSBNYXRoLm1heChib3VuZHMubWluWCwgTWF0aC5taW4odGhpcy5jdXJyZW50WCwgYm91bmRzLm1heFgpKTtcbiAgICB0aGlzLmN1cnJlbnRZID0gTWF0aC5tYXgoYm91bmRzLm1pblksIE1hdGgubWluKHRoaXMuY3VycmVudFksIGJvdW5kcy5tYXhZKSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZW5kIG9mIGEgZHJhZyBvcGVyYXRpb24uXG4gICAqL1xuICBwcml2YXRlIGhhbmRsZU1vdXNlVXAoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgLy8gU2F2ZSBwb3NpdGlvbiB3aGVuIGRyYWcgZW5kc1xuICAgICAgV2luZG93U3RhdGVTZXJ2aWNlLnNhdmVQb3NpdGlvbih0aGlzLmN1cnJlbnRYLCB0aGlzLmN1cnJlbnRZKTtcbiAgICB9XG4gICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5oYW5kbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwibW91c2Vkb3duXCIsXG4gICAgICB0aGlzLmhhbmRsZU1vdXNlRG93bi5iaW5kKHRoaXMpXG4gICAgKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuaGFuZGxlTW91c2VNb3ZlLmJpbmQodGhpcykpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMuaGFuZGxlTW91c2VVcC5iaW5kKHRoaXMpKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgPG1hcnRpbi5iZWNoYXJkQERldkNvbnN1bHQuY2E+XG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIEZpbGU6IC9Vc2Vycy9tYXJ0aW5iZWNoYXJkL2Rldi9jbGF1ZGVleHQvc3JjL3VpL2NvbXBvbmVudHMvRWRpdGFibGVDZWxsLnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKi9cblxuLy8gVUkgY29tcG9uZW50IGZvciBlZGl0aW5nIGZpbGUgbmFtZXMgaW4gdGhlIGRvd25sb2FkIHRhYmxlXG4vLyBUaGUgY2VsbCB0aGF0IGxldHMgeW91IHJlbmFtZSB3aXRob3V0IHRoZSBkcmFtYSFcblxuY29uc3Qgc3R5bGVzID0ge1xuICBjb2xvcnM6IHtcbiAgICBwcmltYXJ5OiBcIiMwMDY2Y2NcIixcbiAgICBwcmltYXJ5SG92ZXI6IFwiIzAwNTJhM1wiLFxuICAgIGJvcmRlcjogXCIjY2NjXCIsXG4gICAgdGV4dDogXCIjMzMzXCIsXG4gICAgdGV4dE11dGVkOiBcIiM2NjZcIixcbiAgICBiYWNrZ3JvdW5kOiBcIiNmOGY5ZmFcIixcbiAgICBlcnJvcjogXCIjZGMzNTQ1XCIsXG4gICAgc3VjY2VzczogXCIjMjhhNzQ1XCIsXG4gIH0sXG4gIHNwYWNpbmc6IHtcbiAgICBzbTogXCI0cHhcIixcbiAgICBtZDogXCI4cHhcIixcbiAgfSxcbiAgYm9yZGVyUmFkaXVzOiBcIjRweFwiLFxuICBmb250U2l6ZToge1xuICAgIHNtOiBcIjEycHhcIixcbiAgICBtZDogXCIxNHB4XCIsXG4gIH0sXG59O1xuXG5pbnRlcmZhY2UgRWRpdGFibGVDZWxsT3B0aW9ucyB7XG4gIGluaXRpYWxWYWx1ZTogc3RyaW5nO1xuICBvblNhdmU6IChuZXdWYWx1ZTogc3RyaW5nKSA9PiB2b2lkO1xuICBvbkNhbmNlbDogKCkgPT4gdm9pZDtcbiAgdmFsaWRhdG9yPzogKHZhbHVlOiBzdHJpbmcpID0+IHN0cmluZyB8IG51bGw7XG59XG5cbmV4cG9ydCBjbGFzcyBFZGl0YWJsZUNlbGwge1xuICBwcml2YXRlIGNvbnRhaW5lcjogSFRNTEVsZW1lbnQ7XG4gIHByaXZhdGUgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG4gIHByaXZhdGUgZXJyb3I6IEhUTUxFbGVtZW50O1xuICBwcml2YXRlIGluaXRpYWxWYWx1ZTogc3RyaW5nO1xuICBwcml2YXRlIHZhbGlkYXRvcjogKHZhbHVlOiBzdHJpbmcpID0+IHN0cmluZyB8IG51bGw7XG4gIHByaXZhdGUgb25TYXZlOiAodmFsdWU6IHN0cmluZykgPT4gdm9pZDtcbiAgcHJpdmF0ZSBvbkNhbmNlbDogKCkgPT4gdm9pZDtcbiAgcHJpdmF0ZSBpc0VkaXRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBFZGl0YWJsZUNlbGxPcHRpb25zKSB7XG4gICAgdGhpcy5pbml0aWFsVmFsdWUgPSBvcHRpb25zLmluaXRpYWxWYWx1ZTtcbiAgICB0aGlzLm9uU2F2ZSA9IG9wdGlvbnMub25TYXZlO1xuICAgIHRoaXMub25DYW5jZWwgPSBvcHRpb25zLm9uQ2FuY2VsO1xuICAgIHRoaXMudmFsaWRhdG9yID0gb3B0aW9ucy52YWxpZGF0b3IgfHwgKCgpID0+IG51bGwpO1xuXG4gICAgdGhpcy5jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGdhcDogJHtzdHlsZXMuc3BhY2luZy5zbX07XG4gICAgICBgO1xuXG4gICAgLy8gQ3JlYXRlIGlucHV0IGZpZWxkXG4gICAgdGhpcy5pbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICB0aGlzLmlucHV0LnR5cGUgPSBcInRleHRcIjtcbiAgICB0aGlzLmlucHV0LnZhbHVlID0gdGhpcy5pbml0aWFsVmFsdWU7XG4gICAgdGhpcy5pbnB1dC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwYWRkaW5nOiAke3N0eWxlcy5zcGFjaW5nLnNtfSAke3N0eWxlcy5zcGFjaW5nLm1kfTtcbiAgICAgICAgYm9yZGVyOiAxcHggc29saWQgJHtzdHlsZXMuY29sb3JzLmJvcmRlcn07XG4gICAgICAgIGJvcmRlci1yYWRpdXM6ICR7c3R5bGVzLmJvcmRlclJhZGl1c307XG4gICAgICAgIGZvbnQtc2l6ZTogJHtzdHlsZXMuZm9udFNpemUubWR9O1xuICAgICAgICB3aWR0aDogY2FsYygxMDAlIC0gJHtzdHlsZXMuc3BhY2luZy5tZH0gKiAyKTtcbiAgICAgIGA7XG5cbiAgICAvLyBDcmVhdGUgZXJyb3IgbWVzc2FnZSBlbGVtZW50XG4gICAgdGhpcy5lcnJvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5lcnJvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBjb2xvcjogJHtzdHlsZXMuY29sb3JzLmVycm9yfTtcbiAgICAgICAgZm9udC1zaXplOiAke3N0eWxlcy5mb250U2l6ZS5zbX07XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICBgO1xuXG4gICAgLy8gQ3JlYXRlIGJ1dHRvbiBjb250YWluZXJcbiAgICBjb25zdCBidXR0b25Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJ1dHRvbkNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBnYXA6ICR7c3R5bGVzLnNwYWNpbmcuc219O1xuICAgICAgICBtYXJnaW4tdG9wOiAke3N0eWxlcy5zcGFjaW5nLnNtfTtcbiAgICAgIGA7XG5cbiAgICAvLyBDcmVhdGUgc2F2ZSBidXR0b25cbiAgICBjb25zdCBzYXZlQnV0dG9uID0gdGhpcy5jcmVhdGVCdXR0b24oXG4gICAgICBcIlNhdmVcIixcbiAgICAgICgpID0+IHRoaXMuaGFuZGxlU2F2ZSgpLFxuICAgICAgXCJwcmltYXJ5XCJcbiAgICApO1xuXG4gICAgLy8gQ3JlYXRlIGNhbmNlbCBidXR0b25cbiAgICBjb25zdCBjYW5jZWxCdXR0b24gPSB0aGlzLmNyZWF0ZUJ1dHRvbihcbiAgICAgIFwiQ2FuY2VsXCIsXG4gICAgICAoKSA9PiB0aGlzLmhhbmRsZUNhbmNlbCgpLFxuICAgICAgXCJzZWNvbmRhcnlcIlxuICAgICk7XG5cbiAgICBidXR0b25Db250YWluZXIuYXBwZW5kQ2hpbGQoc2F2ZUJ1dHRvbik7XG4gICAgYnV0dG9uQ29udGFpbmVyLmFwcGVuZENoaWxkKGNhbmNlbEJ1dHRvbik7XG5cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmlucHV0KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVycm9yKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChidXR0b25Db250YWluZXIpO1xuXG4gICAgLy8gQWRkIGtleWJvYXJkIGhhbmRsZXJzXG4gICAgdGhpcy5pbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmhhbmRsZVNhdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoZS5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmhhbmRsZUNhbmNlbCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVCdXR0b24oXG4gICAgdGV4dDogc3RyaW5nLFxuICAgIG9uQ2xpY2s6ICgpID0+IHZvaWQsXG4gICAgdmFyaWFudDogXCJwcmltYXJ5XCIgfCBcInNlY29uZGFyeVwiXG4gICk6IEhUTUxCdXR0b25FbGVtZW50IHtcbiAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgYnV0dG9uLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBhZGRpbmc6ICR7c3R5bGVzLnNwYWNpbmcuc219ICR7c3R5bGVzLnNwYWNpbmcubWR9O1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6ICR7c3R5bGVzLmJvcmRlclJhZGl1c307XG4gICAgICAgIGZvbnQtc2l6ZTogJHtzdHlsZXMuZm9udFNpemUuc219O1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIGJhY2tncm91bmQ6ICR7XG4gICAgICAgICAgdmFyaWFudCA9PT0gXCJwcmltYXJ5XCJcbiAgICAgICAgICAgID8gc3R5bGVzLmNvbG9ycy5wcmltYXJ5XG4gICAgICAgICAgICA6IHN0eWxlcy5jb2xvcnMuYmFja2dyb3VuZFxuICAgICAgICB9O1xuICAgICAgICBjb2xvcjogJHt2YXJpYW50ID09PSBcInByaW1hcnlcIiA/IFwid2hpdGVcIiA6IHN0eWxlcy5jb2xvcnMudGV4dH07XG4gICAgICAgIGJvcmRlcjogMXB4IHNvbGlkICR7XG4gICAgICAgICAgdmFyaWFudCA9PT0gXCJwcmltYXJ5XCIgPyBcInRyYW5zcGFyZW50XCIgOiBzdHlsZXMuY29sb3JzLmJvcmRlclxuICAgICAgICB9O1xuICAgICAgYDtcblxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsICgpID0+IHtcbiAgICAgIGJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kID1cbiAgICAgICAgdmFyaWFudCA9PT0gXCJwcmltYXJ5XCJcbiAgICAgICAgICA/IHN0eWxlcy5jb2xvcnMucHJpbWFyeUhvdmVyXG4gICAgICAgICAgOiBzdHlsZXMuY29sb3JzLmJvcmRlcjtcbiAgICB9KTtcblxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgKCkgPT4ge1xuICAgICAgYnV0dG9uLnN0eWxlLmJhY2tncm91bmQgPVxuICAgICAgICB2YXJpYW50ID09PSBcInByaW1hcnlcIlxuICAgICAgICAgID8gc3R5bGVzLmNvbG9ycy5wcmltYXJ5XG4gICAgICAgICAgOiBzdHlsZXMuY29sb3JzLmJhY2tncm91bmQ7XG4gICAgfSk7XG5cbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2spO1xuICAgIHJldHVybiBidXR0b247XG4gIH1cblxuICBwcml2YXRlIHNob3dFcnJvcihtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmVycm9yLnRleHRDb250ZW50ID0gbWVzc2FnZTtcbiAgICB0aGlzLmVycm9yLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgdGhpcy5pbnB1dC5zdHlsZS5ib3JkZXJDb2xvciA9IHN0eWxlcy5jb2xvcnMuZXJyb3I7XG4gIH1cblxuICBwcml2YXRlIGNsZWFyRXJyb3IoKTogdm9pZCB7XG4gICAgdGhpcy5lcnJvci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgdGhpcy5pbnB1dC5zdHlsZS5ib3JkZXJDb2xvciA9IHN0eWxlcy5jb2xvcnMuYm9yZGVyO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTYXZlKCk6IHZvaWQge1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy5pbnB1dC52YWx1ZS50cmltKCk7XG4gICAgY29uc3QgZXJyb3IgPSB0aGlzLnZhbGlkYXRvcihuZXdWYWx1ZSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRoaXMuc2hvd0Vycm9yKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyRXJyb3IoKTtcbiAgICB0aGlzLm9uU2F2ZShuZXdWYWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUNhbmNlbCgpOiB2b2lkIHtcbiAgICB0aGlzLmlucHV0LnZhbHVlID0gdGhpcy5pbml0aWFsVmFsdWU7XG4gICAgdGhpcy5jbGVhckVycm9yKCk7XG4gICAgdGhpcy5vbkNhbmNlbCgpO1xuICB9XG5cbiAgcHVibGljIGdldEVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG4gIHB1YmxpYyBmb2N1cygpOiB2b2lkIHtcbiAgICB0aGlzLmlucHV0LmZvY3VzKCk7XG4gICAgLy8gU2VsZWN0IGFsbCB0ZXh0IGV4Y2VwdCBleHRlbnNpb25cbiAgICBjb25zdCBsYXN0RG90ID0gdGhpcy5pbnB1dC52YWx1ZS5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGxhc3REb3QgPiAwKSB7XG4gICAgICB0aGlzLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKDAsIGxhc3REb3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlucHV0LnNlbGVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogL1VzZXJzL21hcnRpbmJlY2hhcmQvZGV2L2NsYXVkZWV4dC9zcmMvdWkvY29tcG9uZW50cy9GbG9hdGluZ1dpbmRvdy50c1xuICogVGhpcyB3YXMgZ2VuZXJhdGVkIGJ5IENsYXVkZSBTb25uZXQgMy41LCB3aXRoIHRoZSBhc3Npc3RhbmNlIG9mIG15IGh1bWFuIG1lbnRvclxuICovXG5cbmltcG9ydCB0eXBlIHsgRmxvYXRpbmdXaW5kb3dFbGVtZW50cyB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgV2luZG93U3RhdGVTZXJ2aWNlIH0gZnJvbSBcIi4uLy4uL3NlcnZpY2VzL1dpbmRvd1N0YXRlU2VydmljZVwiO1xuaW1wb3J0IHsgSGVscE1hbmFnZXIgfSBmcm9tIFwiLi9IZWxwTWFuYWdlclwiO1xuaW1wb3J0IHsgVUlTdGF0ZU1hbmFnZXIgfSBmcm9tIFwiLi9VSVN0YXRlTWFuYWdlclwiO1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIGZsb2F0aW5nIHdpbmRvdyBpbnRlcmZhY2UgZm9yIHRoZSBleHRlbnNpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBGbG9hdGluZ1dpbmRvdyB7XG4gIHByaXZhdGUgZWxlbWVudDogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBvdXRwdXREaXY6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgdWlTdGF0ZU1hbmFnZXI6IFVJU3RhdGVNYW5hZ2VyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgaGVscE1hbmFnZXI6IEhlbHBNYW5hZ2VyIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSByZWFkb25seSB0ZW1wbGF0ZSA9IGBcbiAgICA8ZGl2IGNsYXNzPVwiZmxvYXRpbmctd2luZG93XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwic3RhdHVzIHJlYWR5XCI+XG4gICAgICAgIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBnYXA6IDVweDsgZmxleC1ncm93OiAxO1wiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3RhdHVzLWxhYmVsXCI+Q2xhdWRlUFMgLSA8L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGF0dXMtdGV4dFwiPlJFQURZPC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwic3RhdHVzLWRldGFpbHNcIj48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8YnV0dG9uIGlkPVwibWluaW1pemVCdXR0b25cIiBzdHlsZT1cImZvbnQtc2l6ZTogMTJweDsgcGFkZGluZzogMnB4IDhweDtcIj5fPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gaWQ9XCJtb2RlVG9nZ2xlQnV0dG9uXCIgdGl0bGU9XCJTd2l0Y2ggdG8gU2NyaXB0IE1vZGVcIiBzdHlsZT1cImZvbnQtc2l6ZTogMTJweDsgcGFkZGluZzogMnB4IDhweDtcIj7wn5OdPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gaWQ9XCJoZWxwQnV0dG9uXCIgc3R5bGU9XCJmb250LXNpemU6IDEycHg7IHBhZGRpbmc6IDJweCA4cHg7XCI+PzwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzY3JpcHQtbW9kZVwiIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic2NyaXB0LWNvbnRhaW5lclwiPlxuICAgICAgICAgICAgPHRleHRhcmVhIGlkPVwic2NyaXB0VGV4dFwiIHBsYWNlaG9sZGVyPVwiU2ltcGxlIHByb21wdDpcblR5cGUgeW91ciBwcm9tcHQgaGVyZVxuXG4tLSBvciAtLVxuXG4vcmVwZWF0IE1BWCAzIC9zdG9wX2lmIHN1Y2Nlc3NcbllvdXIgcHJvbXB0IGhlcmVcblxuLS0gb3IgLS0gXG5cbi9yZXBlYXQgTUFYIDMgL3N0b3BfaWZfbm90IGZhaWx1cmVcbllvdXIgcHJvbXB0IGhlcmVcIj48L3RleHRhcmVhPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInJlc2l6ZS1oYW5kbGVcIj48L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8YnV0dG9uIGlkPVwicnVuU2NyaXB0XCI+UnVuIFNjcmlwdDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNpbXBsZS1tb2RlXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInNpbXBsZS1idXR0b25zXCIgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBnYXA6IDhweDsgbWFyZ2luLWJvdHRvbTogMTBweDtcIj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJjb21tYW5kLWJ1dHRvbiBzZWFyY2gtYnV0dG9uXCIgZGF0YS1jb21tYW5kPVwiL3NlYXJjaF9wcm9qZWN0IFwiIGRhdGEtbm8tYXV0by1ydW49XCJ0cnVlXCI+U2VhcmNoPC9idXR0b24+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiY29tbWFuZC1idXR0b24gcHJvamVjdC1idXR0b25cIiBkYXRhLWNvbW1hbmQ9XCIvcHJvamVjdFwiPlByb2plY3Q8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJjb21tYW5kLWJ1dHRvblwiIGRhdGEtY29tbWFuZD1cIi9jb252ZXJzYXRpb25cIj5Db252ZXJzYXRpb248L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJjb21tYW5kLWJ1dHRvblwiIGRhdGEtY29tbWFuZD1cIi9hcnRpZmFjdHNcIj5BcnRpZmFjdHM8L2J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicHJvamVjdC1zZWFyY2gtY29udGFpbmVyXCI+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cInByb2plY3Qtc2VhcmNoLWlucHV0XCIgcGxhY2Vob2xkZXI9XCJFbnRlciBzZWFyY2ggY3JpdGVyaWEuLi5cIiAvPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInByb2plY3Qtc2VhcmNoLWdseXBoXCI+8J+UjTwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInByb2plY3Qtc2VhcmNoLWNhbmNlbFwiPkNhbmNlbDwvYnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm91dHB1dC1jb250YWluZXJcIj5cbiAgICAgICAgICA8ZGl2IGlkPVwic2NyaXB0T3V0cHV0XCI+PC9kaXY+XG4gICAgICAgICAgPGRpdiBpZD1cImNvbGxhcHNlQnV0dG9uXCIgc3R5bGU9XCJjdXJzb3I6IHBvaW50ZXI7IHVzZXItc2VsZWN0OiBub25lOyBwYWRkaW5nOiA1cHg7XCI+4pa8PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGA7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluamVjdHMgdGhlIGZsb2F0aW5nIHdpbmRvdyBpbnRvIHRoZSBET00uXG4gICAqIEByZXR1cm5zIFRoZSBmbG9hdGluZyB3aW5kb3cgZWxlbWVudFxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHdpbmRvdyBjcmVhdGlvbiBmYWlsc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGNyZWF0ZSgpOiBQcm9taXNlPEhUTUxFbGVtZW50PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gdGhpcy50ZW1wbGF0ZS50cmltKCk7XG5cbiAgICBjb25zdCB3aW5kb3cgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcihcIi5mbG9hdGluZy13aW5kb3dcIik7XG4gICAgaWYgKCF3aW5kb3cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgZmxvYXRpbmcgd2luZG93XCIpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICB0aGlzLmVsZW1lbnQgPSB3aW5kb3cgYXMgSFRNTEVsZW1lbnQ7XG4gICAgdGhpcy5vdXRwdXREaXYgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIiNzY3JpcHRPdXRwdXRcIikgYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICAvLyBHZXQgZWxlbWVudHMgYW5kIGJpbmQgZXZlbnQgbGlzdGVuZXJzXG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmdldEVsZW1lbnRzKCk7XG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoZWxlbWVudHMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBoZWxwIG1hbmFnZXJcbiAgICB0aGlzLmhlbHBNYW5hZ2VyID0gbmV3IEhlbHBNYW5hZ2VyKHRoaXMub3V0cHV0RGl2KTtcblxuICAgIC8vIFJlc3RvcmUgc2F2ZWQgd2luZG93IHN0YXRlXG4gICAgV2luZG93U3RhdGVTZXJ2aWNlLmFwcGx5U3RhdGUodGhpcy5lbGVtZW50KTtcblxuICAgIC8vIFNldCB1cCByZXNpemUgZnVuY3Rpb25hbGl0eVxuICAgIHRoaXMuc2V0dXBSZXNpemVIYW5kbGVzKCk7XG5cbiAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgdGhlIHJlc2l6ZSBoYW5kbGUgZnVuY3Rpb25hbGl0eVxuICAgKi9cbiAgcHJpdmF0ZSBzZXR1cFJlc2l6ZUhhbmRsZXMoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQpIHJldHVybjtcblxuICAgIGNvbnN0IHNjcmlwdENvbnRhaW5lciA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgXCIuc2NyaXB0LWNvbnRhaW5lclwiXG4gICAgKSBhcyBIVE1MRWxlbWVudDtcbiAgICBjb25zdCBzY3JpcHRUZXh0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICBcIiNzY3JpcHRUZXh0XCJcbiAgICApIGFzIEhUTUxUZXh0QXJlYUVsZW1lbnQ7XG4gICAgY29uc3QgcmVzaXplSGFuZGxlID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICBcIi5yZXNpemUtaGFuZGxlXCJcbiAgICApIGFzIEhUTUxFbGVtZW50O1xuXG4gICAgaWYgKCFzY3JpcHRDb250YWluZXIgfHwgIXNjcmlwdFRleHQgfHwgIXJlc2l6ZUhhbmRsZSkgcmV0dXJuO1xuXG4gICAgbGV0IHN0YXJ0WSA9IDA7XG4gICAgbGV0IHN0YXJ0SGVpZ2h0ID0gMDtcbiAgICBsZXQgaXNEcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgcmVzaXplSGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgKGUpID0+IHtcbiAgICAgIGlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgc3RhcnRZID0gZS5jbGllbnRZO1xuICAgICAgc3RhcnRIZWlnaHQgPSBzY3JpcHRUZXh0Lm9mZnNldEhlaWdodDtcblxuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSBcInJvdy1yZXNpemVcIjtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUudXNlclNlbGVjdCA9IFwibm9uZVwiO1xuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAoZSkgPT4ge1xuICAgICAgaWYgKCFpc0RyYWdnaW5nKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IGRlbHRhWSA9IGUuY2xpZW50WSAtIHN0YXJ0WTtcbiAgICAgIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KDEwMCwgc3RhcnRIZWlnaHQgKyBkZWx0YVkpO1xuXG4gICAgICBzY3JpcHRUZXh0LnN0eWxlLmhlaWdodCA9IGAke25ld0hlaWdodH1weGA7XG4gICAgICBXaW5kb3dTdGF0ZVNlcnZpY2Uuc2F2ZVNjcmlwdEhlaWdodChgJHtuZXdIZWlnaHR9cHhgKTtcbiAgICB9KTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsICgpID0+IHtcbiAgICAgIGlmICghaXNEcmFnZ2luZykgcmV0dXJuO1xuICAgICAgaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSBcIlwiO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS51c2VyU2VsZWN0ID0gXCJcIjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnMgdG8gVUkgZWxlbWVudHNcbiAgICovXG4gIHByaXZhdGUgYmluZEV2ZW50TGlzdGVuZXJzKGVsZW1lbnRzOiBGbG9hdGluZ1dpbmRvd0VsZW1lbnRzKTogdm9pZCB7XG4gICAgLy8gQ29tbWFuZCBidXR0b24gaGFuZGxlcnNcbiAgICBlbGVtZW50cy53aW5kb3cucXVlcnlTZWxlY3RvckFsbChcIi5jb21tYW5kLWJ1dHRvblwiKS5mb3JFYWNoKChidXR0b24pID0+IHtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBjb21tYW5kID0gYnV0dG9uLmdldEF0dHJpYnV0ZShcImRhdGEtY29tbWFuZFwiKTtcbiAgICAgICAgaWYgKGNvbW1hbmQpIHtcbiAgICAgICAgICBpZiAoYnV0dG9uLmNsYXNzTGlzdC5jb250YWlucyhcInNlYXJjaC1idXR0b25cIikpIHtcbiAgICAgICAgICAgIC8vIFNob3cgc2VhcmNoIFVJIGZvciBzZWFyY2ggYnV0dG9uXG4gICAgICAgICAgICBjb25zdCBzZWFyY2hDb250YWluZXIgPSBlbGVtZW50cy53aW5kb3cucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgXCIucHJvamVjdC1zZWFyY2gtY29udGFpbmVyXCJcbiAgICAgICAgICAgICkgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoc2VhcmNoQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIHNlYXJjaENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICBjb25zdCBzZWFyY2hJbnB1dCA9IHNlYXJjaENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICAgIFwiLnByb2plY3Qtc2VhcmNoLWlucHV0XCJcbiAgICAgICAgICAgICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICAgICAgICBpZiAoc2VhcmNoSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBvdGhlciBidXR0b25zLCBqdXN0IGV4ZWN1dGUgdGhlIGNvbW1hbmRcbiAgICAgICAgICAgIGVsZW1lbnRzLnNjcmlwdFRleHQudmFsdWUgPSBjb21tYW5kO1xuICAgICAgICAgICAgZWxlbWVudHMucnVuQnV0dG9uLmNsaWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFByb2plY3Qgc2VhcmNoIGhhbmRsZXJzXG4gICAgY29uc3Qgc2VhcmNoQ29udGFpbmVyID0gZWxlbWVudHMud2luZG93LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICBcIi5wcm9qZWN0LXNlYXJjaC1jb250YWluZXJcIlxuICAgICkgYXMgSFRNTEVsZW1lbnQ7XG4gICAgY29uc3Qgc2VhcmNoSW5wdXQgPSBzZWFyY2hDb250YWluZXI/LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICBcIi5wcm9qZWN0LXNlYXJjaC1pbnB1dFwiXG4gICAgKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgIGNvbnN0IHNlYXJjaEdseXBoID0gc2VhcmNoQ29udGFpbmVyPy5xdWVyeVNlbGVjdG9yKFxuICAgICAgXCIucHJvamVjdC1zZWFyY2gtZ2x5cGhcIlxuICAgICkgYXMgSFRNTEJ1dHRvbkVsZW1lbnQ7XG4gICAgY29uc3Qgc2VhcmNoQ2FuY2VsID0gc2VhcmNoQ29udGFpbmVyPy5xdWVyeVNlbGVjdG9yKFxuICAgICAgXCIucHJvamVjdC1zZWFyY2gtY2FuY2VsXCJcbiAgICApIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuXG4gICAgY29uc3QgZXhlY3V0ZVByb2plY3RTZWFyY2ggPSAoKSA9PiB7XG4gICAgICBpZiAoc2VhcmNoSW5wdXQgJiYgc2VhcmNoSW5wdXQudmFsdWUudHJpbSgpKSB7XG4gICAgICAgIC8vIEV4ZWN1dGUgc2VhcmNoIGluIHNpbXBsZSBtb2RlXG4gICAgICAgIGVsZW1lbnRzLnNjcmlwdFRleHQudmFsdWUgPSBgL3NlYXJjaF9wcm9qZWN0ICR7c2VhcmNoSW5wdXQudmFsdWUudHJpbSgpfWA7XG4gICAgICAgIGVsZW1lbnRzLnJ1bkJ1dHRvbi5jbGljaygpO1xuXG4gICAgICAgIC8vIFNob3cgY2FuY2VsIGJ1dHRvblxuICAgICAgICBpZiAoc2VhcmNoQ2FuY2VsKSB7XG4gICAgICAgICAgc2VhcmNoQ2FuY2VsLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgc2VhcmNoQ2FuY2VsLnRleHRDb250ZW50ID0gXCJDYW5jZWxcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBjYW5jZWxTZWFyY2ggPSAoKSA9PiB7XG4gICAgICAvLyBIaWRlIHNlYXJjaCBVSSBhbmQgY2FuY2VsIGJ1dHRvblxuICAgICAgaWYgKHNlYXJjaENvbnRhaW5lcikge1xuICAgICAgICBzZWFyY2hDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgfVxuICAgICAgaWYgKHNlYXJjaElucHV0KSB7XG4gICAgICAgIHNlYXJjaElucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChzZWFyY2hDYW5jZWwpIHtcbiAgICAgICAgc2VhcmNoQ2FuY2VsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xpY2sgdGhlIHJ1biBidXR0b24gdG8gdHJpZ2dlciBjYW5jZWwgaW4gd29ya2luZyBzdGF0ZVxuICAgICAgZWxlbWVudHMucnVuQnV0dG9uLmNsaWNrKCk7XG4gICAgfTtcblxuICAgIGlmIChzZWFyY2hJbnB1dCkge1xuICAgICAgc2VhcmNoSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKGUpID0+IHtcbiAgICAgICAgaWYgKGUua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZXhlY3V0ZVByb2plY3RTZWFyY2goKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgIGNhbmNlbFNlYXJjaCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc2VhcmNoR2x5cGgpIHtcbiAgICAgIHNlYXJjaEdseXBoLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBleGVjdXRlUHJvamVjdFNlYXJjaCk7XG4gICAgfVxuXG4gICAgaWYgKHNlYXJjaENhbmNlbCkge1xuICAgICAgc2VhcmNoQ2FuY2VsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjYW5jZWxTZWFyY2gpO1xuICAgIH1cblxuICAgIC8vIE1vZGUgdG9nZ2xlIGhhbmRsZXJcbiAgICBlbGVtZW50cy5tb2RlVG9nZ2xlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBpc1NjcmlwdE1vZGUgPVxuICAgICAgICBlbGVtZW50cy5zY3JpcHRNb2RlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgIT09IFwibm9uZVwiO1xuICAgICAgZWxlbWVudHMuc2NyaXB0TW9kZUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gaXNTY3JpcHRNb2RlXG4gICAgICAgID8gXCJub25lXCJcbiAgICAgICAgOiBcImJsb2NrXCI7XG4gICAgICBlbGVtZW50cy5zaW1wbGVNb2RlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBpc1NjcmlwdE1vZGVcbiAgICAgICAgPyBcImJsb2NrXCJcbiAgICAgICAgOiBcIm5vbmVcIjtcbiAgICAgIGVsZW1lbnRzLm1vZGVUb2dnbGVCdXR0b24udGl0bGUgPSBpc1NjcmlwdE1vZGVcbiAgICAgICAgPyBcIlN3aXRjaCB0byBTY3JpcHQgTW9kZVwiXG4gICAgICAgIDogXCJTd2l0Y2ggdG8gQ29tbWFuZCBNb2RlXCI7XG4gICAgICBlbGVtZW50cy5tb2RlVG9nZ2xlQnV0dG9uLnRleHRDb250ZW50ID0gaXNTY3JpcHRNb2RlID8gXCLwn5OdXCIgOiBcIvCflJhcIjtcbiAgICB9KTtcblxuICAgIGVsZW1lbnRzLnJ1bkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT5cbiAgICAgIHRoaXMudWlTdGF0ZU1hbmFnZXI/LnVwZGF0ZUJ1dHRvblN0YXRlcyh0cnVlKVxuICAgICk7XG4gICAgZWxlbWVudHMuaGVscEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT5cbiAgICAgIHRoaXMuaGVscE1hbmFnZXI/LnNob3coKVxuICAgICk7XG5cbiAgICBlbGVtZW50cy5taW5pbWl6ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT5cbiAgICAgIHRoaXMudWlTdGF0ZU1hbmFnZXI/LnRvZ2dsZU1pbmltaXplKClcbiAgICApO1xuXG4gICAgZWxlbWVudHMuY29sbGFwc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+XG4gICAgICB0aGlzLnVpU3RhdGVNYW5hZ2VyPy50b2dnbGVDb2xsYXBzZSgpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYWxsIFVJIGVsZW1lbnRzIG1hbmFnZWQgYnkgdGhlIGZsb2F0aW5nIHdpbmRvdy5cbiAgICogQHJldHVybnMgT2JqZWN0IGNvbnRhaW5pbmcgYWxsIFVJIGVsZW1lbnRzXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgYW55IGVsZW1lbnQgaXMgbm90IGZvdW5kXG4gICAqL1xuICBwdWJsaWMgZ2V0RWxlbWVudHMoKTogRmxvYXRpbmdXaW5kb3dFbGVtZW50cyB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZsb2F0aW5nIHdpbmRvdyBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudHMgPSB7XG4gICAgICB3aW5kb3c6IHRoaXMuZWxlbWVudCxcbiAgICAgIHN0YXR1czogdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuc3RhdHVzXCIpLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuc3RhdHVzLXRleHRcIiksXG4gICAgICBzdGF0dXNEZXRhaWxzOiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5zdGF0dXMtZGV0YWlsc1wiKSxcbiAgICAgIHNjcmlwdFRleHQ6IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiI3NjcmlwdFRleHRcIiksXG4gICAgICBydW5CdXR0b246IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiI3J1blNjcmlwdFwiKSxcbiAgICAgIG91dHB1dDogdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjc2NyaXB0T3V0cHV0XCIpLFxuICAgICAgaGVscEJ1dHRvbjogdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjaGVscEJ1dHRvblwiKSxcbiAgICAgIGNvbGxhcHNlQnV0dG9uOiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIiNjb2xsYXBzZUJ1dHRvblwiKSxcbiAgICAgIG1pbmltaXplQnV0dG9uOiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIiNtaW5pbWl6ZUJ1dHRvblwiKSxcbiAgICAgIG1vZGVUb2dnbGVCdXR0b246IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiI21vZGVUb2dnbGVCdXR0b25cIiksXG4gICAgICBzY3JpcHRNb2RlQ29udGFpbmVyOiB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5zY3JpcHQtbW9kZVwiKSxcbiAgICAgIHNpbXBsZU1vZGVDb250YWluZXI6IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLnNpbXBsZS1tb2RlXCIpLFxuICAgIH07XG5cbiAgICAvLyBWYWxpZGF0ZSBhbGwgZWxlbWVudHMgZXhpc3RcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhlbGVtZW50cykpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBlbGVtZW50OiAke2tleX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUeXBlIGFzc2VydGlvbiBpcyBzYWZlIGhlcmUgYmVjYXVzZSB3ZSB2YWxpZGF0ZWQgYWxsIGVsZW1lbnRzIGV4aXN0XG4gICAgcmV0dXJuIGVsZW1lbnRzIGFzIEZsb2F0aW5nV2luZG93RWxlbWVudHM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgVUkgc3RhdGUgbWFuYWdlciAtIGNyaXRpY2FsIGZvciB3aW5kb3cgc3RhdGUgbWFuYWdlbWVudFxuICAgKi9cbiAgcHVibGljIHNldFVJU3RhdGVNYW5hZ2VyKG1hbmFnZXI6IFVJU3RhdGVNYW5hZ2VyKTogdm9pZCB7XG4gICAgdGhpcy51aVN0YXRlTWFuYWdlciA9IG1hbmFnZXI7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZmxvYXRpbmcgd2luZG93IGZyb20gdGhlIERPTS5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIC8vIFNhdmUgd2luZG93IHN0YXRlIGJlZm9yZSByZW1vdmFsXG4gICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgV2luZG93U3RhdGVTZXJ2aWNlLnNhdmVHZW9tZXRyeShcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLndpZHRoLFxuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0XG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQ/LnBhcmVudEVsZW1lbnQ/LnJlbW92ZSgpO1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5vdXRwdXREaXYgPSBudWxsO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogL1VzZXJzL21hcnRpbmJlY2hhcmQvZGV2L2NsYXVkZWV4dC9zcmMvdWkvY29tcG9uZW50cy9IZWxwTWFuYWdlci50c1xuICogVGhpcyB3YXMgZ2VuZXJhdGVkIGJ5IENsYXVkZSBTb25uZXQgMy41LCB3aXRoIHRoZSBhc3Npc3RhbmNlIG9mIG15IGh1bWFuIG1lbnRvclxuICovXG5cbi8qKlxuICogTWFuYWdlcyBoZWxwIHRleHQgZGlzcGxheSBhbmQgZm9ybWF0dGluZyBmb3IgdGhlIGV4dGVuc2lvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhlbHBNYW5hZ2VyIHtcbiAgcHJpdmF0ZSByZWFkb25seSBvdXRwdXRFbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgSEVMUF9URVhUID0gYFxuICAgIENsYXVkZVNjcmlwdCB2MS41XG4gICAgXG4gICAgMS4gU2ltcGxlIFByb21wdDpcbiAgICBKdXN0IHR5cGUgeW91ciBwcm9tcHQgYW5kIGl0IHdpbGwgYmUgc2VudCBvbmNlLlxuICAgIFxuICAgIDIuIENvbW1hbmRzOlxuICAgIFxuICAgIEJhc2ljIENvbW1hbmRzOlxuICAgIC9kW29jc10gLSBMaXN0IGF2YWlsYWJsZSBkb2N1bWVudHNcbiAgICAvcFtyb2plY3RdIC0gTGlzdCBjb252ZXJzYXRpb25zIGluIGN1cnJlbnQgcHJvamVjdFxuICAgIFxuICAgIENvbnRlbnQgQ29tbWFuZHM6XG4gICAgL2Nbb252ZXJzYXRpb25dIC0gRXhwb3J0IGNvbnZlcnNhdGlvbiB3aXRob3V0IGFydGlmYWN0c1xuICAgIC9jW29udmVyc2F0aW9uXSAvYVtydGlmYWN0c10gLSBFeHBvcnQgY29udmVyc2F0aW9uIGluY2x1ZGluZyBhcnRpZmFjdHNcbiAgICAvY1tvbnZlcnNhdGlvbl0gL21bdWx0aXBsZV0gLSBFeHBvcnQgYXJ0aWZhY3RzIGFzIHNlcGFyYXRlIGZpbGVzXG4gICAgL2FbcnRpZmFjdHNdIC0gRXhwb3J0IG9ubHkgYXJ0aWZhY3RzIGFzIG1hcmtkb3duXG4gICAgL2FbcnRpZmFjdHNdIC9tW3VsdGlwbGVdIC0gRXhwb3J0IGFydGlmYWN0cyBhcyBzZXBhcmF0ZSBmaWxlc1xuICAgIFxuICAgIFByb2plY3QgQ29tbWFuZHM6XG4gICAgL3NwW3NlYXJjaF9wcm9qZWN0XSBbdGV4dF0gLSBTZWFyY2ggcHJvamVjdCBjb252ZXJzYXRpb25zXG4gICAgL3FwW3F1ZXJ5X3Byb2plY3RdIHByb21wdCAtIFF1ZXJ5IGFsbCBjb252ZXJzYXRpb25zXG4gICAgXG4gICAgQWxpYXMgQ29tbWFuZHM6XG4gICAgL2FsW2lhc10gQG5hbWUgdGV4dCAtIENyZWF0ZSBvciB1cGRhdGUgYW4gYWxpYXNcbiAgICAvZGFbZGVsZXRlX2FsaWFzXSBAbmFtZSAtIERlbGV0ZSBhbiBhbGlhc1xuICAgIC9sYVtsaXN0X2FsaWFzXSAtIExpc3QgYWxsIGFsaWFzZXNcbiAgICBcbiAgICAzLiBMb29wIENvbW1hbmQgRm9ybWF0OlxuICAgIC9yZXBlYXQgWy9tYXggbnVtYmVyXSBbL3N0b3BfaWYgY29uZGl0aW9uXVxuICAgIG9yXG4gICAgL3JlcGVhdCBbL21heCBudW1iZXJdIFsvc3RvcF9pZl9ub3QgY29uZGl0aW9uXVxuICAgIFxuICAgIEV4YW1wbGVzOlxuICAgIFNpbXBsZSBwcm9tcHQ6XG4gICAgVGVsbCBtZSBhIGpva2VcbiAgICBcbiAgICBXaXRoIGFsaWFzZXM6XG4gICAgL2FsaWFzIEBqb2tlIFRlbGwgbWUgeW91ciBiZXN0IGpva2VcbiAgICBAam9rZVxuICAgIFxuICAgIFdpdGggcmVwZWF0IGFuZCBtYXggdHJpZXM6XG4gICAgL3JlcGVhdCAvbWF4IDMgL3N0b3BfaWYgc3VjY2Vzc1xuICAgIFRlbGwgbWUgYSBqb2tlXG4gICAgXG4gICAgV2l0aCByZXBlYXQgdW50aWwgY29uZGl0aW9uOlxuICAgIC9yZXBlYXQgL3N0b3BfaWYgbGF1Z2hcbiAgICBUZWxsIG1lIGEgam9rZVxuICAgIFxuICAgIE5vdGU6IEFsbCBjb21tYW5kIGtleXdvcmRzIG5vdyBzdGFydCB3aXRoIC8gZm9yIGNvbnNpc3RlbmN5YC50cmltKCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSGVscE1hbmFnZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBvdXRwdXRFbGVtZW50IC0gRWxlbWVudCB0byBkaXNwbGF5IGhlbHAgdGV4dCBpblxuICAgKi9cbiAgY29uc3RydWN0b3Iob3V0cHV0RWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICB0aGlzLm91dHB1dEVsZW1lbnQgPSBvdXRwdXRFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXlzIHRoZSBoZWxwIHRleHQgaW4gdGhlIG91dHB1dCBlbGVtZW50LlxuICAgKi9cbiAgcHVibGljIHNob3coKTogdm9pZCB7XG4gICAgdGhpcy5vdXRwdXRFbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgSGVscE1hbmFnZXIuSEVMUF9URVhULnNwbGl0KFwiXFxuXCIpLmZvckVhY2goKGxpbmUpID0+IHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYudGV4dENvbnRlbnQgPSBsaW5lO1xuICAgICAgZGl2LnN0eWxlLndoaXRlU3BhY2UgPSBcInByZVwiO1xuICAgICAgdGhpcy5vdXRwdXRFbGVtZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgaGVscCB0ZXh0IGNvbnRlbnQgZHluYW1pY2FsbHkuXG4gICAqIEBwYXJhbSBuZXdUZXh0IC0gTmV3IGhlbHAgdGV4dCBjb250ZW50XG4gICAqL1xuICBwdWJsaWMgdXBkYXRlQ29udGVudChuZXdUZXh0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLm91dHB1dEVsZW1lbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBuZXdUZXh0XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAgIC5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi50ZXh0Q29udGVudCA9IGxpbmU7XG4gICAgICAgIGRpdi5zdHlsZS53aGl0ZVNwYWNlID0gXCJwcmVcIjtcbiAgICAgICAgdGhpcy5vdXRwdXRFbGVtZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGhlbHAgdGV4dCBkaXNwbGF5LlxuICAgKi9cbiAgcHVibGljIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMub3V0cHV0RWxlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogL1VzZXJzL21hcnRpbmJlY2hhcmQvZGV2L2NsYXVkZWV4dC9zcmMvdWkvY29tcG9uZW50cy9TZWFyY2hSZXN1bHRQcmV2aWV3LnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKlxuICogQ29tcG9uZW50IGZvciBkaXNwbGF5aW5nIGRldGFpbGVkIHNlYXJjaCByZXN1bHRzIGluIGEgbW9kYWwgd2luZG93XG4gKi9cblxuaW1wb3J0IHR5cGUgeyBTZWFyY2hSZXN1bHRJbmZvIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5pbXBvcnQgeyBDb252ZXJzYXRpb25SZXRyaWV2YWwgfSBmcm9tIFwiLi4vLi4vc2VydmljZXMvQ29udmVyc2F0aW9uUmV0cmlldmFsXCI7XG5pbXBvcnQgeyBnZXRPcmdhbml6YXRpb25JZCB9IGZyb20gXCIuLi8uLi91dGlscy9nZXRDbGF1ZGVJZHNcIjtcblxuZXhwb3J0IGNsYXNzIFNlYXJjaFJlc3VsdFByZXZpZXcge1xuICBwcml2YXRlIGRpYWxvZzogSFRNTERpYWxvZ0VsZW1lbnQ7XG4gIHByaXZhdGUgY29udGVudDogSFRNTERpdkVsZW1lbnQ7XG4gIHByaXZhdGUgb25WaWV3Q29udmVyc2F0aW9uOiAoXG4gICAgY29udmVyc2F0aW9uSWQ6IHN0cmluZyxcbiAgICBtZXNzYWdlSWQ6IHN0cmluZ1xuICApID0+IHZvaWQ7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgb25WaWV3Q29udmVyc2F0aW9uOiAoY29udmVyc2F0aW9uSWQ6IHN0cmluZywgbWVzc2FnZUlkOiBzdHJpbmcpID0+IHZvaWRcbiAgKSB7XG4gICAgdGhpcy5kaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGlhbG9nXCIpO1xuICAgIHRoaXMuY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5vblZpZXdDb252ZXJzYXRpb24gPSBvblZpZXdDb252ZXJzYXRpb247XG4gICAgdGhpcy5zZXR1cERpYWxvZygpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cERpYWxvZygpOiB2b2lkIHtcbiAgICAvLyBTdHlsZSB0aGUgZGlhbG9nXG4gICAgdGhpcy5kaWFsb2cuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBhZGRpbmc6IDA7XG4gICAgICBib3JkZXI6IG5vbmU7XG4gICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICBib3gtc2hhZG93OiAwIDRweCAxMnB4IHJnYmEoMCwgMCwgMCwgMC4xNSk7XG4gICAgICBtYXgtd2lkdGg6IDgwMHB4O1xuICAgICAgd2lkdGg6IDkwdnc7XG4gICAgICBtYXgtaGVpZ2h0OiA4MHZoO1xuICAgICAgYmFja2dyb3VuZDogd2hpdGU7XG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICB0b3A6IDUwJTtcbiAgICAgIGxlZnQ6IDUwJTtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgICAgei1pbmRleDogMTAwMDAwMjtcbiAgICBgO1xuXG4gICAgLy8gQ3JlYXRlIGhlYWRlclxuICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgaGVhZGVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwYWRkaW5nOiAxNnB4O1xuICAgICAgYmFja2dyb3VuZDogI2Y4ZjlmYTtcbiAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZGVlMmU2O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBib3JkZXItcmFkaXVzOiA4cHggOHB4IDAgMDtcbiAgICBgO1xuXG4gICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaDJcIik7XG4gICAgdGl0bGUuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIG1hcmdpbjogMDtcbiAgICAgIGZvbnQtc2l6ZTogMThweDtcbiAgICAgIGNvbG9yOiAjMzMzO1xuICAgIGA7XG4gICAgdGl0bGUudGV4dENvbnRlbnQgPSBcIlNlYXJjaCBSZXN1bHQgRGV0YWlsc1wiO1xuXG4gICAgY29uc3QgY2xvc2VCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGNsb3NlQnV0dG9uLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBiYWNrZ3JvdW5kOiBub25lO1xuICAgICAgYm9yZGVyOiBub25lO1xuICAgICAgZm9udC1zaXplOiAyMHB4O1xuICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgY29sb3I6ICM2NjY7XG4gICAgICBwYWRkaW5nOiA0cHggOHB4O1xuICAgIGA7XG4gICAgY2xvc2VCdXR0b24udGV4dENvbnRlbnQgPSBcIsOXXCI7XG4gICAgY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHRoaXMuaGlkZSgpKTtcblxuICAgIGhlYWRlci5hcHBlbmRDaGlsZCh0aXRsZSk7XG4gICAgaGVhZGVyLmFwcGVuZENoaWxkKGNsb3NlQnV0dG9uKTtcblxuICAgIC8vIFN0eWxlIHRoZSBjb250ZW50IGNvbnRhaW5lclxuICAgIHRoaXMuY29udGVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcGFkZGluZzogMTZweDtcbiAgICAgIG1heC1oZWlnaHQ6IGNhbGMoODB2aCAtIDEyMHB4KTtcbiAgICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgYDtcblxuICAgIC8vIEFkZCBjb21wb25lbnRzIHRvIGRpYWxvZ1xuICAgIHRoaXMuZGlhbG9nLmFwcGVuZENoaWxkKGhlYWRlcik7XG4gICAgdGhpcy5kaWFsb2cuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50KTtcblxuICAgIC8vIEFkZCBkaWFsb2cgdG8gZG9jdW1lbnRcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZGlhbG9nKTtcbiAgfVxuXG4gIHByaXZhdGUgc2hvd0Vycm9yKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IGVycm9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBlcnJvckRpdi5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgY29sb3I6ICNkYzM1NDU7XG4gICAgICBwYWRkaW5nOiA4cHggMTJweDtcbiAgICAgIGJhY2tncm91bmQ6ICNmZmY1ZjU7XG4gICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICBtYXJnaW4tdG9wOiA4cHg7XG4gICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgYDtcbiAgICBlcnJvckRpdi50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG5cbiAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGVycm9yIG1lc3NhZ2VzXG4gICAgY29uc3QgZXhpc3RpbmdFcnJvciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtZXJyb3JdXCIpO1xuICAgIGlmIChleGlzdGluZ0Vycm9yKSB7XG4gICAgICBleGlzdGluZ0Vycm9yLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGVycm9yRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtZXJyb3JcIiwgXCJ0cnVlXCIpO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlcnJvckRpdik7XG4gIH1cblxuICAvKipcbiAgICogU2hvd3MgdGhlIHByZXZpZXcgZGlhbG9nIHdpdGggc2VhcmNoIHJlc3VsdCBkZXRhaWxzIG9yIGVycm9yIGluZm9ybWF0aW9uXG4gICAqL1xuICBwdWJsaWMgc2hvdyhyZXN1bHQ6IFNlYXJjaFJlc3VsdEluZm8gfCBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gXCJcIjtcblxuICAgIC8vIElmIHJlc3VsdCBpcyBhIHN0cmluZywgaXQncyBhbiBlcnJvciBtZXNzYWdlXG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGVycm9yU2VjdGlvbiA9IHtcbiAgICAgICAgdGl0bGU6IFwiRXJyb3IgRGV0YWlsc1wiLFxuICAgICAgICBjb250ZW50OiByZXN1bHQsXG4gICAgICAgIHN0eWxlOiBgXG4gICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XG4gICAgICAgICAgY29sb3I6ICNkYzM1NDU7XG4gICAgICAgICAgYmFja2dyb3VuZDogI2ZmZjVmNTtcbiAgICAgICAgICBwYWRkaW5nOiAxMnB4O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgICAgICBib3JkZXItbGVmdDogM3B4IHNvbGlkICNkYzM1NDU7XG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDtcbiAgICAgICAgYCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHNlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgc2VjdGlvbi5zdHlsZS5tYXJnaW5Cb3R0b20gPSBcIjI0cHhcIjtcblxuICAgICAgY29uc3QgaGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoM1wiKTtcbiAgICAgIGhlYWRpbmcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgbWFyZ2luOiAwIDAgOHB4IDA7XG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgY29sb3I6ICMzMzM7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA2MDA7XG4gICAgICBgO1xuICAgICAgaGVhZGluZy50ZXh0Q29udGVudCA9IGVycm9yU2VjdGlvbi50aXRsZTtcblxuICAgICAgY29uc3QgY29udGVudERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50RGl2LnN0eWxlLmNzc1RleHQgPSBlcnJvclNlY3Rpb24uc3R5bGU7XG4gICAgICBjb250ZW50RGl2LnRleHRDb250ZW50ID0gZXJyb3JTZWN0aW9uLmNvbnRlbnQ7XG5cbiAgICAgIHNlY3Rpb24uYXBwZW5kQ2hpbGQoaGVhZGluZyk7XG4gICAgICBzZWN0aW9uLmFwcGVuZENoaWxkKGNvbnRlbnREaXYpO1xuICAgICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKHNlY3Rpb24pO1xuXG4gICAgICB0aGlzLmRpYWxvZy5zaG93TW9kYWwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgc2VjdGlvbnMgZm9yIGRpZmZlcmVudCBwYXJ0cyBvZiB0aGUgcmVzdWx0XG4gICAgY29uc3Qgc2VjdGlvbnMgPSBbXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiBcIk1hdGNoIFJlYXNvblwiLFxuICAgICAgICBjb250ZW50OiByZXN1bHQubWF0Y2hSZWFzb24sXG4gICAgICAgIHN0eWxlOiBgXG4gICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XG4gICAgICAgICAgY29sb3I6ICMzMzM7XG4gICAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDtcbiAgICAgICAgYCxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHRpdGxlOiBcIlJlbGV2YW50IFNuaXBwZXRcIixcbiAgICAgICAgY29udGVudDogcmVzdWx0LnJlbGV2YW50U25pcHBldCxcbiAgICAgICAgc3R5bGU6IGBcbiAgICAgICAgICBmb250LWZhbWlseTogbW9ub3NwYWNlO1xuICAgICAgICAgIGJhY2tncm91bmQ6ICNmOGY5ZmE7XG4gICAgICAgICAgcGFkZGluZzogMTJweDtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgICAgYm9yZGVyLWxlZnQ6IDNweCBzb2xpZCAjMDA2NmNjO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xuICAgICAgICAgIG92ZXJmbG93LXg6IGF1dG87XG4gICAgICAgICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICAgICAgICAgIGNvbG9yOiAjMzMzO1xuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XG4gICAgICAgIGAsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0aXRsZTogXCJWaWV3IENvbnZlcnNhdGlvblwiLFxuICAgICAgICBjb250ZW50OiBcIkNsaWNrIHRvIHZpZXcgY29udmVyc2F0aW9uIGFuZCBqdW1wIHRvIG1hdGNoaW5nIG1lc3NhZ2VcIixcbiAgICAgICAgc3R5bGU6IGBcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgICAgY29sb3I6ICMwMDY2Y2M7XG4gICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XG4gICAgICAgICAgcGFkZGluZzogOHB4IDEycHg7XG4gICAgICAgICAgYmFja2dyb3VuZDogI2YwZjdmZjtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjJzIGVhc2U7XG4gICAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZTBmMGZmO1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xcHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgYCxcbiAgICAgICAgaXNMaW5rOiB0cnVlLFxuICAgICAgfSxcbiAgICBdO1xuXG4gICAgLy8gQWRkIGVhY2ggc2VjdGlvblxuICAgIHNlY3Rpb25zLmZvckVhY2goKHsgdGl0bGUsIGNvbnRlbnQsIHN0eWxlLCBpc0xpbmsgfSkgPT4ge1xuICAgICAgY29uc3Qgc2VjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBzZWN0aW9uLnN0eWxlLm1hcmdpbkJvdHRvbSA9IFwiMjRweFwiO1xuXG4gICAgICBjb25zdCBoZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgzXCIpO1xuICAgICAgaGVhZGluZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBtYXJnaW46IDAgMCA4cHggMDtcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgICBjb2xvcjogIzMzMztcbiAgICAgICAgZm9udC13ZWlnaHQ6IDYwMDtcbiAgICAgIGA7XG4gICAgICBoZWFkaW5nLnRleHRDb250ZW50ID0gdGl0bGU7XG5cbiAgICAgIGNvbnN0IGNvbnRlbnREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudERpdi5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XG4gICAgICBjb250ZW50RGl2LnRleHRDb250ZW50ID0gY29udGVudDtcblxuICAgICAgaWYgKGlzTGluaykge1xuICAgICAgICBjb250ZW50RGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCBvcmdhbml6YXRpb24gSURcbiAgICAgICAgICAgIGNvbnN0IG9yZ0lkID0gZ2V0T3JnYW5pemF0aW9uSWQoKTtcbiAgICAgICAgICAgIGlmICghb3JnSWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IoXG4gICAgICAgICAgICAgICAgY29udGVudERpdixcbiAgICAgICAgICAgICAgICBcIlVuYWJsZSB0byBnZXQgb3JnYW5pemF0aW9uIElELiBQbGVhc2UgZW5zdXJlIHlvdSdyZSBsb2dnZWQgaW4gdG8gQ2xhdWRlLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm90aWZ5IHBhcmVudCB0byBzaG93IGNvbnZlcnNhdGlvblxuICAgICAgICAgICAgdGhpcy5vblZpZXdDb252ZXJzYXRpb24ocmVzdWx0LmNvbnZlcnNhdGlvbklkLCByZXN1bHQubWVzc2FnZUlkKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBsb2FkIGNvbnZlcnNhdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IoXG4gICAgICAgICAgICAgIGNvbnRlbnREaXYsXG4gICAgICAgICAgICAgIFwiVW5hYmxlIHRvIGxvYWQgY29udmVyc2F0aW9uLiBQbGVhc2UgdHJ5IHJlZnJlc2hpbmcgdGhlIHBhZ2UuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgc2VjdGlvbi5hcHBlbmRDaGlsZChoZWFkaW5nKTtcbiAgICAgIHNlY3Rpb24uYXBwZW5kQ2hpbGQoY29udGVudERpdik7XG4gICAgICB0aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQoc2VjdGlvbik7XG4gICAgfSk7XG5cbiAgICB0aGlzLmRpYWxvZy5zaG93TW9kYWwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgcHJldmlldyBkaWFsb2dcbiAgICovXG4gIHB1YmxpYyBoaWRlKCk6IHZvaWQge1xuICAgIHRoaXMuZGlhbG9nLmNsb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW5zIHVwIHRoZSBjb21wb25lbnRcbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuZGlhbG9nLnJlbW92ZSgpO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogL1VzZXJzL21hcnRpbmJlY2hhcmQvZGV2L2NsYXVkZWV4dC9zcmMvdWkvY29tcG9uZW50cy9TdGF0dXNNYW5hZ2VyLnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBTdGF0dXNTdGF0ZSwgU3RhdHVzQ29uZmlnIH0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5cbi8qKlxuICogUmVxdWlyZWQgZWxlbWVudHMgZm9yIHN0YXR1cyBtYW5hZ2VtZW50XG4gKi9cbmludGVyZmFjZSBTdGF0dXNFbGVtZW50cyB7XG4gIHN0YXR1c0VsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICBzdGF0dXNUZXh0OiBIVE1MRWxlbWVudDtcbiAgc3RhdHVzRGV0YWlsczogSFRNTEVsZW1lbnQ7XG4gIHNjcmlwdElucHV0OiBIVE1MVGV4dEFyZWFFbGVtZW50O1xuICBydW5CdXR0b246IEhUTUxCdXR0b25FbGVtZW50O1xufVxuXG4vKipcbiAqIE1hbmFnZXMgdGhlIGRpc3BsYXkgYW5kIHVwZGF0ZXMgb2Ygc3RhdHVzIGluZm9ybWF0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgU3RhdHVzTWFuYWdlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZWxlbWVudHM6IFN0YXR1c0VsZW1lbnRzO1xuICBwcml2YXRlIGN1cnJlbnRTdGF0ZTogU3RhdHVzU3RhdGUgPSBcInJlYWR5XCI7XG4gIHB1YmxpYyBvbkNhbmNlbDogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgU1RBVFVTX0NPTkZJR1M6IFJlY29yZDxTdGF0dXNTdGF0ZSwgU3RhdHVzQ29uZmlnPiA9IHtcbiAgICByZWFkeTogeyB0ZXh0OiBcIlJFQURZXCIsIGNsYXNzOiBcInJlYWR5XCIgfSxcbiAgICB3b3JraW5nOiB7IHRleHQ6IFwiV09SS0lOR1wiLCBjbGFzczogXCJ3b3JraW5nXCIgfSxcbiAgICBlcnJvcjogeyB0ZXh0OiBcIkVSUk9SXCIsIGNsYXNzOiBcImVycm9yXCIgfSxcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTdGF0dXNNYW5hZ2VyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gZWxlbWVudHMgLSBSZXF1aXJlZCBET00gZWxlbWVudHMgZm9yIHN0YXR1cyBtYW5hZ2VtZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50czogU3RhdHVzRWxlbWVudHMpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgdGhpcy5pbml0aWFsaXplU3RhdHVzKCk7XG4gICAgdGhpcy5zZXR1cENhbmNlbEhhbmRsZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGluaXRpYWwgc3RhdHVzIGRpc3BsYXkuXG4gICAqL1xuICBwcml2YXRlIGluaXRpYWxpemVTdGF0dXMoKTogdm9pZCB7XG4gICAgdGhpcy5zZXRTdGF0dXMoXCJyZWFkeVwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGhhbmRsZXIgZm9yIGNhbmNlbCBidXR0b24gY2xpY2tzXG4gICAqL1xuICBwcml2YXRlIHNldHVwQ2FuY2VsSGFuZGxlcigpOiB2b2lkIHtcbiAgICB0aGlzLmVsZW1lbnRzLnJ1bkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBcIndvcmtpbmdcIiAmJiB0aGlzLm9uQ2FuY2VsKSB7XG4gICAgICAgIHRoaXMub25DYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjdXJyZW50IHN0YXR1cyBkaXNwbGF5LlxuICAgKiBAcGFyYW0gc3RhdGUgLSBOZXcgc3RhdHVzIHN0YXRlIHRvIGRpc3BsYXlcbiAgICogQHBhcmFtIGRldGFpbHMgLSBPcHRpb25hbCBkZXRhaWxzIG1lc3NhZ2VcbiAgICogQHBhcmFtIGNsZWFySW5wdXQgLSBXaGV0aGVyIHRvIGNsZWFyIGlucHV0IG9uIHJlYWR5IHN0YXRlXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc2V0U3RhdHVzKFxuICAgIHN0YXRlOiBTdGF0dXNTdGF0ZSxcbiAgICBkZXRhaWxzOiBzdHJpbmcgPSBcIlwiLFxuICAgIGNsZWFySW5wdXQ6IGJvb2xlYW4gPSB0cnVlXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnNvbGUubG9nKFwiU3RhdHVzOlwiLCBzdGF0ZSwgZGV0YWlscyk7XG5cbiAgICBjb25zdCBjb25maWcgPSBTdGF0dXNNYW5hZ2VyLlNUQVRVU19DT05GSUdTW3N0YXRlXTtcbiAgICB0aGlzLmVsZW1lbnRzLnN0YXR1c1RleHQudGV4dENvbnRlbnQgPSBjb25maWcudGV4dDtcbiAgICB0aGlzLmVsZW1lbnRzLnN0YXR1c0RldGFpbHMudGV4dENvbnRlbnQgPSBkZXRhaWxzO1xuICAgIHRoaXMuZWxlbWVudHMuc3RhdHVzRWxlbWVudC5jbGFzc05hbWUgPSBgc3RhdHVzICR7Y29uZmlnLmNsYXNzfWA7XG5cbiAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMudXBkYXRlSW5wdXRTdGF0ZShzdGF0ZSk7XG4gICAgdGhpcy51cGRhdGVCdXR0b25TdGF0ZShzdGF0ZSk7XG5cbiAgICAvLyBDbGVhciBpbnB1dCBvbiByZWFkeSBzdGF0ZSBpZiBjbGVhcklucHV0IGlzIHRydWVcbiAgICBpZiAoc3RhdGUgPT09IFwicmVhZHlcIiAmJiBjbGVhcklucHV0KSB7XG4gICAgICB0aGlzLmVsZW1lbnRzLnNjcmlwdElucHV0LnZhbHVlID0gXCJcIjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgaW5wdXQgZmllbGQgc3RhdGUgYmFzZWQgb24gc3RhdHVzLlxuICAgKiBAcGFyYW0gc3RhdGUgLSBDdXJyZW50IHN0YXR1cyBzdGF0ZVxuICAgKi9cbiAgcHJpdmF0ZSB1cGRhdGVJbnB1dFN0YXRlKHN0YXRlOiBTdGF0dXNTdGF0ZSk6IHZvaWQge1xuICAgIHRoaXMuZWxlbWVudHMuc2NyaXB0SW5wdXQuZGlzYWJsZWQgPSBzdGF0ZSA9PT0gXCJ3b3JraW5nXCI7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcnVuIGJ1dHRvbiBzdGF0ZSBiYXNlZCBvbiBzdGF0dXMuXG4gICAqIEBwYXJhbSBzdGF0ZSAtIEN1cnJlbnQgc3RhdHVzIHN0YXRlXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZUJ1dHRvblN0YXRlKHN0YXRlOiBTdGF0dXNTdGF0ZSk6IHZvaWQge1xuICAgIGlmIChzdGF0ZSA9PT0gXCJ3b3JraW5nXCIpIHtcbiAgICAgIHRoaXMuZWxlbWVudHMucnVuQnV0dG9uLnRleHRDb250ZW50ID0gXCJDYW5jZWxcIjtcbiAgICAgIHRoaXMuZWxlbWVudHMucnVuQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWxlbWVudHMucnVuQnV0dG9uLnRleHRDb250ZW50ID0gXCJSdW4gU2NyaXB0XCI7XG4gICAgICB0aGlzLmVsZW1lbnRzLnJ1bkJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXR1cyBzdGF0ZS5cbiAgICogQHJldHVybnMgQ3VycmVudCBzdGF0dXMgc3RhdGVcbiAgICovXG4gIHB1YmxpYyBnZXRDdXJyZW50U3RhdGUoKTogU3RhdHVzU3RhdGUge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHN0YXR1cyBpcyBpbiBhIHNwZWNpZmljIHN0YXRlLlxuICAgKiBAcGFyYW0gc3RhdGUgLSBTdGF0ZSB0byBjaGVja1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIGN1cnJlbnQgc3RhdGUgbWF0Y2hlc1xuICAgKi9cbiAgcHVibGljIGlzSW5TdGF0ZShzdGF0ZTogU3RhdHVzU3RhdGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RhdGUgPT09IHN0YXRlO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogc3JjL3VpL2NvbXBvbmVudHMvVUlTdGF0ZU1hbmFnZXIudHNcbiAqIFRoaXMgd2FzIGdlbmVyYXRlZCBieSBDbGF1ZGUgU29ubmV0IDMuNSwgd2l0aCB0aGUgYXNzaXN0YW5jZSBvZiBteSBodW1hbiBtZW50b3JcbiAqXG4gKiBNYW5hZ2VzIFVJIHN0YXRlIGFuZCBsb2dnaW5nIGZvciB0aGUgQ2xhdWRlIGV4dGVuc2lvblxuICogTm90ZTogTWFraW5nIHlvdXIgVUkgc3RhdGUgYXMgcHJlZGljdGFibGUgYXMgYSB3ZWxsLXdyaXR0ZW4gc2NyaXB0IVxuICovXG5cbmltcG9ydCB0eXBlIHsgU3RhdHVzTWFuYWdlciB9IGZyb20gXCIuL1N0YXR1c01hbmFnZXJcIjtcbmltcG9ydCB0eXBlIHsgRmxvYXRpbmdXaW5kb3dFbGVtZW50cyB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuaW1wb3J0IHsgV2luZG93U3RhdGVTZXJ2aWNlIH0gZnJvbSBcIi4uLy4uL3NlcnZpY2VzL1dpbmRvd1N0YXRlU2VydmljZVwiO1xuXG5leHBvcnQgY2xhc3MgVUlTdGF0ZU1hbmFnZXIge1xuICBwcml2YXRlIHJlYWRvbmx5IGVsZW1lbnRzOiBGbG9hdGluZ1dpbmRvd0VsZW1lbnRzO1xuICBwcml2YXRlIHJlYWRvbmx5IHN0YXR1c01hbmFnZXI6IFN0YXR1c01hbmFnZXI7XG4gIHByaXZhdGUgaXNNaW5pbWl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBpc0NvbGxhcHNlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIHJlc2l6ZU9ic2VydmVyOiBSZXNpemVPYnNlcnZlciB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRzOiBGbG9hdGluZ1dpbmRvd0VsZW1lbnRzLCBzdGF0dXNNYW5hZ2VyOiBTdGF0dXNNYW5hZ2VyKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgIHRoaXMuc3RhdHVzTWFuYWdlciA9IHN0YXR1c01hbmFnZXI7XG4gICAgdGhpcy5iaW5kS2V5Ym9hcmRFdmVudHMoKTtcbiAgICB0aGlzLnNldHVwUmVzaXplT2JzZXJ2ZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIG9ic2VydmVyIGZvciB3aW5kb3cgc2l6ZSBjaGFuZ2VzXG4gICAqL1xuICBwcml2YXRlIHNldHVwUmVzaXplT2JzZXJ2ZXIoKTogdm9pZCB7XG4gICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc29sZS53YXJuKFwiUmVzaXplT2JzZXJ2ZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbnRyeS50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIGlmICghdGhpcy5pc01pbmltaXplZCkge1xuICAgICAgICAgIFdpbmRvd1N0YXRlU2VydmljZS5zYXZlR2VvbWV0cnkoXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoLFxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5lbGVtZW50cy53aW5kb3cpO1xuXG4gICAgLy8gQWxzbyBvYnNlcnZlIHNjcmlwdCB0ZXh0YXJlYSBoZWlnaHRcbiAgICBjb25zdCBzY3JpcHRDb250YWluZXIgPSB0aGlzLmVsZW1lbnRzLnNjcmlwdFRleHQucGFyZW50RWxlbWVudDtcbiAgICBpZiAoc2NyaXB0Q29udGFpbmVyKSB7XG4gICAgICBjb25zdCBzY3JpcHRPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZW50cnkudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgIFdpbmRvd1N0YXRlU2VydmljZS5zYXZlU2NyaXB0SGVpZ2h0KGVsZW1lbnQuc3R5bGUuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzY3JpcHRPYnNlcnZlci5vYnNlcnZlKHNjcmlwdENvbnRhaW5lcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIGtleWJvYXJkIGV2ZW50cyBmb3IgdGhlIHNjcmlwdCBpbnB1dFxuICAgKi9cbiAgcHJpdmF0ZSBiaW5kS2V5Ym9hcmRFdmVudHMoKTogdm9pZCB7XG4gICAgdGhpcy5lbGVtZW50cy5zY3JpcHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAvLyBSdW4gc2NyaXB0IG9uIEVudGVyIHdpdGhvdXQgc2hpZnRcbiAgICAgIGlmIChlLmtleSA9PT0gXCJFbnRlclwiICYmICFlLnNoaWZ0S2V5KSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5ydW5CdXR0b24uY2xpY2soKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgbmV3IGxpbmUgb24gU2hpZnQrRW50ZXJcbiAgICAgIGVsc2UgaWYgKGUua2V5ID09PSBcIkVudGVyXCIgJiYgZS5zaGlmdEtleSkge1xuICAgICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIHdpbGwgYWRkIG5ldyBsaW5lXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ2FuY2VsIG9uIEVzY2FwZSB3aGVuIHNjcmlwdCBpcyBydW5uaW5nXG4gICAgICBlbHNlIGlmIChcbiAgICAgICAgZS5rZXkgPT09IFwiRXNjYXBlXCIgJiZcbiAgICAgICAgdGhpcy5zdGF0dXNNYW5hZ2VyLmdldEN1cnJlbnRTdGF0ZSgpID09PSBcIndvcmtpbmdcIlxuICAgICAgKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5ydW5CdXR0b24uY2xpY2soKTsgLy8gV2lsbCB0cmlnZ2VyIGNhbmNlbCBpbiB3b3JraW5nIHN0YXRlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgbWluaW1pemUgc3RhdGUgb2YgdGhlIHdpbmRvd1xuICAgKi9cbiAgcHVibGljIHRvZ2dsZU1pbmltaXplKCk6IHZvaWQge1xuICAgIHRoaXMuaXNNaW5pbWl6ZWQgPSAhdGhpcy5pc01pbmltaXplZDtcblxuICAgIC8vIFNhdmUgY3VycmVudCBkaW1lbnNpb25zIGJlZm9yZSB0b2dnbGluZ1xuICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IHRoaXMuZWxlbWVudHMud2luZG93LnN0eWxlLndpZHRoO1xuICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSB0aGlzLmVsZW1lbnRzLndpbmRvdy5zdHlsZS5oZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5pc01pbmltaXplZCkge1xuICAgICAgLy8gU3RvcmUgZGltZW5zaW9ucyBmb3IgcmVzdG9yYXRpb25cbiAgICAgIGlmIChjdXJyZW50V2lkdGggJiYgY3VycmVudEhlaWdodCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzLndpbmRvdy5kYXRhc2V0LnByZXZXaWR0aCA9IGN1cnJlbnRXaWR0aDtcbiAgICAgICAgdGhpcy5lbGVtZW50cy53aW5kb3cuZGF0YXNldC5wcmV2SGVpZ2h0ID0gY3VycmVudEhlaWdodDtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIGRpbWVuc2lvbnMgdG8gYWxsb3cgc2hyaW5raW5nXG4gICAgICB0aGlzLmVsZW1lbnRzLndpbmRvdy5zdHlsZS53aWR0aCA9IFwiXCI7XG4gICAgICB0aGlzLmVsZW1lbnRzLndpbmRvdy5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXN0b3JlIHByZXZpb3VzIGRpbWVuc2lvbnMgaWYgdGhleSBleGlzdFxuICAgICAgY29uc3QgcHJldldpZHRoID0gdGhpcy5lbGVtZW50cy53aW5kb3cuZGF0YXNldC5wcmV2V2lkdGg7XG4gICAgICBjb25zdCBwcmV2SGVpZ2h0ID0gdGhpcy5lbGVtZW50cy53aW5kb3cuZGF0YXNldC5wcmV2SGVpZ2h0O1xuICAgICAgaWYgKHByZXZXaWR0aCAmJiBwcmV2SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMud2luZG93LnN0eWxlLndpZHRoID0gcHJldldpZHRoO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLndpbmRvdy5zdHlsZS5oZWlnaHQgPSBwcmV2SGVpZ2h0O1xuXG4gICAgICAgIC8vIFNhdmUgcmVzdG9yZWQgZGltZW5zaW9uc1xuICAgICAgICBXaW5kb3dTdGF0ZVNlcnZpY2Uuc2F2ZUdlb21ldHJ5KHByZXZXaWR0aCwgcHJldkhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVG9nZ2xlIG1pbmltaXplZCBjbGFzcyBmb3IgQ1NTIHN0eWxpbmdcbiAgICB0aGlzLmVsZW1lbnRzLndpbmRvdy5jbGFzc0xpc3QudG9nZ2xlKFwibWluaW1pemVkXCIsIHRoaXMuaXNNaW5pbWl6ZWQpO1xuICAgIHRoaXMuZWxlbWVudHMubWluaW1pemVCdXR0b24udGV4dENvbnRlbnQgPSB0aGlzLmlzTWluaW1pemVkID8gXCLilqFcIiA6IFwiX1wiO1xuICAgIHRoaXMuZWxlbWVudHMubWluaW1pemVCdXR0b24udGl0bGUgPSB0aGlzLmlzTWluaW1pemVkXG4gICAgICA/IFwiUmVzdG9yZVwiXG4gICAgICA6IFwiTWluaW1pemVcIjtcblxuICAgIC8vIFNhdmUgd2luZG93IHN0YXRlXG4gICAgV2luZG93U3RhdGVTZXJ2aWNlLnNhdmVXaW5kb3dTdGF0ZSh0aGlzLmlzTWluaW1pemVkLCB0aGlzLmlzQ29sbGFwc2VkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBjb2xsYXBzZSBzdGF0ZSBvZiB0aGUgb3V0cHV0IHBhbmVsXG4gICAqL1xuICBwdWJsaWMgdG9nZ2xlQ29sbGFwc2UoKTogdm9pZCB7XG4gICAgdGhpcy5pc0NvbGxhcHNlZCA9ICF0aGlzLmlzQ29sbGFwc2VkO1xuXG4gICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQpIHtcbiAgICAgIC8vIFN0b3JlIGN1cnJlbnQgd2luZG93IGhlaWdodCBmb3IgcmVzdG9yYXRpb25cbiAgICAgIGNvbnN0IGN1cnJlbnRXaW5kb3dIZWlnaHQgPSB0aGlzLmVsZW1lbnRzLndpbmRvdy5zdHlsZS5oZWlnaHQ7XG4gICAgICBpZiAoY3VycmVudFdpbmRvd0hlaWdodCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzLndpbmRvdy5kYXRhc2V0LnByZXZIZWlnaHQgPSBjdXJyZW50V2luZG93SGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICAvLyBTdG9yZSBvdXRwdXQgaGVpZ2h0IGZvciByZXN0b3JhdGlvblxuICAgICAgY29uc3QgY3VycmVudE91dHB1dEhlaWdodCA9IHRoaXMuZWxlbWVudHMub3V0cHV0LnN0eWxlLmhlaWdodDtcbiAgICAgIGlmIChjdXJyZW50T3V0cHV0SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMub3V0cHV0LmRhdGFzZXQucHJldkhlaWdodCA9IGN1cnJlbnRPdXRwdXRIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbGxhcHNlIG91dHB1dCBhcmVhXG4gICAgICB0aGlzLmVsZW1lbnRzLm91dHB1dC5zdHlsZS5tYXhIZWlnaHQgPSBcIjNlbVwiO1xuICAgICAgdGhpcy5lbGVtZW50cy5vdXRwdXQuc3R5bGUub3ZlcmZsb3dZID0gXCJoaWRkZW5cIjtcblxuICAgICAgLy8gU2hyaW5rIHdpbmRvdyB0byBmaXQgY29sbGFwc2VkIGNvbnRlbnRcbiAgICAgIHRoaXMuZWxlbWVudHMud2luZG93LnN0eWxlLmhlaWdodCA9IFwiYXV0b1wiO1xuICAgICAgdGhpcy5lbGVtZW50cy53aW5kb3cuc3R5bGUubWluSGVpZ2h0ID0gXCJhdXRvXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlc3RvcmUgd2luZG93IGhlaWdodFxuICAgICAgY29uc3QgcHJldldpbmRvd0hlaWdodCA9IHRoaXMuZWxlbWVudHMud2luZG93LmRhdGFzZXQucHJldkhlaWdodDtcbiAgICAgIGlmIChwcmV2V2luZG93SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHMud2luZG93LnN0eWxlLmhlaWdodCA9IHByZXZXaW5kb3dIZWlnaHQ7XG4gICAgICAgIHRoaXMuZWxlbWVudHMud2luZG93LnN0eWxlLm1pbkhlaWdodCA9IFwiMjAwcHhcIjsgLy8gUmVzdG9yZSBkZWZhdWx0IG1pbi1oZWlnaHRcbiAgICAgIH1cblxuICAgICAgLy8gUmVzdG9yZSBvdXRwdXQgaGVpZ2h0XG4gICAgICBjb25zdCBwcmV2T3V0cHV0SGVpZ2h0ID0gdGhpcy5lbGVtZW50cy5vdXRwdXQuZGF0YXNldC5wcmV2SGVpZ2h0O1xuICAgICAgaWYgKHByZXZPdXRwdXRIZWlnaHQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5vdXRwdXQuc3R5bGUuaGVpZ2h0ID0gcHJldk91dHB1dEhlaWdodDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWxlbWVudHMub3V0cHV0LnN0eWxlLm1heEhlaWdodCA9IFwiXCI7XG4gICAgICB0aGlzLmVsZW1lbnRzLm91dHB1dC5zdHlsZS5vdmVyZmxvd1kgPSBcImF1dG9cIjtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnRzLmNvbGxhcHNlQnV0dG9uLnRleHRDb250ZW50ID0gdGhpcy5pc0NvbGxhcHNlZCA/IFwi4pa2XCIgOiBcIuKWvFwiO1xuICAgIHRoaXMuZWxlbWVudHMuY29sbGFwc2VCdXR0b24udGl0bGUgPSB0aGlzLmlzQ29sbGFwc2VkXG4gICAgICA/IFwiRXhwYW5kXCJcbiAgICAgIDogXCJDb2xsYXBzZVwiO1xuXG4gICAgLy8gU2F2ZSB3aW5kb3cgc3RhdGVcbiAgICBXaW5kb3dTdGF0ZVNlcnZpY2Uuc2F2ZVdpbmRvd1N0YXRlKHRoaXMuaXNNaW5pbWl6ZWQsIHRoaXMuaXNDb2xsYXBzZWQpO1xuICAgIGNvbnN0IHdpbmRvd0hlaWdodCA9IHRoaXMuZWxlbWVudHMud2luZG93LnN0eWxlLmhlaWdodDtcbiAgICBpZiAod2luZG93SGVpZ2h0KSB7XG4gICAgICBXaW5kb3dTdGF0ZVNlcnZpY2Uuc2F2ZUdlb21ldHJ5KFxuICAgICAgICB0aGlzLmVsZW1lbnRzLndpbmRvdy5zdHlsZS53aWR0aCxcbiAgICAgICAgd2luZG93SGVpZ2h0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGJ1dHRvbiBzdGF0ZXMgYmFzZWQgb24gZXhlY3V0aW9uIHN0YXRlXG4gICAqIEBwYXJhbSBpc0V4ZWN1dGluZyAtIFdoZXRoZXIgYSBzY3JpcHQgaXMgY3VycmVudGx5IGV4ZWN1dGluZ1xuICAgKi9cbiAgcHVibGljIHVwZGF0ZUJ1dHRvblN0YXRlcyhpc0V4ZWN1dGluZzogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuZWxlbWVudHMucnVuQnV0dG9uLnRleHRDb250ZW50ID0gaXNFeGVjdXRpbmcgPyBcIkNhbmNlbFwiIDogXCJSdW4gU2NyaXB0XCI7XG4gICAgdGhpcy5lbGVtZW50cy5ydW5CdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVsZW1lbnRzLnNjcmlwdFRleHQuZGlzYWJsZWQgPSBpc0V4ZWN1dGluZztcbiAgfVxuXG4gIHB1YmxpYyBzZXRNb2RlKHNjcmlwdE1vZGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBXaW5kb3dTdGF0ZVNlcnZpY2Uuc2F2ZU1vZGUoc2NyaXB0TW9kZSk7XG4gICAgLy8gVXBkYXRlIFVJIGVsZW1lbnRzIHZpc2liaWxpdHlcbiAgICBpZiAoXG4gICAgICB0aGlzLmVsZW1lbnRzLnNjcmlwdE1vZGVDb250YWluZXIgJiZcbiAgICAgIHRoaXMuZWxlbWVudHMuc2ltcGxlTW9kZUNvbnRhaW5lclxuICAgICkge1xuICAgICAgdGhpcy5lbGVtZW50cy5zY3JpcHRNb2RlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBzY3JpcHRNb2RlXG4gICAgICAgID8gXCJibG9ja1wiXG4gICAgICAgIDogXCJub25lXCI7XG4gICAgICB0aGlzLmVsZW1lbnRzLnNpbXBsZU1vZGVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IHNjcmlwdE1vZGVcbiAgICAgICAgPyBcIm5vbmVcIlxuICAgICAgICA6IFwiYmxvY2tcIjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBhIG1lc3NhZ2UgdG8gdGhlIG91dHB1dCBhcmVhXG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gTWVzc2FnZSB0byBsb2dcbiAgICogQHBhcmFtIHR5cGUgLSBUeXBlIG9mIG1lc3NhZ2UgZm9yIHN0eWxpbmdcbiAgICovXG4gIHB1YmxpYyBsb2coXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIHR5cGU6IFwiaW5mb1wiIHwgXCJlcnJvclwiIHwgXCJzdWNjZXNzXCIgPSBcImluZm9cIlxuICApOiB2b2lkIHtcbiAgICBjb25zdCBsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGxvZy50ZXh0Q29udGVudCA9IGBbJHtuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpfV0gJHttZXNzYWdlfWA7XG4gICAgbG9nLnN0eWxlLmNvbG9yID1cbiAgICAgIHR5cGUgPT09IFwiZXJyb3JcIiA/IFwicmVkXCIgOiB0eXBlID09PSBcInN1Y2Nlc3NcIiA/IFwiZ3JlZW5cIiA6IFwiYmxhY2tcIjtcbiAgICB0aGlzLmVsZW1lbnRzLm91dHB1dC5hcHBlbmRDaGlsZChsb2cpO1xuICAgIHRoaXMuZWxlbWVudHMub3V0cHV0LnNjcm9sbFRvcCA9IHRoaXMuZWxlbWVudHMub3V0cHV0LnNjcm9sbEhlaWdodDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgcmVzb3VyY2VzXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgb3V0cHV0IGFyZWFcbiAgICovXG4gIHB1YmxpYyBjbGVhck91dHB1dCgpOiB2b2lkIHtcbiAgICB0aGlzLmVsZW1lbnRzLm91dHB1dC5pbm5lckhUTUwgPSBcIlwiO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogL1VzZXJzL21hcnRpbmJlY2hhcmQvZGV2L2NsYXVkZWV4dC9zcmMvdXRpbHMvRXZlbnRTdHJlYW1QYXJzZXIudHNcbiAqIFRoaXMgd2FzIGdlbmVyYXRlZCBieSBDbGF1ZGUgU29ubmV0IDMuNSwgd2l0aCB0aGUgYXNzaXN0YW5jZSBvZiBteSBodW1hbiBtZW50b3JcbiAqXG4gKiBIYW5kbGVzIHBhcnNpbmcgb2YgU2VydmVyLVNlbnQgRXZlbnRzIGZyb20gQ2xhdWRlIEFQSSByZXNwb25zZXNcbiAqIE5vdGU6IE1ha2luZyBldmVudCBzdHJlYW1zIGFzIHNtb290aCBhcyBhIHdlbGwtb2lsZWQgbWFjaGluZSFcbiAqL1xuXG4vKipcbiAqIEJhc2ljIGV2ZW50IGRhdGEgc3RydWN0dXJlXG4gKi9cbmludGVyZmFjZSBFdmVudERhdGEge1xuICB0eXBlOiBzdHJpbmc7XG4gIGNvbXBsZXRpb24/OiBzdHJpbmc7XG4gIGlkPzogc3RyaW5nO1xuICBzdG9wX3JlYXNvbj86IHN0cmluZyB8IG51bGw7XG4gIG1vZGVsPzogc3RyaW5nO1xuICBzdG9wPzogc3RyaW5nIHwgbnVsbDtcbiAgbG9nX2lkPzogc3RyaW5nO1xuICBtZXNzYWdlTGltaXQ/OiB7XG4gICAgdHlwZTogc3RyaW5nO1xuICAgIHJlc2V0c0F0OiBzdHJpbmcgfCBudWxsO1xuICAgIHJlbWFpbmluZzogbnVtYmVyIHwgbnVsbDtcbiAgICBwZXJNb2RlbExpbWl0OiBudW1iZXIgfCBudWxsO1xuICB9O1xuICBjb21wbGV0aW9uX3R5cGU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogU3RydWN0dXJlZCBldmVudCB3aXRoIHR5cGUgYW5kIGRhdGFcbiAqL1xuaW50ZXJmYWNlIFN0cmVhbUV2ZW50IHtcbiAgdHlwZTogc3RyaW5nO1xuICBkYXRhOiBFdmVudERhdGE7XG59XG5cbi8qKlxuICogUGFyc2VyIGZvciBTZXJ2ZXItU2VudCBFdmVudHMgZnJvbSBDbGF1ZGUncyBBUElcbiAqL1xuZXhwb3J0IGNsYXNzIEV2ZW50U3RyZWFtUGFyc2VyIHtcbiAgcHJpdmF0ZSBidWZmZXI6IHN0cmluZyA9IFwiXCI7XG4gIHByaXZhdGUgY3VycmVudE1lc3NhZ2U6IHN0cmluZyA9IFwiXCI7XG4gIHByaXZhdGUgaXNDb21wbGV0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYSBjaHVuayBvZiBkYXRhIGZyb20gdGhlIGV2ZW50IHN0cmVhbVxuICAgKiBAcGFyYW0gY2h1bmsgLSBSYXcgY2h1bmsgZGF0YSBmcm9tIHN0cmVhbVxuICAgKiBAcGFyYW0gb25FdmVudCAtIE9wdGlvbmFsIGNhbGxiYWNrIGZvciBlYWNoIHBhcnNlZCBldmVudFxuICAgKiBAcmV0dXJucyBUaGUgYWNjdW11bGF0ZWQgdGV4dCBjb250ZW50XG4gICAqL1xuICBwdWJsaWMgcHJvY2Vzc0NodW5rKFxuICAgIGNodW5rOiBzdHJpbmcsXG4gICAgb25FdmVudD86IChldmVudDogU3RyZWFtRXZlbnQpID0+IHZvaWRcbiAgKTogc3RyaW5nIHtcbiAgICAvLyBBZGQgbmV3IGRhdGEgdG8gYnVmZmVyXG4gICAgdGhpcy5idWZmZXIgKz0gY2h1bms7XG5cbiAgICAvLyBQcm9jZXNzIGNvbXBsZXRlIGV2ZW50cyBpbiBidWZmZXJcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLmJ1ZmZlci5zcGxpdChcIlxcblxcblwiKTtcbiAgICB0aGlzLmJ1ZmZlciA9IGV2ZW50cy5wb3AoKSB8fCBcIlwiOyAvLyBLZWVwIGxhc3QgaW5jb21wbGV0ZSBldmVudFxuXG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgIGlmICghZXZlbnQudHJpbSgpKSBjb250aW51ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgIGlmIChvbkV2ZW50KSB7XG4gICAgICAgICAgICBvbkV2ZW50KHBhcnNlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucHJvY2Vzc0V2ZW50KHBhcnNlZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwYXJzaW5nIGV2ZW50OlwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudE1lc3NhZ2U7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgc2luZ2xlIGV2ZW50IHN0cmluZyBpbnRvIHN0cnVjdHVyZWQgZGF0YVxuICAgKiBAcGFyYW0gZXZlbnRTdHJpbmcgLSBSYXcgZXZlbnQgZGF0YVxuICAgKiBAcmV0dXJucyBQYXJzZWQgZXZlbnQgZGF0YSBvciBudWxsIGlmIGludmFsaWRcbiAgICovXG4gIHByaXZhdGUgcGFyc2VFdmVudChldmVudFN0cmluZzogc3RyaW5nKTogU3RyZWFtRXZlbnQgfCBudWxsIHtcbiAgICBjb25zdCBsaW5lcyA9IGV2ZW50U3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICAgIGxldCBldmVudFR5cGUgPSBcIlwiO1xuICAgIGxldCBldmVudERhdGE6IEV2ZW50RGF0YSB8IG51bGwgPSBudWxsO1xuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICBpZiAoIWxpbmUudHJpbSgpKSBjb250aW51ZTtcblxuICAgICAgY29uc3QgW2ZpZWxkLCAuLi52YWx1ZXNdID0gbGluZS5zcGxpdChcIjogXCIpO1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXMuam9pbihcIjogXCIpLnRyaW0oKTtcblxuICAgICAgaWYgKGZpZWxkID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgZXZlbnRUeXBlID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGZpZWxkID09PSBcImRhdGFcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGV2ZW50RGF0YSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwYXJzaW5nIGV2ZW50IGRhdGE6XCIsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlcXVpcmUgYm90aCBldmVudCB0eXBlIGFuZCBkYXRhXG4gICAgaWYgKCFldmVudFR5cGUgfHwgIWV2ZW50RGF0YSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGV2ZW50VHlwZSxcbiAgICAgIGRhdGE6IGV2ZW50RGF0YSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBhIHBhcnNlZCBldmVudCBhbmQgdXBkYXRlcyBpbnRlcm5hbCBzdGF0ZVxuICAgKiBAcGFyYW0gZXZlbnQgLSBQYXJzZWQgZXZlbnQgZGF0YVxuICAgKi9cbiAgcHJpdmF0ZSBwcm9jZXNzRXZlbnQoZXZlbnQ6IFN0cmVhbUV2ZW50KTogdm9pZCB7XG4gICAgLy8gU2tpcCBwaW5nIGV2ZW50c1xuICAgIGlmIChldmVudC50eXBlID09PSBcInBpbmdcIikgcmV0dXJuO1xuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRpb24gZXZlbnRzXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiY29tcGxldGlvblwiICYmIGV2ZW50LmRhdGEpIHtcbiAgICAgIGlmIChldmVudC5kYXRhLmNvbXBsZXRpb24pIHtcbiAgICAgICAgdGhpcy5jdXJyZW50TWVzc2FnZSArPSBldmVudC5kYXRhLmNvbXBsZXRpb247XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBjb21wbGV0aW9uXG4gICAgICBpZiAoZXZlbnQuZGF0YS5zdG9wX3JlYXNvbikge1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBlbnRpcmUgYWNjdW11bGF0ZWQgbWVzc2FnZVxuICAgKi9cbiAgcHVibGljIGdldE1lc3NhZ2UoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50TWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIG1lc3NhZ2UgaXMgY29tcGxldGVcbiAgICovXG4gIHB1YmxpYyBpc01lc3NhZ2VDb21wbGV0ZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvbXBsZXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlXG4gICAqL1xuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgIHRoaXMuY3VycmVudE1lc3NhZ2UgPSBcIlwiO1xuICAgIHRoaXMuaXNDb21wbGV0ZSA9IGZhbHNlO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogL3NyYy91dGlscy9QYXRoRXh0cmFjdG9yLnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGV4dHJhY3RpbmcgZmlsZSBwYXRocyBmcm9tIGNvZGUgYXJ0aWZhY3RzXG4gKiBOb3RlOiBGaW5kaW5nIG5lZWRsZXMgaW4gY29tbWVudCBoYXlzdGFja3Mgc2luY2UgMjAyNCFcbiAqL1xuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSBmaWxlIHBhdGggZnJvbSBhIGNvZGUgYXJ0aWZhY3QncyBjb21tZW50c1xuICogQ2hlY2tzIGJvdGggc2luZ2xlLWxpbmUgYW5kIGJsb2NrIGNvbW1lbnRzIGF0IHRoZSBzdGFydCBvZiB0aGUgZmlsZVxuICogQHBhcmFtIGNvbnRlbnQgLSBUaGUgY29udGVudCB0byBhbmFseXplXG4gKiBAcmV0dXJucyBUaGUgZXh0cmFjdGVkIHBhdGggb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhdGhGcm9tQ29tbWVudHMoY29udGVudDogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgLy8gTm9ybWFsaXplIGxpbmUgZW5kaW5nc1xuICBjb25zdCBub3JtYWxpemVkQ29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxuXCIpO1xuICBjb25zdCBsaW5lcyA9IG5vcm1hbGl6ZWRDb250ZW50LnNwbGl0KFwiXFxuXCIpO1xuXG4gIGxldCBpbkJsb2NrQ29tbWVudCA9IGZhbHNlO1xuICBsZXQgY29sbGVjdGVkTGluZXM6IHN0cmluZ1tdID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbigyMCwgbGluZXMubGVuZ3RoKTsgaSsrKSB7XG4gICAgLy8gT25seSBjaGVjayBmaXJzdCAyMCBsaW5lc1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGxpbmVzXG4gICAgaWYgKCFsaW5lKSBjb250aW51ZTtcblxuICAgIC8vIENoZWNrIGZvciBzdGFydCBvZiBibG9jayBjb21tZW50XG4gICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcIi8qXCIpKSB7XG4gICAgICBpbkJsb2NrQ29tbWVudCA9IHRydWU7XG4gICAgICBjb2xsZWN0ZWRMaW5lcy5wdXNoKGxpbmUuc3Vic3RyaW5nKDIpLnRyaW0oKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgZW5kIG9mIGJsb2NrIGNvbW1lbnRcbiAgICBpZiAoaW5CbG9ja0NvbW1lbnQgJiYgbGluZS5pbmNsdWRlcyhcIiovXCIpKSB7XG4gICAgICBpbkJsb2NrQ29tbWVudCA9IGZhbHNlO1xuICAgICAgY29sbGVjdGVkTGluZXMucHVzaChsaW5lLnN1YnN0cmluZygwLCBsaW5lLmluZGV4T2YoXCIqL1wiKSkudHJpbSgpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIENvbGxlY3QgYmxvY2sgY29tbWVudCBsaW5lc1xuICAgIGlmIChpbkJsb2NrQ29tbWVudCkge1xuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgKiBpZiBwcmVzZW50XG4gICAgICBjb25zdCBjbGVhbkxpbmUgPSBsaW5lLnN0YXJ0c1dpdGgoXCIqXCIpID8gbGluZS5zdWJzdHJpbmcoMSkudHJpbSgpIDogbGluZTtcbiAgICAgIGNvbGxlY3RlZExpbmVzLnB1c2goY2xlYW5MaW5lKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBzaW5nbGUtbGluZSBjb21tZW50c1xuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCIvL1wiKSkge1xuICAgICAgY29sbGVjdGVkTGluZXMucHVzaChsaW5lLnN1YnN0cmluZygyKS50cmltKCkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGl0IGEgbm9uLWNvbW1lbnQgbGluZSwgc3RvcCBwcm9jZXNzaW5nXG4gICAgaWYgKCFpbkJsb2NrQ29tbWVudCkgYnJlYWs7XG4gIH1cblxuICAvLyBMb29rIGZvciBwYXRoIGluIGNvbGxlY3RlZCBsaW5lc1xuICBmb3IgKGNvbnN0IGxpbmUgb2YgY29sbGVjdGVkTGluZXMpIHtcbiAgICAvLyBDaGVjayBmb3IgZXhwbGljaXQgcGF0aCBkZWNsYXJhdGlvbnNcbiAgICBjb25zdCBwYXRoTWF0Y2hlcyA9IFtcbiAgICAgIC9GaWxlOlxccyooW14qXFxuXSspL2ksIC8vIEZpbGU6IHBhdGhcbiAgICAgIC9QYXRoOlxccyooW14qXFxuXSspL2ksIC8vIFBhdGg6IHBhdGhcbiAgICAgIC9GaWxlUGF0aDpcXHMqKFteKlxcbl0rKS9pLCAvLyBGaWxlUGF0aDogcGF0aFxuICAgICAgL0BwYXRoXFxzKyhbXipcXG5dKykvaSwgLy8gQHBhdGggcGF0aFxuICAgICAgL15bXFxcXC9dLipcXC5bXFx3XSskLywgLy8gQWJzb2x1dGUgcGF0aCB3aXRoIGV4dGVuc2lvblxuICAgIF07XG5cbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0aE1hdGNoZXMpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbGluZS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCBwYXRoID0gbWF0Y2hbMV0gfHwgbWF0Y2hbMF07XG4gICAgICAgIHJldHVybiBwYXRoLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEhhbmRsZXMgc3BlY2lhbCBjYXNlcyB3aGVyZSB0aGUgcGF0aCBtaWdodCBiZSBpbiBhIG5vbi1zdGFuZGFyZCBmb3JtYXRcbiAqIFN1Y2ggYXMgaW4gSlNPTiBmaWxlcyB3aXRoIF9wYXRoIHByb3BlcnR5XG4gKiBAcGFyYW0gY29udGVudCAtIFRoZSBjb250ZW50IHRvIGFuYWx5emVcbiAqIEByZXR1cm5zIFRoZSBleHRyYWN0ZWQgcGF0aCBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0UGF0aEZyb21TcGVjaWFsQ2FzZXMoXG4gIGNvbnRlbnQ6IHN0cmluZ1xuKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBpZiBpdCdzIGEgSlNPTiBmaWxlXG4gICAgY29uc3QganNvbkNvbnRlbnQgPSBKU09OLnBhcnNlKGNvbnRlbnQpO1xuICAgIGlmIChqc29uQ29udGVudC5fcGF0aCB8fCBqc29uQ29udGVudC5fZmlsZSkge1xuICAgICAgcmV0dXJuIGpzb25Db250ZW50Ll9wYXRoIHx8IGpzb25Db250ZW50Ll9maWxlO1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gICAgLy8gTm90IEpTT04sIGNvbnRpbnVlIHdpdGggbm9ybWFsIHByb2Nlc3NpbmdcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogTWFpbiBmdW5jdGlvbiB0byBleHRyYWN0IGEgcmVsYXRpdmUgcGF0aCB0byBvbmUgb2YgdGhlIG1haW4gcHJvamVjdCBzdWJkaXJlY3Rvcmllc1xuICogVHJpZXMgZGlmZmVyZW50IHN0cmF0ZWdpZXMgaW4gb3JkZXIgb2YgcmVsaWFiaWxpdHlcbiAqIEBwYXJhbSBjb250ZW50IC0gVGhlIGNvbnRlbnQgdG8gYW5hbHl6ZVxuICogQHBhcmFtIHN1YmRpcmVjdG9yaWVzIC0gT3B0aW9uYWwgbGlzdCBvZiBzdWJkaXJlY3RvcmllcyB0byBtYXRjaFxuICogQHJldHVybnMgVGhlIGV4dHJhY3RlZCBwYXRoIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RSZWxQYXRoKFxuICBjb250ZW50OiBzdHJpbmcsXG4gIHN1YmRpcmVjdG9yaWVzPzogc3RyaW5nW11cbik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBleHRyYWN0UGF0aChcbiAgICBjb250ZW50LFxuICAgIHN1YmRpcmVjdG9yaWVzIHx8IFtcInNyY1wiLCBcImRvY1wiLCBcInRlc3RzXCIsIFwid2ViXCIsIFwiYXBpXCIsIFwiYXBwXCJdXG4gICk7XG59XG5cbi8qKlxuICogTWFpbiBmdW5jdGlvbiB0byBleHRyYWN0IHBhdGggZnJvbSBjb250ZW50XG4gKiBUcmllcyBkaWZmZXJlbnQgc3RyYXRlZ2llcyBpbiBvcmRlciBvZiByZWxpYWJpbGl0eVxuICogQHBhcmFtIGNvbnRlbnQgLSBUaGUgY29udGVudCB0byBhbmFseXplXG4gKiBAcGFyYW0gc3ViZGlyZWN0b3JpZXMgLSBPcHRpb25hbCBsaXN0IG9mIHN1YmRpcmVjdG9yaWVzIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBUaGUgZXh0cmFjdGVkIHBhdGggb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFBhdGgoXG4gIGNvbnRlbnQ6IHN0cmluZyxcbiAgc3ViZGlyZWN0b3JpZXM/OiBzdHJpbmdbXVxuKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgLy8gRmlyc3QgdHJ5IHNwZWNpYWwgY2FzZXMgKGxpa2UgSlNPTilcbiAgY29uc3Qgc3BlY2lhbENhc2VQYXRoID0gZXh0cmFjdFBhdGhGcm9tU3BlY2lhbENhc2VzKGNvbnRlbnQpO1xuICBpZiAoc3BlY2lhbENhc2VQYXRoKSB7XG4gICAgcmV0dXJuIGZpbHRlclBhdGhGcm9tU3ViZGlyZWN0b3JpZXMoc3BlY2lhbENhc2VQYXRoLCBzdWJkaXJlY3Rvcmllcyk7XG4gIH1cblxuICAvLyBUaGVuIHRyeSBleHRyYWN0aW5nIGZyb20gY29tbWVudHNcbiAgY29uc3QgY29tbWVudFBhdGggPSBleHRyYWN0UGF0aEZyb21Db21tZW50cyhjb250ZW50KTtcbiAgaWYgKGNvbW1lbnRQYXRoKSB7XG4gICAgcmV0dXJuIGZpbHRlclBhdGhGcm9tU3ViZGlyZWN0b3JpZXMoY29tbWVudFBhdGgsIHN1YmRpcmVjdG9yaWVzKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGZpbHRlciB0aGUgcGF0aCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgc3ViZGlyZWN0b3JpZXMuXG4gKiBLZWVwcyBvbmx5IHRoZSBwYXRoIHNlZ21lbnQgZnJvbSB0aGUgZmlyc3QgbWF0Y2ggb2YgdGhlIHN1YmRpcmVjdG9yeSBvbndhcmRzLlxuICogQHBhcmFtIHBhdGggLSBUaGUgZnVsbCBwYXRoIGV4dHJhY3RlZCBmcm9tIGNvbnRlbnRcbiAqIEBwYXJhbSBzdWJkaXJlY3RvcmllcyAtIExpc3Qgb2Ygc3ViZGlyZWN0b3JpZXMgdG8gc2VhcmNoIGZvciBpbiB0aGUgcGF0aFxuICogQHJldHVybnMgVGhlIGZpbHRlcmVkIHBhdGggb3IgdGhlIG9yaWdpbmFsIHBhdGggaWYgbm8gc3ViZGlyZWN0b3J5IG1hdGNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJQYXRoRnJvbVN1YmRpcmVjdG9yaWVzKFxuICBwYXRoOiBzdHJpbmcsXG4gIHN1YmRpcmVjdG9yaWVzPzogc3RyaW5nW11cbik6IHN0cmluZyB7XG4gIGlmICghc3ViZGlyZWN0b3JpZXMpIHJldHVybiBwYXRoO1xuXG4gIC8vIEpvaW4gdGhlIHN1YmRpcmVjdG9yaWVzIHdpdGggfCBmb3IgcmVnZXggT1IsIGVuc3VyaW5nIHdvcmQgYm91bmRhcmllc1xuICBjb25zdCBzdWJkaXJlY3RvcnlQYXR0ZXJuID0gbmV3IFJlZ0V4cChcbiAgICBgXFxcXGIoJHtzdWJkaXJlY3Rvcmllcy5qb2luKFwifFwiKX0pXFxcXGJgLFxuICAgIFwiaVwiXG4gICk7XG4gIGNvbnN0IG1hdGNoID0gcGF0aC5tYXRjaChzdWJkaXJlY3RvcnlQYXR0ZXJuKTtcblxuICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwYXRoLnNsaWNlKG1hdGNoLmluZGV4KTtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgPG1hcnRpbi5iZWNoYXJkQERldkNvbnN1bHQuY2E+XG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIEZpbGU6IHNyYy91dGlscy9TY3JpcHRQYXJzZXIudHNcbiAqIFRoaXMgd2FzIGdlbmVyYXRlZCBieSBDbGF1ZGUgU29ubmV0IDMuNSwgd2l0aCB0aGUgYXNzaXN0YW5jZSBvZiBteSBodW1hbiBtZW50b3JcbiAqL1xuXG5pbXBvcnQge1xuICBTY3JpcHQsXG4gIFNjcmlwdFN0YXRlbWVudCxcbiAgUGFyc2VkQ29tbWFuZExpbmUgYXMgUGFyc2VkQ29tbWFuZFRleHQsXG4gIFN0b3BDb25kaXRpb24sXG59IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgcGFyc2VTdG9wQ29uZGl0aW9uQ29tbWFuZCB9IGZyb20gXCIuL2NvbW1hbmRzL3BhcnNlU3RvcENvbmRpdGlvbnNcIjtcbmltcG9ydCB7XG4gIGdldENvbW1hbmRNYXRjaGVzLFxuICBnZXRDb21tYW5kT3B0aW9uRGVmaW5pdGlvbnMsXG4gIE9wdGlvblR5cGUsXG59IGZyb20gXCIuL2NvbW1hbmRzL0NvbW1hbmRNYXBcIjtcbmltcG9ydCB7IHBhcnNlUmVwZWF0Q29tbWFuZCB9IGZyb20gXCIuL2NvbW1hbmRzL3BhcnNlUmVwZWF0Q29tbWFuZFwiO1xuaW1wb3J0IHsgcGFyc2VBbGlhc0NvbW1hbmQgfSBmcm9tIFwiLi9jb21tYW5kcy9wYXJzZUFsaWFzQ29tbWFuZFwiO1xuaW1wb3J0IHtcbiAgcGFyc2VQcm9qZWN0Q29tbWFuZCxcbiAgcGFyc2VTZWFyY2hQcm9qZWN0Q29tbWFuZCxcbiAgcGFyc2VRdWVyeVByb2plY3RDb21tYW5kLFxufSBmcm9tIFwiLi9jb21tYW5kcy9wYXJzZVByb2plY3RDb21tYW5kc1wiO1xuaW1wb3J0IHtcbiAgcGFyc2VDb252ZXJzYXRpb25Db21tYW5kLFxuICBwYXJzZUFydGlmYWN0c0NvbW1hbmQsXG59IGZyb20gXCIuL2NvbW1hbmRzL3BhcnNlQ29udGVudENvbW1hbmRzXCI7XG5pbXBvcnQgeyBzcGxpdFRleHRXaXRoUXVvdGVzIH0gZnJvbSBcIi4vc3BsaXRUZXh0XCI7XG5pbXBvcnQgeyBwYXJzZURvY3NDb21tYW5kIH0gZnJvbSBcIi4vY29tbWFuZHMvcGFyc2VEb2NzQ29tbWFuZFwiO1xuXG5leHBvcnQgY2xhc3MgU2NyaXB0UGFyc2VyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgQ09NTUFORF9QUkVGSVggPSBcIi9cIjtcblxuICAvKipcbiAgICogUGFyc2VzIHRleHQgaW50byBhIFNjcmlwdCBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcGFyc2UodGV4dDogc3RyaW5nKTogU2NyaXB0IHtcbiAgICBjb25zdCBzdGF0ZW1lbnRzID0gdGhpcy5wYXJzZVN0YXRlbWVudHModGV4dCk7XG4gICAgcmV0dXJuIHsgc3RhdGVtZW50cyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyB0ZXh0IGludG8gc3RhdGVtZW50cyB3aGlsZSBwcmVzZXJ2aW5nIHF1b3RlZCBzdHJpbmdzXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBwYXJzZVN0YXRlbWVudHModGV4dDogc3RyaW5nKTogU2NyaXB0U3RhdGVtZW50W10ge1xuICAgIGNvbnN0IHN0YXRlbWVudHM6IFNjcmlwdFN0YXRlbWVudFtdID0gW107XG4gICAgbGV0IGN1cnJlbnQgPSBcIlwiO1xuICAgIGxldCBpblF1b3RlcyA9IGZhbHNlO1xuICAgIGxldCBxdW90ZUNoYXI6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gdGV4dFtpXTtcblxuICAgICAgLy8gSGFuZGxlIHF1b3RlZCB0ZXh0XG4gICAgICBpZiAoKGNoYXIgPT09ICdcIicgfHwgY2hhciA9PT0gXCInXCIpICYmICFpblF1b3Rlcykge1xuICAgICAgICBpblF1b3RlcyA9IHRydWU7XG4gICAgICAgIHF1b3RlQ2hhciA9IGNoYXI7XG4gICAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gcXVvdGVDaGFyICYmIGluUXVvdGVzKSB7XG4gICAgICAgIGluUXVvdGVzID0gZmFsc2U7XG4gICAgICAgIHF1b3RlQ2hhciA9IG51bGw7XG4gICAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICAgIH1cbiAgICAgIC8vIEhhbmRsZSBzdGF0ZW1lbnQgc2VwYXJhdG9yc1xuICAgICAgZWxzZSBpZiAoY2hhciA9PT0gXCI7XCIgJiYgIWluUXVvdGVzKSB7XG4gICAgICAgIGlmIChjdXJyZW50LnRyaW0oKSkge1xuICAgICAgICAgIHN0YXRlbWVudHMucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50KGN1cnJlbnQudHJpbSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IFwiXCI7XG4gICAgICB9XG4gICAgICAvLyBDb2xsZWN0IGNoYXJhY3RlcnNcbiAgICAgIGVsc2Uge1xuICAgICAgICBjdXJyZW50ICs9IGNoYXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGZpbmFsIHN0YXRlbWVudFxuICAgIGlmIChjdXJyZW50LnRyaW0oKSkge1xuICAgICAgc3RhdGVtZW50cy5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnQoY3VycmVudC50cmltKCkpKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaW5hbFN0YXRlbWVudHM6IFNjcmlwdFN0YXRlbWVudFtdID0gW107XG4gICAgc3RhdGVtZW50cy5mb3JFYWNoKChzdGF0ZW1lbnQpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgc3RhdGVtZW50LmNvbW1hbmQgPT09IFwic3RvcF9pZlwiIHx8XG4gICAgICAgIHN0YXRlbWVudC5jb21tYW5kID09PSBcInN0b3BfaWZfbm90XCJcbiAgICAgICkge1xuICAgICAgICBjb25zdCBsYXN0ID0gZmluYWxTdGF0ZW1lbnRzWzBdO1xuICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdG9wIHN0YXRlbWVudCB3aXRob3V0IHByZWNlZGluZyBwcm9tcHQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdC5hZGRTdG9wQ29uZGl0aW9uKHtcbiAgICAgICAgICB0YXJnZXQ6IHN0YXRlbWVudC5wcm9tcHQgfHwgXCJcIixcbiAgICAgICAgICB0eXBlOiBzdGF0ZW1lbnQuY29tbWFuZCA9PT0gXCJzdG9wX2lmXCIgPyBcImlmXCIgOiBcImlmX25vdFwiLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmFsU3RhdGVtZW50cy5wdXNoKHN0YXRlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmluYWxTdGF0ZW1lbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHNpbmdsZSBzdGF0ZW1lbnQgd2l0aCBzdG9wIGNvbmRpdGlvbnNcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHBhcnNlU3RhdGVtZW50KHRleHQ6IHN0cmluZyk6IFNjcmlwdFN0YXRlbWVudCB7XG4gICAgY29uc3Qgc3RhdGVtZW50VGV4dCA9IHRleHQudHJpbSgpO1xuXG4gICAgLy8gUGFyc2UgbWFpbiBzdGF0ZW1lbnQgKGNvbW1hbmQgb3IgcHJvbXB0KVxuICAgIC8qbGV0IHN0YXRlbWVudCA9IHN0YXRlbWVudFRleHQuc3RhcnRzV2l0aCh0aGlzLkNPTU1BTkRfUFJFRklYKVxuICAgICAgPyB0aGlzLnBhcnNlQ29tbWFuZFN0YXRlbWVudChzdGF0ZW1lbnRUZXh0KVxuICAgICAgOiB0aGlzLnBhcnNlUHJvbXB0U3RhdGVtZW50KHN0YXRlbWVudFRleHQpO1xuKi9cbiAgICBjb25zdCBzdGF0ZW1lbnQgPSB0aGlzLnBhcnNlQ29tbWFuZFN0YXRlbWVudChzdGF0ZW1lbnRUZXh0KTtcbiAgICByZXR1cm4gc3RhdGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHByb21wdCBzdGF0ZW1lbnRcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHBhcnNlUHJvbXB0U3RhdGVtZW50KHRleHQ6IHN0cmluZyk6IFNjcmlwdFN0YXRlbWVudCB7XG4gICAgcmV0dXJuIG5ldyBTY3JpcHRTdGF0ZW1lbnQoe1xuICAgICAgcHJvbXB0OiB0ZXh0LFxuICAgICAgaXNDb21tYW5kOiBmYWxzZSxcbiAgICAgIGNvbW1hbmQ6IG51bGwsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgY29tbWFuZCBzdGF0ZW1lbnRcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHBhcnNlQ29tbWFuZFN0YXRlbWVudCh0ZXh0OiBzdHJpbmcpOiBTY3JpcHRTdGF0ZW1lbnQge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VDb21tYW5kVGV4dCh0ZXh0KTtcblxuICAgIHN3aXRjaCAocGFyc2VkLmNvbW1hbmQpIHtcbiAgICAgIGNhc2UgXCJyZXBlYXRcIjpcbiAgICAgICAgcmV0dXJuIHBhcnNlUmVwZWF0Q29tbWFuZChwYXJzZWQpO1xuICAgICAgY2FzZSBcInN0b3BfaWZcIjpcbiAgICAgIGNhc2UgXCJzdG9wX2lmX25vdFwiOlxuICAgICAgICByZXR1cm4gcGFyc2VTdG9wQ29uZGl0aW9uQ29tbWFuZChwYXJzZWQpO1xuICAgICAgY2FzZSBcImFsaWFzXCI6XG4gICAgICBjYXNlIFwibGlzdF9hbGlhc1wiOlxuICAgICAgY2FzZSBcImRlbGV0ZV9hbGlhc1wiOlxuICAgICAgICByZXR1cm4gcGFyc2VBbGlhc0NvbW1hbmQocGFyc2VkKTtcbiAgICAgIGNhc2UgXCJwcm9qZWN0XCI6XG4gICAgICAgIHJldHVybiBwYXJzZVByb2plY3RDb21tYW5kKHBhcnNlZCk7XG4gICAgICBjYXNlIFwic2VhcmNoX3Byb2plY3RcIjpcbiAgICAgICAgcmV0dXJuIHBhcnNlU2VhcmNoUHJvamVjdENvbW1hbmQocGFyc2VkKTtcbiAgICAgIGNhc2UgXCJxdWVyeV9wcm9qZWN0XCI6XG4gICAgICAgIHJldHVybiBwYXJzZVF1ZXJ5UHJvamVjdENvbW1hbmQocGFyc2VkKTtcbiAgICAgIGNhc2UgXCJjb252ZXJzYXRpb25cIjpcbiAgICAgICAgcmV0dXJuIHBhcnNlQ29udmVyc2F0aW9uQ29tbWFuZChwYXJzZWQpO1xuICAgICAgY2FzZSBcImFydGlmYWN0c1wiOlxuICAgICAgICByZXR1cm4gcGFyc2VBcnRpZmFjdHNDb21tYW5kKHBhcnNlZCk7XG4gICAgICBjYXNlIFwiZG9jc1wiOlxuICAgICAgICByZXR1cm4gcGFyc2VEb2NzQ29tbWFuZChwYXJzZWQpO1xuICAgICAgY2FzZSBcInByb21wdFwiOiB7XG4gICAgICAgIGNvbnN0IHN0YXRlbWVudCA9IHRoaXMucGFyc2VQcm9tcHRTdGF0ZW1lbnQocGFyc2VkLnByb21wdCk7XG4gICAgICAgIGNvbnN0IHN0b3BJZkNvbmRpdGlvbiA9IHBhcnNlZD8ub3B0aW9ucz8uW1wic3RvcF9pZlwiXTtcbiAgICAgICAgY29uc3Qgc3RvcElmTm90Q29uZGl0aW9uID0gcGFyc2VkPy5vcHRpb25zPy5bXCJzdG9wX2lmX25vdFwiXTtcblxuICAgICAgICBpZiAoc3RvcElmQ29uZGl0aW9uIHx8IHN0b3BJZk5vdENvbmRpdGlvbikge1xuICAgICAgICAgIHN0YXRlbWVudC5hZGRTdG9wQ29uZGl0aW9uKHtcbiAgICAgICAgICAgIHRhcmdldDogc3RvcElmQ29uZGl0aW9uIHx8IHN0b3BJZk5vdENvbmRpdGlvbixcbiAgICAgICAgICAgIHR5cGU6IHN0b3BJZkNvbmRpdGlvbiA/IFwiaWZcIiA6IFwiaWZfbm90XCIsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGVtZW50O1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmhhbmRsZWQgY29tbWFuZDogJHtwYXJzZWQuY29tbWFuZH1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgbXVsdGktbGluZSBjb21tYW5kIHRleHRcbiAgICovXG4gIHByaXZhdGUgc3RhdGljIHBhcnNlQ29tbWFuZFRleHQodGV4dDogc3RyaW5nKTogUGFyc2VkQ29tbWFuZFRleHQge1xuICAgIGNvbnN0IGlzQ29tbWFuZCA9IHRleHQuc3RhcnRzV2l0aCh0aGlzLkNPTU1BTkRfUFJFRklYKTtcblxuICAgIC8vIEV4dHJhY3QgY29tbWFuZCBhbmQgcmVtYWluaW5nIHRleHRcbiAgICBjb25zdCBwYXJ0cyA9IHNwbGl0VGV4dFdpdGhRdW90ZXModGV4dCk7XG5cbiAgICBjb25zdCByYXdDb21tYW5kID0gaXNDb21tYW5kID8gcGFydHNbMF0gOiBcIlwiO1xuICAgIGxldCBjb21tYW5kTmFtZSA9IGlzQ29tbWFuZCA/IHJhd0NvbW1hbmQuc3Vic3RyaW5nKDEpIDogXCJwcm9tcHRcIjtcblxuICAgIGlmIChpc0NvbW1hbmQpIHtcbiAgICAgIC8vIFJlc29sdmUgY29tbWFuZFxuICAgICAgY29uc3QgbWF0Y2hlcyA9IGdldENvbW1hbmRNYXRjaGVzKGNvbW1hbmROYW1lKTtcbiAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY29tbWFuZDogJHtyYXdDb21tYW5kfWApO1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEFtYmlndW91cyBjb21tYW5kICcke3Jhd0NvbW1hbmR9Jy4gQ291bGQgYmU6ICR7bWF0Y2hlcy5qb2luKFwiLCBcIil9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29tbWFuZE5hbWUgPSBtYXRjaGVzWzBdLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLy8gUGFyc2Ugb3B0aW9ucyBhbmQgY29udGVudFxuICAgIGNvbnN0IG9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICBsZXQgcHJvbXB0UGFydHM6IHN0cmluZ1tdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gaXNDb21tYW5kID8gMSA6IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuXG4gICAgICBpZiAocGFydC5zdGFydHNXaXRoKHRoaXMuQ09NTUFORF9QUkVGSVgpKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb25zID0gZ2V0Q29tbWFuZE9wdGlvbkRlZmluaXRpb25zKGNvbW1hbmROYW1lKTtcbiAgICAgICAgaWYgKCFkZWZpbml0aW9ucykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBpbnZhbGlkIG9wdGlvbjogXCIke3BhcnR9XCIsIGNvbW1hbmQgXCIke2NvbW1hbmROYW1lfVwiIGhhcyBubyBvcHRpb25zYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXJzZSBvcHRpb25cbiAgICAgICAgY29uc3Qgb3B0aW9uS2V5ID0gcGFydC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IGRlZmluaXRpb25zW29wdGlvbktleV07XG5cbiAgICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgaW52YWxpZCBvcHRpb246IFwiJHtwYXJ0fVwiLCBjb21tYW5kIFwiJHtyYXdDb21tYW5kfVwiIGhhcyBvcHRpb25zOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhkZWZpbml0aW9ucylcbiAgICAgICAgICAgICl9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9uID09PSBcIndpdGhfYXJnXCIpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgaWYgKGkgPCBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbb3B0aW9uS2V5XSA9IHBhcnRzW2ldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBNaXNzaW5nIHZhbHVlIGZvciBvcHRpb246IFwiJHtwYXJ0fVwiLCBjb21tYW5kIFwiJHtyYXdDb21tYW5kfVwiYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9uID09PSBcIndpdGhfcHJvbXB0XCIpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgbGV0IGFyZyA9IFwiXCI7XG4gICAgICAgICAgd2hpbGUgKGkgPCBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRQYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICBpZiAobmV4dFBhcnQuc3RhcnRzV2l0aCh0aGlzLkNPTU1BTkRfUFJFRklYKSkge1xuICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJnID0gKGFyZyA/IFwiIFwiICsgYXJnIDogXCJcIikgKyBwYXJ0c1tpXTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgTWlzc2luZyB2YWx1ZSBmb3Igb3B0aW9uOiBcIiR7cGFydH1cIiwgY29tbWFuZCBcIiR7cmF3Q29tbWFuZH1cImBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdGlvbnNbb3B0aW9uS2V5XSA9IGFyZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zW29wdGlvbktleV0gPSBcInRydWVcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbXB0UGFydHMucHVzaChwYXJ0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29tbWFuZDogY29tbWFuZE5hbWUsXG4gICAgICByYXdDb21tYW5kLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHByb21wdDogcHJvbXB0UGFydHMuam9pbihcIiBcIiksXG4gICAgfTtcbiAgfVxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgPG1hcnRpbi5iZWNoYXJkQERldkNvbnN1bHQuY2E+XG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIEZpbGU6IHNyYy91dGlscy9jb21tYW5kcy9Db21tYW5kTWFwLnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKlxuICogRGVmaW5lcyBjb21tYW5kcyBhbmQgdGhlaXIgb3B0aW9uc1xuICovXG5cbi8qKlxuICogVHlwZSBvZiBhcmd1bWVudCByZXF1aXJlZCBmb3IgYW4gb3B0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIE9wdGlvblR5cGUgPSBcIm5vX2FyZ1wiIHwgXCJ3aXRoX2FyZ1wiIHwgXCJ3aXRoX3Byb21wdFwiO1xuXG4vKipcbiAqIE9wdGlvbiBmb3JtYXQ6XG4gKiBrZXk6IG9wdGlvbiBuYW1lXG4gKiB2YWx1ZTogT3B0aW9uVHlwZSBpbmRpY2F0aW5nIGFyZ3VtZW50IHJlcXVpcmVtZW50XG4gKi9cbnR5cGUgQ29tbWFuZE9wdGlvbkRlZmluaXRpb25zID0geyBba2V5OiBzdHJpbmddOiBPcHRpb25UeXBlIH07XG5cbi8qKlxuICogQmFzZSBjb21tYW5kIGluZm8gd2l0aG91dCBvcHRpb25zXG4gKi9cbmludGVyZmFjZSBCYXNlQ29tbWFuZEluZm8ge1xuICBmdWxsOiBzdHJpbmc7XG4gIGFiYnJldmlhdGlvbjogc3RyaW5nO1xuICBvcHRpb25zPzogQ29tbWFuZE9wdGlvbkRlZmluaXRpb25zO1xufVxuXG4vKipcbiAqIE1hcHMgY29tbWFuZCBuYW1lcyB0byB0aGVpciBmdWxsIG5hbWVzLCBhYmJyZXZpYXRpb25zIGFuZCBhbGxvd2VkIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IENPTU1BTkRfTUFQOiB7IFtrZXk6IHN0cmluZ106IEJhc2VDb21tYW5kSW5mbyB9ID0ge1xuICAvLyBCYXNpYyBjb21tYW5kc1xuICByZXBlYXQ6IHtcbiAgICBmdWxsOiBcInJlcGVhdFwiLFxuICAgIGFiYnJldmlhdGlvbjogXCJyXCIsXG4gICAgb3B0aW9uczoge1xuICAgICAgbWF4OiBcIndpdGhfYXJnXCIsIC8vIFJlcXVpcmVzIG51bWJlciBhcmd1bWVudFxuICAgICAgc3RvcF9pZjogXCJ3aXRoX3Byb21wdFwiLCAvLyBSZXF1aXJlcyBjb25kaXRpb24gdGV4dFxuICAgICAgc3RvcF9pZl9ub3Q6IFwid2l0aF9wcm9tcHRcIiwgLy8gUmVxdWlyZXMgY29uZGl0aW9uIHRleHRcbiAgICB9LFxuICB9LFxuXG4gIHByb21wdDoge1xuICAgIGZ1bGw6IFwicHJvbXB0XCIsXG4gICAgYWJicmV2aWF0aW9uOiBcIlwiLFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHN0b3BfaWY6IFwid2l0aF9wcm9tcHRcIiwgLy8gUmVxdWlyZXMgY29uZGl0aW9uIHRleHRcbiAgICAgIHN0b3BfaWZfbm90OiBcIndpdGhfcHJvbXB0XCIsIC8vIFJlcXVpcmVzIGNvbmRpdGlvbiB0ZXh0XG4gICAgfSxcbiAgfSxcblxuICAvLyBDb250ZW50IGNvbW1hbmRzXG4gIGNvbnZlcnNhdGlvbjoge1xuICAgIGZ1bGw6IFwiY29udmVyc2F0aW9uXCIsXG4gICAgYWJicmV2aWF0aW9uOiBcImNcIixcbiAgICBvcHRpb25zOiB7XG4gICAgICBhcnRpZmFjdHM6IFwibm9fYXJnXCIsIC8vIEZsYWcgb25seVxuICAgICAgYTogXCJub19hcmdcIiwgLy8gRmxhZyBvbmx5XG4gICAgICBtdWx0aXBsZTogXCJub19hcmdcIiwgLy8gRmxhZyBvbmx5XG4gICAgICBtOiBcIm5vX2FyZ1wiLCAvLyBGbGFnIG9ubHlcbiAgICB9LFxuICB9LFxuXG4gIHN0b3BfaWY6IHtcbiAgICBmdWxsOiBcInN0b3BfaWZcIixcbiAgICBhYmJyZXZpYXRpb246IFwiXCIsXG4gIH0sXG5cbiAgc3RvcF9pZl9ub3Q6IHtcbiAgICBmdWxsOiBcInN0b3BfaWZfbm90XCIsXG4gICAgYWJicmV2aWF0aW9uOiBcIlwiLFxuICB9LFxuXG4gIGFydGlmYWN0czoge1xuICAgIGZ1bGw6IFwiYXJ0aWZhY3RzXCIsXG4gICAgYWJicmV2aWF0aW9uOiBcImFcIixcbiAgICBvcHRpb25zOiB7XG4gICAgICBtdWx0aXBsZTogXCJub19hcmdcIiwgLy8gRmxhZyBvbmx5XG4gICAgfSxcbiAgfSxcblxuICAvLyBQcm9qZWN0IGNvbW1hbmRzIHdpdGggbm8gb3B0aW9uc1xuICBkb2NzOiB7IGZ1bGw6IFwiZG9jc1wiLCBhYmJyZXZpYXRpb246IFwiZFwiIH0sXG4gIHByb2plY3Q6IHsgZnVsbDogXCJwcm9qZWN0XCIsIGFiYnJldmlhdGlvbjogXCJwXCIgfSxcbiAgc2VhcmNoX3Byb2plY3Q6IHsgZnVsbDogXCJzZWFyY2hfcHJvamVjdFwiLCBhYmJyZXZpYXRpb246IFwic3BcIiB9LFxuICBxdWVyeV9wcm9qZWN0OiB7IGZ1bGw6IFwicXVlcnlfcHJvamVjdFwiLCBhYmJyZXZpYXRpb246IFwicXBcIiB9LFxuXG4gIC8vIEFsaWFzIGNvbW1hbmRzICh3aXRoIEAgc3ludGF4IHN1cHBvcnQpXG4gIGFsaWFzOiB7IGZ1bGw6IFwiYWxpYXNcIiwgYWJicmV2aWF0aW9uOiBcIkArXCIgfSxcbiAgbGlzdF9hbGlhczogeyBmdWxsOiBcImxpc3RfYWxpYXNcIiwgYWJicmV2aWF0aW9uOiBcIkA/XCIgfSxcbiAgZGVsZXRlX2FsaWFzOiB7IGZ1bGw6IFwiZGVsZXRlX2FsaWFzXCIsIGFiYnJldmlhdGlvbjogXCJALVwiIH0sXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgdHlwZSBDb21tYW5kTmFtZSA9IGtleW9mIHR5cGVvZiBDT01NQU5EX01BUDtcblxuLyoqXG4gKiBHZXRzIHRoZSBmdWxsIGNvbW1hbmQgbmFtZSBmb3IgYW4gYWJicmV2aWF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdWxsQ29tbWFuZChhYmJyOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAvLyBIYW5kbGUgdGhlIHNwZWNpYWwgY2FzZSB3aGVyZSBhbGlhcyBjb21tYW5kIHN0YXJ0cyB3aXRoIEBcbiAgaWYgKGFiYnIuc3RhcnRzV2l0aChcIkBcIikpIHtcbiAgICBzd2l0Y2ggKGFiYnIpIHtcbiAgICAgIGNhc2UgXCJAK1wiOlxuICAgICAgICByZXR1cm4gXCJhbGlhc1wiO1xuICAgICAgY2FzZSBcIkAtXCI6XG4gICAgICAgIHJldHVybiBcImRlbGV0ZV9hbGlhc1wiO1xuICAgICAgY2FzZSBcIkA/XCI6XG4gICAgICAgIHJldHVybiBcImxpc3RfYWxpYXNcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgZW50cnkgPSBPYmplY3QuZW50cmllcyhDT01NQU5EX01BUCkuZmluZChcbiAgICAoW18sIGluZm9dKSA9PiBpbmZvLmFiYnJldmlhdGlvbiA9PT0gYWJici50b0xvd2VyQ2FzZSgpXG4gICk7XG4gIHJldHVybiBlbnRyeT8uWzBdO1xufVxuXG4vKipcbiAqIEdldHMgYWxsIHBvc3NpYmxlIGNvbW1hbmQgbWF0Y2hlcyBmb3IgYSBwYXJ0aWFsIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tbWFuZE1hdGNoZXMocGFydGlhbDogc3RyaW5nKTogQ29tbWFuZE5hbWVbXSB7XG4gIC8vIEhhbmRsZSBzcGVjaWFsIGFsaWFzIGFiYnJldmlhdGlvbnNcbiAgaWYgKHBhcnRpYWwuc3RhcnRzV2l0aChcIkBcIikpIHtcbiAgICBzd2l0Y2ggKHBhcnRpYWwpIHtcbiAgICAgIGNhc2UgXCJAK1wiOlxuICAgICAgICByZXR1cm4gW1wiYWxpYXNcIl07XG4gICAgICBjYXNlIFwiQC1cIjpcbiAgICAgICAgcmV0dXJuIFtcImRlbGV0ZV9hbGlhc1wiXTtcbiAgICAgIGNhc2UgXCJAP1wiOlxuICAgICAgICByZXR1cm4gW1wibGlzdF9hbGlhc1wiXTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzZWFyY2ggPSBwYXJ0aWFsLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhDT01NQU5EX01BUClcbiAgICAuZmlsdGVyKChbY29tbWFuZCwgaW5mb10pID0+IHtcbiAgICAgIHJldHVybiBpbmZvLmZ1bGwgPT09IHNlYXJjaCB8fCBpbmZvLmFiYnJldmlhdGlvbi50b0xvd2VyQ2FzZSgpID09PSBzZWFyY2g7XG4gICAgfSlcbiAgICAubWFwKChbY29tbWFuZF0pID0+IGNvbW1hbmQgYXMgQ29tbWFuZE5hbWUpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG9wdGlvbiByZXF1aXJlbWVudHMgZm9yIGEgY29tbWFuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tbWFuZE9wdGlvbkRlZmluaXRpb25zKFxuICBjb21tYW5kOiBzdHJpbmdcbik6IHsgW2tleTogc3RyaW5nXTogT3B0aW9uVHlwZSB9IHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgY29tbWFuZHMgPSBnZXRDb21tYW5kTWF0Y2hlcyhjb21tYW5kKTtcblxuICByZXR1cm4gQ09NTUFORF9NQVBbY29tbWFuZHNbMF0gYXMgQ29tbWFuZE5hbWVdPy5vcHRpb25zO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgPG1hcnRpbi5iZWNoYXJkQERldkNvbnN1bHQuY2E+XG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIEZpbGU6IHNyYy91dGlscy9jb21tYW5kcy9wYXJzZUFsaWFzQ29tbWFuZC50c1xuICogVGhpcyB3YXMgZ2VuZXJhdGVkIGJ5IENsYXVkZSBTb25uZXQgMy41LCB3aXRoIHRoZSBhc3Npc3RhbmNlIG9mIG15IGh1bWFuIG1lbnRvclxuICovXG5cbmltcG9ydCB7IFBhcnNlZENvbW1hbmRMaW5lLCBTY3JpcHRTdGF0ZW1lbnQgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcblxuLyoqXG4gKiBQYXJzZXMgYW4gYWxpYXMgY29tbWFuZCBpbnRvIGEgc2NyaXB0IG9iamVjdFxuICogQHBhcmFtIGNvbW1hbmQgLSBUaGUgcGFyc2VkIGNvbW1hbmQgbmFtZVxuICogQHBhcmFtIGFyZ3MgLSBBcnJheSBvZiBjb21tYW5kIGFyZ3VtZW50c1xuICogQHJldHVybnMgUGFyc2VkIHNjcmlwdCBvYmplY3RcbiAqIEB0aHJvd3MgRXJyb3IgaWYgY29tbWFuZCBzeW50YXggaXMgaW52YWxpZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBbGlhc0NvbW1hbmQoXG4gIHBhcnNlZENvbW1hbmRMaW5lOiBQYXJzZWRDb21tYW5kTGluZVxuKTogU2NyaXB0U3RhdGVtZW50IHtcbiAgY29uc3QgeyBjb21tYW5kLCBwcm9tcHQgfSA9IHBhcnNlZENvbW1hbmRMaW5lO1xuXG4gIGNvbnN0IGJhc2VTdGF0ZW1lbnQgPSBuZXcgU2NyaXB0U3RhdGVtZW50KHtcbiAgICBpc0NvbW1hbmQ6IHRydWUsXG4gICAgY29tbWFuZDogY29tbWFuZCxcbiAgICBvcHRpb25zOiB7fSxcbiAgICBwcm9tcHQ6IFwiXCIsXG4gIH0pO1xuXG4gIHN3aXRjaCAoY29tbWFuZCkge1xuICAgIGNhc2UgXCJhbGlhc1wiOiB7XG4gICAgICAvLyBFeHBlY3QgZm9ybWF0OiAvYWxpYXMgQG5hbWUgdGV4dFxuICAgICAgY29uc3QgYWxpYXNBcmdzID0gcHJvbXB0LnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuICAgICAgaWYgKGFsaWFzQXJncy5sZW5ndGggPCAyIHx8ICFhbGlhc0FyZ3NbMF0uc3RhcnRzV2l0aChcIkBcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhbGlhcyBzeW50YXguIFVzZTogL2FsaWFzIEBuYW1lIHRleHRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBhbGlhc05hbWUgPSBhbGlhc0FyZ3NbMF0uc3Vic3RyaW5nKDEpO1xuICAgICAgY29uc3QgYWxpYXNUZXh0ID0gYWxpYXNBcmdzLnNsaWNlKDEpLmpvaW4oXCIgXCIpO1xuICAgICAgaWYgKCFpc1ZhbGlkQWxpYXNOYW1lKGFsaWFzTmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBhbGlhcyBuYW1lLiBPbmx5IGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB1bmRlcnNjb3JlcyBhcmUgYWxsb3dlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTY3JpcHRTdGF0ZW1lbnQoe1xuICAgICAgICBpc0NvbW1hbmQ6IHRydWUsXG4gICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgIGFsaWFzQ29tbWFuZDoge1xuICAgICAgICAgIHR5cGU6IFwiYWxpYXNcIixcbiAgICAgICAgICBuYW1lOiBhbGlhc05hbWUsXG4gICAgICAgICAgdGV4dDogYWxpYXNUZXh0LFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2FzZSBcImRlbGV0ZV9hbGlhc1wiOiB7XG4gICAgICAvLyBFeHBlY3QgZm9ybWF0OiAvZGVsZXRlX2FsaWFzIEBuYW1lXG4gICAgICBjb25zdCBkZWxldGVBcmdzID0gcHJvbXB0LnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuICAgICAgaWYgKGRlbGV0ZUFyZ3MubGVuZ3RoICE9PSAxIHx8ICFkZWxldGVBcmdzWzBdLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgZGVsZXRlIGFsaWFzIHN5bnRheC4gVXNlOiAvZGVsZXRlX2FsaWFzIEBuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbGV0ZU5hbWUgPSBkZWxldGVBcmdzWzBdLnN1YnN0cmluZygxKTtcbiAgICAgIGlmICghaXNWYWxpZEFsaWFzTmFtZShkZWxldGVOYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIGFsaWFzIG5hbWUuIE9ubHkgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIHVuZGVyc2NvcmVzIGFyZSBhbGxvd2VkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU2NyaXB0U3RhdGVtZW50KHtcbiAgICAgICAgaXNDb21tYW5kOiB0cnVlLFxuICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICBhbGlhc0NvbW1hbmQ6IHtcbiAgICAgICAgICB0eXBlOiBcImRlbGV0ZV9hbGlhc1wiLFxuICAgICAgICAgIG5hbWU6IGRlbGV0ZU5hbWUsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYXNlIFwibGlzdF9hbGlhc1wiOiB7XG4gICAgICAvLyBFeHBlY3QgZm9ybWF0OiAvbGlzdF9hbGlhcyAobm8gYXJndW1lbnRzKVxuICAgICAgaWYgKHByb21wdC50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJMaXN0IGFsaWFzIGNvbW1hbmQgdGFrZXMgbm8gYXJndW1lbnRzLiBVc2U6IC9saXN0X2FsaWFzXCJcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBTY3JpcHRTdGF0ZW1lbnQoe1xuICAgICAgICBpc0NvbW1hbmQ6IHRydWUsXG4gICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgIGFsaWFzQ29tbWFuZDoge1xuICAgICAgICAgIHR5cGU6IFwibGlzdF9hbGlhc1wiLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhbGlhcyBjb21tYW5kOiAke2NvbW1hbmR9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYWxpYXMgY29tbWFuZCBhcmd1bWVudCBmb3JtYXRcbiAqIEBwYXJhbSBuYW1lIC0gQWxpYXMgbmFtZSB0byB2YWxpZGF0ZVxuICogQHJldHVybnMgVHJ1ZSBpZiBuYW1lIGlzIHZhbGlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQWxpYXNOYW1lKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gL15bYS16QS1aMC05X10rJC8udGVzdChuYW1lKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDI0IE1hcnRpbiBCZWNoYXJkIDxtYXJ0aW4uYmVjaGFyZEBEZXZDb25zdWx0LmNhPlxuICogVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBGaWxlOiBzcmMvdXRpbHMvY29tbWFuZHMvcGFyc2VDb250ZW50Q29tbWFuZHMudHNcbiAqIFRoaXMgd2FzIGdlbmVyYXRlZCBieSBDbGF1ZGUgU29ubmV0IDMuNSwgd2l0aCB0aGUgYXNzaXN0YW5jZSBvZiBteSBodW1hbiBtZW50b3JcbiAqL1xuXG5pbXBvcnQge1xuICBQYXJzZWRDb21tYW5kTGluZSxcbiAgU2NyaXB0U3RhdGVtZW50LFxuICBDb21tYW5kT3B0aW9ucyxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCI7XG5cbi8qKlxuICogUHJvY2Vzc2VzIGJhc2ljIGNvbnRlbnQgY29tbWFuZCBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NDb250ZW50T3B0aW9ucyhcbiAgb3B0aW9uczogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuKTogQ29tbWFuZE9wdGlvbnMge1xuICBjb25zdCBjb21tYW5kT3B0aW9uczogQ29tbWFuZE9wdGlvbnMgPSB7fTtcblxuICAvLyBQcm9jZXNzIG9wdGlvbnNcbiAgZm9yIChjb25zdCBba2V5LCBfXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zKSkge1xuICAgIHN3aXRjaCAoa2V5LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJhcnRpZmFjdHNcIjpcbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgIGNvbW1hbmRPcHRpb25zLmluY2x1ZGVBcnRpZmFjdHMgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgY29tbWFuZE9wdGlvbnMuZG93bmxvYWRNdWx0aXBsZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIG9wdGlvbjogLyR7a2V5fWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb21tYW5kT3B0aW9ucztcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBjb252ZXJzYXRpb24gY29tbWFuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VDb252ZXJzYXRpb25Db21tYW5kKFxuICBwYXJzZWRDb21tYW5kTGluZTogUGFyc2VkQ29tbWFuZExpbmVcbik6IFNjcmlwdFN0YXRlbWVudCB7XG4gIGNvbnN0IHsgb3B0aW9ucyB9ID0gcGFyc2VkQ29tbWFuZExpbmU7XG4gIGNvbnN0IGNvbW1hbmRPcHRpb25zID0gcHJvY2Vzc0NvbnRlbnRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIENvbnZlcnNhdGlvbiBzcGVjaWZpYyBkZWZhdWx0c1xuICBjb21tYW5kT3B0aW9ucy5pbmNsdWRlQ29udmVyc2F0aW9uID0gdHJ1ZTtcblxuICAvLyBWYWxpZGF0ZSBvcHRpb25zXG4gIGlmIChjb21tYW5kT3B0aW9ucy5kb3dubG9hZE11bHRpcGxlICYmICFjb21tYW5kT3B0aW9ucy5pbmNsdWRlQXJ0aWZhY3RzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiL211bHRpcGxlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCAvYXJ0aWZhY3RzIG9wdGlvblwiKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2NyaXB0U3RhdGVtZW50KHtcbiAgICBpc0NvbW1hbmQ6IHRydWUsXG4gICAgY29tbWFuZDogXCJjb252ZXJzYXRpb25cIixcbiAgICBvcHRpb25zOiBjb21tYW5kT3B0aW9ucyxcbiAgICBwcm9tcHQ6IHBhcnNlZENvbW1hbmRMaW5lLnByb21wdC50cmltKCksXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBhcnRpZmFjdHMgY29tbWFuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBcnRpZmFjdHNDb21tYW5kKFxuICBwYXJzZWRDb21tYW5kTGluZTogUGFyc2VkQ29tbWFuZExpbmVcbik6IFNjcmlwdFN0YXRlbWVudCB7XG4gIGNvbnN0IHsgb3B0aW9ucyB9ID0gcGFyc2VkQ29tbWFuZExpbmU7XG4gIGNvbnN0IGNvbW1hbmRPcHRpb25zID0gcHJvY2Vzc0NvbnRlbnRPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIEFydGlmYWN0cyBjb21tYW5kIGFsd2F5cyBpbmNsdWRlcyBhcnRpZmFjdHNcbiAgY29tbWFuZE9wdGlvbnMuaW5jbHVkZUFydGlmYWN0cyA9IHRydWU7XG4gIGNvbW1hbmRPcHRpb25zLmluY2x1ZGVDb252ZXJzYXRpb24gPSBmYWxzZTtcblxuICByZXR1cm4gbmV3IFNjcmlwdFN0YXRlbWVudCh7XG4gICAgaXNDb21tYW5kOiB0cnVlLFxuICAgIGNvbW1hbmQ6IFwiYXJ0aWZhY3RzXCIsXG4gICAgb3B0aW9uczogY29tbWFuZE9wdGlvbnMsXG4gICAgcHJvbXB0OiBwYXJzZWRDb21tYW5kTGluZS5wcm9tcHQudHJpbSgpLFxuICB9KTtcbn1cbiIsImltcG9ydCB7IFBhcnNlZENvbW1hbmRMaW5lLCBTY3JpcHRTdGF0ZW1lbnQgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcblxuLyoqXG4gKiBQYXJzZXMgYSBiYXNpYyBwcm9qZWN0IGNvbW1hbmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRG9jc0NvbW1hbmQoXG4gIHBhcnNlZENvbW1hbmRMaW5lOiBQYXJzZWRDb21tYW5kTGluZVxuKTogU2NyaXB0U3RhdGVtZW50IHtcbiAgcmV0dXJuIG5ldyBTY3JpcHRTdGF0ZW1lbnQoe1xuICAgIGlzQ29tbWFuZDogdHJ1ZSxcbiAgICBjb21tYW5kOiBcImRvY3NcIixcbiAgICBwcm9tcHQ6IHBhcnNlZENvbW1hbmRMaW5lLnByb21wdC50cmltKCksXG4gIH0pO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgPG1hcnRpbi5iZWNoYXJkQERldkNvbnN1bHQuY2E+XG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIEZpbGU6IHNyYy91dGlscy9jb21tYW5kcy9wYXJzZVByb2plY3RDb21tYW5kcy50c1xuICogVGhpcyB3YXMgZ2VuZXJhdGVkIGJ5IENsYXVkZSBTb25uZXQgMy41LCB3aXRoIHRoZSBhc3Npc3RhbmNlIG9mIG15IGh1bWFuIG1lbnRvclxuICovXG5cbmltcG9ydCB7IFBhcnNlZENvbW1hbmRMaW5lLCBTY3JpcHRTdGF0ZW1lbnQgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcblxuLyoqXG4gKiBQYXJzZXMgYSBiYXNpYyBwcm9qZWN0IGNvbW1hbmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUHJvamVjdENvbW1hbmQoXG4gIHBhcnNlZENvbW1hbmRMaW5lOiBQYXJzZWRDb21tYW5kTGluZVxuKTogU2NyaXB0U3RhdGVtZW50IHtcbiAgcmV0dXJuIG5ldyBTY3JpcHRTdGF0ZW1lbnQoe1xuICAgIGlzQ29tbWFuZDogdHJ1ZSxcbiAgICBjb21tYW5kOiBcInByb2plY3RcIixcbiAgICBwcm9tcHQ6IHBhcnNlZENvbW1hbmRMaW5lLnByb21wdC50cmltKCksXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhIHByb2plY3Qgc2VhcmNoIGNvbW1hbmQgd2l0aCBvcHRpb25hbCBzZWFyY2ggdGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTZWFyY2hQcm9qZWN0Q29tbWFuZChcbiAgcGFyc2VkQ29tbWFuZExpbmU6IFBhcnNlZENvbW1hbmRMaW5lXG4pOiBTY3JpcHRTdGF0ZW1lbnQge1xuICBjb25zdCB7IHByb21wdCB9ID0gcGFyc2VkQ29tbWFuZExpbmU7XG5cbiAgaWYgKCFwcm9tcHQudHJpbSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VhcmNoIHByb2plY3QgY29tbWFuZCByZXF1aXJlcyBzZWFyY2ggdGV4dFwiKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU2NyaXB0U3RhdGVtZW50KHtcbiAgICBpc0NvbW1hbmQ6IHRydWUsXG4gICAgY29tbWFuZDogXCJzZWFyY2hfcHJvamVjdFwiLFxuICAgIHNlYXJjaFRleHQ6IHByb21wdC50cmltKCksXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhIHByb2plY3QgcXVlcnkgY29tbWFuZCB3aXRoIHJlcXVpcmVkIHByb21wdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VRdWVyeVByb2plY3RDb21tYW5kKFxuICBwYXJzZWRDb21tYW5kTGluZTogUGFyc2VkQ29tbWFuZExpbmVcbik6IFNjcmlwdFN0YXRlbWVudCB7XG4gIGNvbnN0IHsgcHJvbXB0IH0gPSBwYXJzZWRDb21tYW5kTGluZTtcblxuICBpZiAoIXByb21wdC50cmltKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWVyeSBwcm9qZWN0IGNvbW1hbmQgcmVxdWlyZXMgYSBwcm9tcHRcIik7XG4gIH1cblxuICByZXR1cm4gbmV3IFNjcmlwdFN0YXRlbWVudCh7XG4gICAgaXNDb21tYW5kOiB0cnVlLFxuICAgIGNvbW1hbmQ6IFwicXVlcnlfcHJvamVjdFwiLFxuICAgIG9wdGlvbnM6IHt9LFxuICAgIHByb21wdDogcHJvbXB0LnRyaW0oKSxcbiAgfSk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogc3JjL3V0aWxzL2NvbW1hbmRzL3BhcnNlUmVwZWF0Q29tbWFuZC50c1xuICogVGhpcyB3YXMgZ2VuZXJhdGVkIGJ5IENsYXVkZSBTb25uZXQgMy41LCB3aXRoIHRoZSBhc3Npc3RhbmNlIG9mIG15IGh1bWFuIG1lbnRvclxuICovXG5cbmltcG9ydCB7IFBhcnNlZENvbW1hbmRMaW5lLCBTY3JpcHRTdGF0ZW1lbnQgfSBmcm9tIFwiLi4vLi4vdHlwZXNcIjtcbmltcG9ydCB7IHBhcnNlU3RvcENvbmRpdGlvbkNvbW1hbmQgfSBmcm9tIFwiLi9wYXJzZVN0b3BDb25kaXRpb25zXCI7XG5cbmNvbnN0IERFRkFVTFRfTUFYX1RSSUVTID0gMztcblxuLyoqXG4gKiBQYXJzZXMgYSByZXBlYXQgY29tbWFuZFxuICogRm9ybWF0OiAvcmVwZWF0IFsvbWF4IG51bWJlcl0gWy9zdG9wX2lmIGNvbmRpdGlvbiB8IC9zdG9wX2lmX25vdCBjb25kaXRpb25dIHByb21wdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSZXBlYXRDb21tYW5kKFxuICBwYXJzZWRDb21tYW5kTGluZTogUGFyc2VkQ29tbWFuZExpbmVcbik6IFNjcmlwdFN0YXRlbWVudCB7XG4gIGNvbnN0IHsgb3B0aW9ucywgcHJvbXB0IH0gPSBwYXJzZWRDb21tYW5kTGluZTtcblxuICAvLyBFeHRyYWN0IG9wdGlvbnNcbiAgY29uc3QgbWF4VHJpZXMgPSBvcHRpb25zLm1heCA/IHBhcnNlSW50KG9wdGlvbnMubWF4LCAxMCkgOiBERUZBVUxUX01BWF9UUklFUztcbiAgaWYgKGlzTmFOKG1heFRyaWVzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgL21heCB2YWx1ZSAtIG11c3QgYmUgYSBudW1iZXJcIik7XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBwcm9tcHRcbiAgaWYgKCFwcm9tcHQgfHwgcHJvbXB0LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9tcHQgcHJvdmlkZWQgYWZ0ZXIgL3JlcGVhdCBjb21tYW5kXCIpO1xuICB9XG5cbiAgLy8gSGFuZGxlIHN0b3AgY29uZGl0aW9uc1xuICBjb25zdCBzdG9wSWZDb25kaXRpb24gPSBvcHRpb25zW1wic3RvcF9pZlwiXTtcbiAgY29uc3Qgc3RvcElmTm90Q29uZGl0aW9uID0gb3B0aW9uc1tcInN0b3BfaWZfbm90XCJdO1xuXG4gIGlmIChzdG9wSWZDb25kaXRpb24gJiYgc3RvcElmTm90Q29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJDYW5ub3QgdXNlIGJvdGggL3N0b3BfaWYgYW5kIC9zdG9wX2lmX25vdCBvcHRpb25zIHRvZ2V0aGVyXCJcbiAgICApO1xuICB9XG5cbiAgLy8gSW5pdGlhbGl6ZSBjb21tYW5kIG9wdGlvbnNcbiAgY29uc3QgY29tbWFuZE9wdGlvbnMgPSB7XG4gICAgbWF4VHJpZXMsXG4gIH07XG5cbiAgY29uc3Qgc3RhdGVtZW50ID0gbmV3IFNjcmlwdFN0YXRlbWVudCh7XG4gICAgaXNDb21tYW5kOiB0cnVlLFxuICAgIGNvbW1hbmQ6IFwicmVwZWF0XCIsXG4gICAgb3B0aW9uczogY29tbWFuZE9wdGlvbnMsXG4gICAgcHJvbXB0OiBwcm9tcHQudHJpbSgpLFxuICB9KTtcblxuICAvLyBBZGQgc3RvcCBjb25kaXRpb25zIHRvIG9wdGlvbnMgaWYgcHJlc2VudFxuICBpZiAoc3RvcElmQ29uZGl0aW9uIHx8IHN0b3BJZk5vdENvbmRpdGlvbikge1xuICAgIHN0YXRlbWVudC5hZGRTdG9wQ29uZGl0aW9uKHtcbiAgICAgIHRhcmdldDogc3RvcElmQ29uZGl0aW9uIHx8IHN0b3BJZk5vdENvbmRpdGlvbixcbiAgICAgIHR5cGU6IHN0b3BJZkNvbmRpdGlvbiA/IFwiaWZcIiA6IFwiaWZfbm90XCIsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc3RhdGVtZW50O1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgPG1hcnRpbi5iZWNoYXJkQERldkNvbnN1bHQuY2E+XG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIEZpbGU6IHNyYy91dGlscy9jb21tYW5kcy9wYXJzZVN0b3BDb25kaXRpb25zLnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKi9cblxuaW1wb3J0IHsgc3RhdCB9IGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgUGFyc2VkQ29tbWFuZExpbmUsIFNjcmlwdFN0YXRlbWVudCwgU3RvcENvbmRpdGlvbiB9IGZyb20gXCIuLi8uLi90eXBlc1wiO1xuXG4vKipcbiAqIFBhcnNlcyBhIHN0b3AgY29uZGl0aW9uIGZyb20gY29tbWFuZCB0ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN0b3BDb25kaXRpb25Db21tYW5kKFxuICBwYXJzZWRDb21tYW5kTGluZTogUGFyc2VkQ29tbWFuZExpbmVcbik6IFNjcmlwdFN0YXRlbWVudCB7XG4gIGNvbnN0IHRhcmdldCA9IHBhcnNlZENvbW1hbmRMaW5lLnByb21wdDtcblxuICBjb25zdCB0eXBlID0gcGFyc2VkQ29tbWFuZExpbmUuY29tbWFuZCA9PT0gXCJzdG9wX2lmXCIgPyBcImlmXCIgOiBcImlmX25vdFwiO1xuXG4gIGNvbnN0IHN0YXRlbWVudCA9IG5ldyBTY3JpcHRTdGF0ZW1lbnQoe1xuICAgIGlzQ29tbWFuZDogdHJ1ZSxcbiAgICBjb21tYW5kOiBwYXJzZWRDb21tYW5kTGluZS5jb21tYW5kLFxuICAgIG9wdGlvbnM6IHsgc3RvcENvbmRpdGlvbnM6IFt7IHRhcmdldCwgdHlwZSB9XSB9LFxuICB9KTtcblxuICByZXR1cm4gc3RhdGVtZW50O1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgPG1hcnRpbi5iZWNoYXJkQERldkNvbnN1bHQuY2E+XG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIEZpbGU6IC9Vc2Vycy9tYXJ0aW5iZWNoYXJkL2Rldi9jbGF1ZGVleHQvc3JjL3V0aWxzL2dldENsYXVkZUlkcy50c1xuICogVGhpcyB3YXMgZ2VuZXJhdGVkIGJ5IENsYXVkZSBTb25uZXQgMy41LCB3aXRoIHRoZSBhc3Npc3RhbmNlIG9mIG15IGh1bWFuIG1lbnRvclxuICpcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciByZXRyaWV2aW5nIG9yZ2FuaXphdGlvbiBhbmQgcHJvamVjdCBJRHMgZnJvbSBDbGF1ZGVcbiAqL1xuXG5pbXBvcnQgeyBnZXRIZWFkZXJzIH0gZnJvbSBcIi4vZ2V0SGVhZGVyc1wiO1xuaW1wb3J0IHR5cGUgeyBDb252ZXJzYXRpb24gfSBmcm9tIFwiLi4vdHlwZXNcIjtcblxuY29uc3QgQVBJX1VSTCA9IFwiaHR0cHM6Ly9hcGkuY2xhdWRlLmFpL2FwaS9vcmdhbml6YXRpb25zXCI7XG5cbi8qKlxuICogR2V0cyBwcm9qZWN0IGFuZCBjb252ZXJzYXRpb24gSURzIGZyb20gdGhlIGN1cnJlbnQgVVJMXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJZHNGcm9tVXJsKCk6IHtcbiAgcHJvamVjdElkOiBzdHJpbmcgfCBudWxsO1xuICBjb252ZXJzYXRpb25JZDogc3RyaW5nIHwgbnVsbDtcbn0ge1xuICBjb25zdCBwcm9qZWN0TWF0Y2ggPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUubWF0Y2goL1xcL3Byb2plY3RcXC8oW15cXC9dKykvKTtcbiAgaWYgKHByb2plY3RNYXRjaCkge1xuICAgIHJldHVybiB7IHByb2plY3RJZDogcHJvamVjdE1hdGNoWzFdLCBjb252ZXJzYXRpb25JZDogbnVsbCB9O1xuICB9XG5cbiAgY29uc3QgY2hhdE1hdGNoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLm1hdGNoKC9cXC9jaGF0XFwvKFteXFwvXSspLyk7XG4gIGlmICghY2hhdE1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJQbGVhc2UgbmF2aWdhdGUgdG8gYSBDbGF1ZGUgY2hhdCBvciBwcm9qZWN0IHBhZ2UgYmVmb3JlIHVzaW5nIHRoaXMgY29tbWFuZFwiXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcHJvamVjdElkOiBudWxsLFxuICAgIGNvbnZlcnNhdGlvbklkOiBjaGF0TWF0Y2hbMV0sXG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgb3JnYW5pemF0aW9uIElEIGZyb20gY29va2llc1xuICogQHRocm93cyBFcnJvciBpZiBvcmdhbml6YXRpb24gSUQgaXMgbm90IGZvdW5kIG9yIGludmFsaWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE9yZ2FuaXphdGlvbklkKCk6IHN0cmluZyB7XG4gIGNvbnN0IGNvb2tpZSA9IGRvY3VtZW50LmNvb2tpZVxuICAgIC5zcGxpdChcIjsgXCIpXG4gICAgLmZpbmQoKHJvdykgPT4gcm93LnN0YXJ0c1dpdGgoXCJsYXN0QWN0aXZlT3JnPVwiKSk7XG5cbiAgaWYgKCFjb29raWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcmdhbml6YXRpb24gSUQgbm90IGZvdW5kIGluIGNvb2tpZXNcIik7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZS5zcGxpdChcIj1cIilbMV0pO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9eXCJ8XCIkL2csIFwiXCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3JnYW5pemF0aW9uIElEIGZvcm1hdCBpbiBjb29raWVcIik7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9qZWN0IFVVSUQgZm9yIEFQSSByZXF1ZXN0c1xuICogQHBhcmFtIG9yZ2FuaXphdGlvbklkIC0gT3JnYW5pemF0aW9uIElEIHRvIHVzZSBmb3IgQVBJIHJlcXVlc3RcbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHByb2plY3QgVVVJRFxuICogQHRocm93cyBFcnJvciBpZiBwcm9qZWN0IFVVSUQgY2Fubm90IGJlIHJldHJpZXZlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvamVjdFV1aWQob3JnYW5pemF0aW9uSWQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IHsgcHJvamVjdElkLCBjb252ZXJzYXRpb25JZCB9ID0gZ2V0SWRzRnJvbVVybCgpO1xuXG4gIGlmIChwcm9qZWN0SWQpIHtcbiAgICByZXR1cm4gcHJvamVjdElkO1xuICB9XG5cbiAgaWYgKGNvbnZlcnNhdGlvbklkKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgIGAke0FQSV9VUkx9LyR7b3JnYW5pemF0aW9uSWR9L2NoYXRfY29udmVyc2F0aW9ucy8ke2NvbnZlcnNhdGlvbklkfT90cmVlPVRydWUmcmVuZGVyaW5nX21vZGU9bWVzc2FnZXNgLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IGdldEhlYWRlcnMoKSxcbiAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiLFxuICAgICAgfVxuICAgICk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gZmV0Y2ggY29udmVyc2F0aW9uIGRldGFpbHM6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YTogQ29udmVyc2F0aW9uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGNvbnN0IHByb2plY3RVdWlkID0gZGF0YS5wcm9qZWN0X3V1aWQ7XG5cbiAgICBpZiAoIXByb2plY3RVdWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9qZWN0IFVVSUQgbm90IGZvdW5kIGluIGNvbnZlcnNhdGlvbiBkZXRhaWxzXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9qZWN0VXVpZDtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIk5vIHByb2plY3Qgb3IgY29udmVyc2F0aW9uIElEIGZvdW5kIGluIFVSTFwiKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDI0IE1hcnRpbiBCZWNoYXJkIDxtYXJ0aW4uYmVjaGFyZEBEZXZDb25zdWx0LmNhPlxuICogVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBGaWxlOiAvVXNlcnMvbWFydGluYmVjaGFyZC9kZXYvY2xhdWRlZXh0L3NyYy91dGlscy9nZXRDb252ZXJzYXRpb24udHNcbiAqIFRoaXMgd2FzIGdlbmVyYXRlZCBieSBDbGF1ZGUgU29ubmV0IDMuNSwgd2l0aCB0aGUgYXNzaXN0YW5jZSBvZiBteSBodW1hbiBtZW50b3JcbiAqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgcmV0cmlldmluZyBjb252ZXJzYXRpb24gZGV0YWlscyBmcm9tIENsYXVkZSdzIEFQSVxuICovXG5cbmltcG9ydCB7IGdldEhlYWRlcnMgfSBmcm9tIFwiLi9nZXRIZWFkZXJzXCI7XG5pbXBvcnQgeyBnZXRPcmdhbml6YXRpb25JZCwgZ2V0SWRzRnJvbVVybCB9IGZyb20gXCIuL2dldENsYXVkZUlkc1wiO1xuaW1wb3J0IHR5cGUgeyBDb252ZXJzYXRpb24gfSBmcm9tIFwiLi4vdHlwZXNcIjtcblxuY29uc3QgQVBJX1VSTCA9IFwiaHR0cHM6Ly9hcGkuY2xhdWRlLmFpL2FwaS9vcmdhbml6YXRpb25zXCI7XG5cbi8qKlxuICogR2V0cyBjdXJyZW50IGNvbnZlcnNhdGlvbiBkZXRhaWxzIGluY2x1ZGluZyBsYXRlc3QgbWVzc2FnZSBJRFxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8geyBjb252ZXJzYXRpb25JZCwgcGFyZW50TWVzc2FnZVV1aWQgfVxuICogQHRocm93cyBFcnJvciBpZiBjb252ZXJzYXRpb24gZGV0YWlscyBjYW5ub3QgYmUgcmV0cmlldmVkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDdXJyZW50Q29udmVyc2F0aW9uRGV0YWlscygpOiBQcm9taXNlPENvbnZlcnNhdGlvbj4ge1xuICAvLyBHZXQgY29udmVyc2F0aW9uIElEIGZyb20gVVJMXG4gIGNvbnN0IG1hdGNoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLm1hdGNoKC9cXC9jaGF0XFwvKFteXFwvXSspLyk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgbmF2aWdhdGUgdG8gYSBDbGF1ZGUgY2hhdCBwYWdlIGZpcnN0XCIpO1xuICB9XG4gIGNvbnN0IGNvbnZlcnNhdGlvbklkID0gbWF0Y2hbMV07XG5cbiAgcmV0dXJuIGdldENvbnZlcnNhdGlvbkRldGFpbHMoY29udmVyc2F0aW9uSWQpO1xufVxuXG4vKipcbiAqIEdldHMgY29udmVyc2F0aW9uIGRldGFpbHMgaW5jbHVkaW5nIGxhdGVzdCBtZXNzYWdlIElEXG4gKiBAcGFyYW0gY29udmVyc2F0aW9uSWQgaWRlbnRpZmllcyB0aGUgY29udmVyc2F0aW9uIGZvciB3aGljaCB0byBnZXQgdGhlIGRldGFpbHMuXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB7IGNvbnZlcnNhdGlvbklkLCBwYXJlbnRNZXNzYWdlVXVpZCB9XG4gKiBAdGhyb3dzIEVycm9yIGlmIGNvbnZlcnNhdGlvbiBkZXRhaWxzIGNhbm5vdCBiZSByZXRyaWV2ZWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvbnZlcnNhdGlvbkRldGFpbHMoXG4gIGNvbnZlcnNhdGlvbklkOiBzdHJpbmdcbik6IFByb21pc2U8Q29udmVyc2F0aW9uPiB7XG4gIGNvbnN0IG9yZ0lkID0gZ2V0T3JnYW5pemF0aW9uSWQoKTtcblxuICB0cnkge1xuICAgIC8vIEdldCBjb252ZXJzYXRpb24gZGV0YWlsc1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICBgJHtBUElfVVJMfS8ke29yZ0lkfS9jaGF0X2NvbnZlcnNhdGlvbnMvJHtjb252ZXJzYXRpb25JZH0/dHJlZT1UcnVlJnJlbmRlcmluZ19tb2RlPW1lc3NhZ2VzYCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiBnZXRIZWFkZXJzKCksXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgIH1cbiAgICApO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnZlcnNhdGlvbjogQ29udmVyc2F0aW9uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgcmV0dXJuIGNvbnZlcnNhdGlvbjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRmFpbGVkIHRvIGdldCBjb252ZXJzYXRpb24gZGV0YWlsczogJHtcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBcIlVua25vd24gZXJyb3JcIlxuICAgICAgfWBcbiAgICApO1xuICB9XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogL3NyYy91dGlscy9nZXRIZWFkZXJzLnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhlYWRlcnMoKTogSGVhZGVyc0luaXQge1xuICByZXR1cm4ge1xuICAgIEFjY2VwdDogXCIqLypcIixcbiAgICBcIkFjY2VwdC1FbmNvZGluZ1wiOiBcImd6aXAsIGRlZmxhdGUsIGJyLCB6c3RkXCIsXG4gICAgXCJBY2NlcHQtTGFuZ3VhZ2VcIjogXCJlbi1VUyxlbjtxPTAuOSxmci1DQTtxPTAuOCxmcjtxPTAuN1wiLFxuICAgIFwiQW50aHJvcGljLUNsaWVudC1TaGFcIjogXCJ1bmtub3duXCIsXG4gICAgXCJBbnRocm9waWMtQ2xpZW50LVZlcnNpb25cIjogXCJ1bmtub3duXCIsXG4gICAgXCJDYWNoZS1Db250cm9sXCI6IFwibm8tY2FjaGVcIixcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBPcmlnaW46IFwiaHR0cHM6Ly9jbGF1ZGUuYWlcIixcbiAgICBQcmFnbWE6IFwibm8tY2FjaGVcIixcbiAgICBSZWZlcmVyOiBcImh0dHBzOi8vY2xhdWRlLmFpL1wiLFxuICAgIFwiU2VjLUNoLVVhXCI6XG4gICAgICAnXCJDaHJvbWl1bVwiO3Y9XCIxMjhcIiwgXCJOb3Q7QT1CcmFuZFwiO3Y9XCIyNFwiLCBcIkdvb2dsZSBDaHJvbWVcIjt2PVwiMTI4XCInLFxuICAgIFwiU2VjLUNoLVVhLU1vYmlsZVwiOiBcIj8wXCIsXG4gICAgXCJTZWMtQ2gtVWEtUGxhdGZvcm1cIjogJ1wibWFjT1NcIicsXG4gICAgUHJpb3JpdHk6IFwidT0xLCBpXCIsXG4gIH07XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyNCBNYXJ0aW4gQmVjaGFyZCA8bWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYT5cbiAqIFRoaXMgc29mdHdhcmUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICogRmlsZTogc3JjL3V0aWxzL3JlcXVlc3RDb21wbGV0aW9uLnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKi9cblxuaW1wb3J0IHsgZ2V0SGVhZGVycyB9IGZyb20gXCIuL2dldEhlYWRlcnNcIjtcbmltcG9ydCB7IGdldE9yZ2FuaXphdGlvbklkIH0gZnJvbSBcIi4vZ2V0Q2xhdWRlSWRzXCI7XG5pbXBvcnQge1xuICBnZXRDdXJyZW50Q29udmVyc2F0aW9uRGV0YWlscyxcbiAgZ2V0Q29udmVyc2F0aW9uRGV0YWlscyxcbn0gZnJvbSBcIi4vZ2V0Q29udmVyc2F0aW9uXCI7XG5pbXBvcnQgeyBFdmVudFN0cmVhbVBhcnNlciB9IGZyb20gXCIuL0V2ZW50U3RyZWFtUGFyc2VyXCI7XG5pbXBvcnQgdHlwZSB7IENvbXBsZXRpb25SZXNwb25zZSB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG5jb25zdCBBUElfVVJMID0gXCJodHRwczovL2FwaS5jbGF1ZGUuYWkvYXBpL29yZ2FuaXphdGlvbnNcIjtcbmNvbnN0IFNUUkVBTUlOR19BUElfVVJMID0gXCJodHRwczovL2NsYXVkZS5haS9hcGkvb3JnYW5pemF0aW9uc1wiO1xuY29uc3QgREVGQVVMVF9USU1FWk9ORSA9IFwiQW1lcmljYS9Ub3JvbnRvXCI7XG5cbi8qKlxuICogUGFyYW1ldGVycyBmb3IgY29tcGxldGlvbiByZXF1ZXN0c1xuICovXG5pbnRlcmZhY2UgQ29tcGxldGlvblJlcXVlc3RQYXJhbXMge1xuICBwcm9tcHQ6IHN0cmluZztcbiAgdGltZXpvbmU/OiBzdHJpbmc7XG4gIGF0dGFjaG1lbnRzPzogYW55W107XG4gIGZpbGVzPzogYW55W107XG4gIHN5bmNTb3VyY2VzPzogYW55W107XG4gIHJlbmRlcmluZ01vZGU/OiBcIm1lc3NhZ2VzXCIgfCBcImpzb25cIjtcbiAgc3RyZWFtPzogYm9vbGVhbjtcbiAgY29udmVyc2F0aW9uSWQ/OiBzdHJpbmc7XG4gIG9uUHJvZ3Jlc3M/OiAoY2h1bms6IHN0cmluZykgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBNYWtlcyBhIG5vbi1zdHJlYW1pbmcgY29tcGxldGlvbiByZXF1ZXN0IHRvIENsYXVkZSdzIEFQSVxuICovXG5hc3luYyBmdW5jdGlvbiBtYWtlTm9uU3RyZWFtaW5nUmVxdWVzdChcbiAgb3JnSWQ6IHN0cmluZyxcbiAgZW5kcG9pbnQ6IHN0cmluZyxcbiAgcmVxdWVzdEJvZHk6IGFueVxuKTogUHJvbWlzZTxDb21wbGV0aW9uUmVzcG9uc2U+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChlbmRwb2ludCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczoge1xuICAgICAgLi4uZ2V0SGVhZGVycygpLFxuICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICB9LFxuICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gIH0pO1xuXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gIH1cblxuICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICByZXR1cm4ge1xuICAgIGNvbXBsZXRpb246IGRhdGEuY29tcGxldGlvbixcbiAgICBzdG9wX3JlYXNvbjogZGF0YS5zdG9wX3JlYXNvbiB8fCBcIlwiLCAvLyBDb252ZXJ0IG51bGwgdG8gZW1wdHkgc3RyaW5nXG4gICAgbW9kZWw6IGRhdGEubW9kZWwgfHwgXCJcIixcbiAgICBzdG9wOiBkYXRhLnN0b3AsXG4gICAgbG9nX2lkOiBkYXRhLmxvZ19pZCB8fCBcIlwiLFxuICAgIG1lc3NhZ2VMaW1pdDogZGF0YS5tZXNzYWdlTGltaXQgfHwge1xuICAgICAgdHlwZTogXCJub25lXCIsXG4gICAgICByZW1haW5pbmc6IDAsXG4gICAgfSxcbiAgfTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGEgc3RyZWFtaW5nIHJlc3BvbnNlIHdpdGggdGhlIGV2ZW50IHN0cmVhbSBwYXJzZXJcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlU3RyZWFtaW5nUmVzcG9uc2UoXG4gIHJlc3BvbnNlOiBSZXNwb25zZSxcbiAgb25Qcm9ncmVzcz86IChjaHVuazogc3RyaW5nKSA9PiB2b2lkXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBoYXMgbm8gYm9keVwiKTtcbiAgfVxuXG4gIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgcGFyc2VyID0gbmV3IEV2ZW50U3RyZWFtUGFyc2VyKCk7XG5cbiAgdHJ5IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSBicmVhaztcblxuICAgICAgY29uc3QgY2h1bmsgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICBjb25zdCBtZXNzYWdlID0gcGFyc2VyLnByb2Nlc3NDaHVuayhjaHVuayk7XG5cbiAgICAgIGlmIChvblByb2dyZXNzICYmIG1lc3NhZ2UpIHtcbiAgICAgICAgb25Qcm9ncmVzcyhtZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcnNlci5pc01lc3NhZ2VDb21wbGV0ZSgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXJzZXIuZ2V0TWVzc2FnZSgpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICB9XG59XG5cbi8qKlxuICogTWFrZXMgYSBjb21wbGV0aW9uIHJlcXVlc3QgdG8gQ2xhdWRlJ3MgQVBJXG4gKiBAcGFyYW0gcGFyYW1zIFJlcXVlc3QgcGFyYW1ldGVyc1xuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gY29tcGxldGlvbiByZXNwb25zZVxuICogQHRocm93cyBFcnJvciBpZiB0aGUgcmVxdWVzdCBmYWlsc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVxdWVzdENvbXBsZXRpb24oXG4gIHBhcmFtczogQ29tcGxldGlvblJlcXVlc3RQYXJhbXNcbik6IFByb21pc2U8Q29tcGxldGlvblJlc3BvbnNlPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3JnSWQgPSBnZXRPcmdhbml6YXRpb25JZCgpO1xuXG4gICAgLy8gR2V0IGNvbnZlcnNhdGlvbiBkZXRhaWxzIHVzaW5nIGFwcHJvcHJpYXRlIHV0aWxpdHkgZnVuY3Rpb25cbiAgICBjb25zdCB7XG4gICAgICB1dWlkOiBjb252ZXJzYXRpb25JZCxcbiAgICAgIGN1cnJlbnRfbGVhZl9tZXNzYWdlX3V1aWQ6IHBhcmVudE1lc3NhZ2VVdWlkLFxuICAgIH0gPSBwYXJhbXMuY29udmVyc2F0aW9uSWRcbiAgICAgID8gYXdhaXQgZ2V0Q29udmVyc2F0aW9uRGV0YWlscyhwYXJhbXMuY29udmVyc2F0aW9uSWQpXG4gICAgICA6IGF3YWl0IGdldEN1cnJlbnRDb252ZXJzYXRpb25EZXRhaWxzKCk7XG5cbiAgICBjb25zdCBlbmRwb2ludCA9IGAke1NUUkVBTUlOR19BUElfVVJMfS8ke29yZ0lkfS9jaGF0X2NvbnZlcnNhdGlvbnMvJHtjb252ZXJzYXRpb25JZH0vY29tcGxldGlvbmA7XG5cbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHtcbiAgICAgIHByb21wdDogcGFyYW1zLnByb21wdCxcbiAgICAgIHBhcmVudF9tZXNzYWdlX3V1aWQ6IHBhcmVudE1lc3NhZ2VVdWlkLFxuICAgICAgdGltZXpvbmU6IHBhcmFtcy50aW1lem9uZSB8fCBERUZBVUxUX1RJTUVaT05FLFxuICAgICAgYXR0YWNobWVudHM6IHBhcmFtcy5hdHRhY2htZW50cyB8fCBbXSxcbiAgICAgIGZpbGVzOiBwYXJhbXMuZmlsZXMgfHwgW10sXG4gICAgICBzeW5jX3NvdXJjZXM6IHBhcmFtcy5zeW5jU291cmNlcyB8fCBbXSxcbiAgICAgIHJlbmRlcmluZ19tb2RlOiBwYXJhbXMucmVuZGVyaW5nTW9kZSB8fCBcIm1lc3NhZ2VzXCIsXG4gICAgfTtcblxuICAgIGlmICghcGFyYW1zLnN0cmVhbSkge1xuICAgICAgLy8gTm9uLXN0cmVhbWluZyByZXF1ZXN0XG4gICAgICByZXR1cm4gYXdhaXQgbWFrZU5vblN0cmVhbWluZ1JlcXVlc3Qob3JnSWQsIGVuZHBvaW50LCByZXF1ZXN0Qm9keSk7XG4gICAgfVxuXG4gICAgLy8gU3RyZWFtaW5nIHJlcXVlc3RcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGVuZHBvaW50LCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAuLi5nZXRIZWFkZXJzKCksXG4gICAgICAgIEFjY2VwdDogXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiLFxuICAgICAgfSxcbiAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3RCb2R5KSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgc3RyZWFtaW5nIHJlc3BvbnNlIHdpdGggcGFyc2VyXG4gICAgY29uc3QgZnVsbENvbXBsZXRpb24gPSBhd2FpdCBoYW5kbGVTdHJlYW1pbmdSZXNwb25zZShcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgcGFyYW1zLm9uUHJvZ3Jlc3NcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBsZXRpb246IGZ1bGxDb21wbGV0aW9uLFxuICAgICAgc3RvcF9yZWFzb246IFwiXCIsIC8vIEVtcHR5IHN0cmluZyBpbnN0ZWFkIG9mIG51bGxcbiAgICAgIG1vZGVsOiBcIlwiLFxuICAgICAgc3RvcDogbnVsbCxcbiAgICAgIGxvZ19pZDogXCJcIixcbiAgICAgIG1lc3NhZ2VMaW1pdDoge1xuICAgICAgICB0eXBlOiBcIm5vbmVcIixcbiAgICAgICAgcmVtYWluaW5nOiAwLFxuICAgICAgfSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDb21wbGV0aW9uIHJlcXVlc3QgZmFpbGVkOiAke1xuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiXG4gICAgICB9YFxuICAgICk7XG4gIH1cbn1cbiIsIi8vIHNwbGl0VGV4dFdpdGhRdW90ZXMudHNcbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgbWFydGluLmJlY2hhcmRARGV2Q29uc3VsdC5jYVxuICogVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBGaWxlIHBhdGg6IHNyYy91dGlscy9zcGxpdFRleHQudHNcbiAqIEdlbmVyYXRlZCBieSBDbGF1ZGUgU29ubmV0IDMuNSwgd2l0aCB0aGUgYXNzaXN0YW5jZSBvZiBteSBodW1hbiBtZW50b3JcbiAqXG4gKiBTcGxpdHMgdGV4dCBpbnRvIHRva2VucywgaGFuZGxpbmcgcXVvdGVkIHN0cmluZ3MgYW5kIGVzY2FwZSBzZXF1ZW5jZXMgaW4gdW5xdW90ZWQgdGV4dC5cbiAqL1xuXG4vKipcbiAqIFRleHQgc3BsaXR0aW5nIHJ1bGVzOlxuICpcbiAqIEZvciBwcm9jZXNzUXVvdGVkVGV4dCh0ZXh0LCBzdGFydEluZGV4LCBxdW90ZUNoYXIpOlxuICogMS4gU3RhcnRzIEFGVEVSIHRoZSBvcGVuaW5nIHF1b3RlIChzdGFydEluZGV4IGlzIHBvc2l0aW9uIGFmdGVyIHF1b3RlKVxuICogMi4gQ29sbGVjdHMgQUxMIGNoYXJhY3RlcnMgbGl0ZXJhbGx5LCB3aXRoIE5PIHNwZWNpYWwgcHJvY2Vzc2luZyAtIHRoaXMgbWVhbnMgYW55IHF1b3RlQ2hhciBpcyBhbiB1bmVzY2FwZWQgcXVvdGVDaGFyXG4gKiAzLiBTdG9wcyBhdCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBxdW90ZUNoYXJcbiAqIDQuIFJldHVybnM6XG4gKiAgICAqIHJlc3VsdDogYWxsIGNoYXJhY3RlcnMgY29sbGVjdGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgcXVvdGVDaGFyXG4gKiAgICAqIHBvc2l0aW9uOiBpbmRleCBhZnRlciB0aGUgcXVvdGVDaGFyXG4gKlxuICogRm9yIHByb2Nlc3NVbnF1b3RlZFRleHQodGV4dCwgc3RhcnRJbmRleCk6XG4gKiAxLiBXaGVuIHNlZXMgYmFja3NsYXNoOlxuICogICAgKiBTa2lwcyB0aGUgYmFja3NsYXNoXG4gKiAgICAqIFRha2VzIG5leHQgY2hhcmFjdGVyIGxpdGVyYWxseSB1bmxlc3MgaXQncyBhIHdoaXRlc3BhY2Ugc2luY2UgdGhhdCdzIGEgZGVsaW1pdG9yXG4gKiAyLiBXaGVuIHNlZXMgdW5lc2NhcGVkIHF1b3RlOlxuICogICAgKiBJZiBoYXMgY29sbGVjdGVkIGNoYXJzOiByZXR1cm5zIFtjb2xsZWN0ZWQsIHF1b3RlUG9zLCBudWxsXVxuICogICAgKiBJZiBubyBjb2xsZWN0ZWQgY2hhcnM6IHJldHVybnMgW1wiXCIsIHF1b3RlUG9zLCBxdW90ZUNoYXJdXG4gKiAzLiBXaGVuIHNlZXMgdW5lc2NhcGVkIHdoaXRlc3BhY2U6XG4gKiAgICAqIFJldHVybnMgW2NvbGxlY3RlZCwgd2hpdGVzcGFjZVBvcywgbnVsbF1cbiAqIDQuIFJldHVybnM6XG4gKiAgICAqIHJlc3VsdDogY29sbGVjdGVkIGNoYXJhY3RlcnMgd2l0aCBlc2NhcGUgcHJvY2Vzc2luZ1xuICogICAgKiBwb3NpdGlvbjogd2hlcmUgaXQgc3RvcHBlZFxuICogICAgKiBxdW90ZUNoYXI6IHF1b3RlIGNoYXJhY3RlciBmb3VuZCAoaWYgYW55KSBvciBudWxsXG4gKlxuICogRm9yIHNwbGl0VGV4dFdpdGhRdW90ZXModGV4dCk6XG4gKiAxLiBTa2lwcyBsZWFkaW5nIHdoaXRlc3BhY2VcbiAqIDIuIElmIHNlZXMgcXVvdGU6XG4gKiAgICAqIENhbGxzIHByb2Nlc3NRdW90ZWRUZXh0XG4gKiAgICAqIFNraXBzIHRyYWlsaW5nIHdoaXRlc3BhY2UgYWZ0ZXIgcXVvdGVcbiAqIDMuIElmIHNlZXMgbm9uLXF1b3RlOlxuICogICAgKiBDYWxscyBwcm9jZXNzVW5xdW90ZWRUZXh0XG4gKiAgICAqIElmIGl0IHJldHVybmVkIGEgcXVvdGUgY2hhciwgY29udGludWVzIGF0IHNhbWUgcG9zaXRpb25cbiAqICAgICogSWYgbm8gcXVvdGUgY2hhciwgc2tpcHMgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICogNC4gUmVwZWF0cyB1bnRpbCBlbmQgb2YgdGV4dFxuICogNS4gT25seSBhZGRzIG5vbi1lbXB0eSB0b2tlbnMgdG8gcmVzdWx0IGFycmF5XG4gKiA2LiBTcGFjZXMgY2Fubm90IGJlIGVzY2FwZWRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1F1b3RlZFRleHQoXG4gIHRleHQ6IHN0cmluZyxcbiAgc3RhcnRJbmRleDogbnVtYmVyLFxuICBxdW90ZUNoYXI6IHN0cmluZ1xuKTogW3N0cmluZywgbnVtYmVyXSB7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgaSA9IHN0YXJ0SW5kZXg7XG5cbiAgd2hpbGUgKGkgPCB0ZXh0Lmxlbmd0aCkge1xuICAgIGNvbnN0IGNoYXIgPSB0ZXh0W2ldO1xuICAgIGlmIChjaGFyID09PSBxdW90ZUNoYXIpIHtcbiAgICAgIHJldHVybiBbcmVzdWx0LCBpICsgMV07IC8vIFNraXAgcGFzdCBjbG9zaW5nIHF1b3RlXG4gICAgfVxuICAgIHJlc3VsdCArPSBjaGFyO1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiBbcmVzdWx0LCBpXTsgLy8gTm8gY2xvc2luZyBxdW90ZSBmb3VuZCwgcmV0dXJuIGFsbCByZW1haW5pbmcgdGV4dFxufVxuXG4vKipcbiAqIFByb2Nlc3NlcyB1bnF1b3RlZCB0ZXh0LCBzcGxpdHRpbmcgYXQgd2hpdGVzcGFjZSBhbmQgaGFuZGxpbmcgZXNjYXBlIHNlcXVlbmNlcy5cbiAqIFdhdGNoZXMgZm9yIHF1b3RlcyB0byBlbmFibGUgbW9kZSBzd2l0Y2hpbmcuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NVbnF1b3RlZFRleHQoXG4gIHRleHQ6IHN0cmluZyxcbiAgc3RhcnRJbmRleDogbnVtYmVyXG4pOiBbc3RyaW5nLCBudW1iZXIsIHN0cmluZyB8IG51bGxdIHtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGxldCBpID0gc3RhcnRJbmRleDtcbiAgbGV0IGVzY2FwZWQgPSBmYWxzZTtcblxuICB3aGlsZSAoaSA8IHRleHQubGVuZ3RoKSB7XG4gICAgY29uc3QgY2hhciA9IHRleHRbaV07XG5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgaWYgKC9cXHMvLnRlc3QoY2hhcikpIHtcbiAgICAgICAgLy8gU3RvcCBhdCBlc2NhcGVkIHdoaXRlc3BhY2UgLSBpdCdzIGEgZGVsaW1pdGVyXG4gICAgICAgIHJldHVybiBbcmVzdWx0LCBpLCBudWxsXTtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBub24td2hpdGVzcGFjZSwgYWRkIGxpdGVyYWxseVxuICAgICAgcmVzdWx0ICs9IGNoYXI7XG4gICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICBpKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgaSsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKC9cXHMvLnRlc3QoY2hhcikgJiYgIWVzY2FwZWQpIHtcbiAgICAgIC8vIEFueSB1bmVzY2FwZWQgd2hpdGVzcGFjZSBpcyBhIGRlbGltaXRlclxuICAgICAgcmV0dXJuIFtyZXN1bHQsIGksIG51bGxdO1xuICAgIH1cblxuICAgIGlmICgoY2hhciA9PT0gJ1wiJyB8fCBjaGFyID09PSBcIidcIikgJiYgIWVzY2FwZWQpIHtcbiAgICAgIC8vIEhhbmRsZSBib3RoIHF1b3RlIHR5cGVzIHRoZSBzYW1lIHdheVxuICAgICAgaWYgKHJlc3VsdCA9PT0gXCJcIikge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IGNvbGxlY3RlZCBhbnkgY2hhcnMsIHJldHVybiB0aGUgcXVvdGUgY2hhciBmb3VuZFxuICAgICAgICByZXR1cm4gW1wiXCIsIGksIGNoYXJdO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgaGF2ZSBjb2xsZWN0ZWQgY2hhcnMsIHJldHVybiB0aGVtIGFuZCBsZXQgY2FsbGVyIGhhbmRsZSB0aGUgcXVvdGVcbiAgICAgIHJldHVybiBbcmVzdWx0LCBpLCBudWxsXTtcbiAgICB9XG5cbiAgICByZXN1bHQgKz0gY2hhcjtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gW3Jlc3VsdCwgaSwgbnVsbF07XG59XG5cbi8qKlxuICogU3BsaXRzIGEgZ2l2ZW4gdGV4dCBpbnRvIHRva2VucyBiYXNlZCBvbiB3aGl0ZXNwYWNlIGFuZCBxdW90ZXMuXG4gKiBQcm9jZXNzZXMgZXNjYXBlIHNlcXVlbmNlcyBvbmx5IGluIHVucXVvdGVkIHRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFRleHRXaXRoUXVvdGVzKHRleHQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgY29uc3QgcmVzdWx0OiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIHRleHQgPSB0ZXh0LnRyaW0oKTtcblxuICB3aGlsZSAoaSA8IHRleHQubGVuZ3RoKSB7XG4gICAgaWYgKHRleHRbaV0gPT09ICdcIicgfHwgdGV4dFtpXSA9PT0gXCInXCIpIHtcbiAgICAgIGNvbnN0IFt0b2tlbiwgbmV3SW5kZXhdID0gcHJvY2Vzc1F1b3RlZFRleHQodGV4dCwgaSArIDEsIHRleHRbaV0pO1xuICAgICAgaWYgKHRva2VuICE9PSBcIlwiKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTsgLy8gTm8gdHJpbSAtIHF1b3RlZCB0ZXh0IGlzIGxpdGVyYWxcbiAgICAgIH1cbiAgICAgIGkgPSBuZXdJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW3Rva2VuLCBuZXdJbmRleCwgcXVvdGVDaGFyXSA9IHByb2Nlc3NVbnF1b3RlZFRleHQodGV4dCwgaSk7XG4gICAgICBpZiAodG9rZW4gIT09IFwiXCIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pOyAvLyBObyB0cmltIC0gcHJvY2Vzc1VucXVvdGVkVGV4dCBoYW5kbGVzIGl0XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4gPT09IFwiXCIgJiYgbmV3SW5kZXggPT09IGkpIHtcbiAgICAgICAgaSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSA9IG5ld0luZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgTWFydGluIEJlY2hhcmQgPG1hcnRpbi5iZWNoYXJkQERldkNvbnN1bHQuY2E+XG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIEZpbGU6IHNyYy9jb250ZW50LnRzXG4gKiBUaGlzIHdhcyBnZW5lcmF0ZWQgYnkgQ2xhdWRlIFNvbm5ldCAzLjUsIHdpdGggdGhlIGFzc2lzdGFuY2Ugb2YgbXkgaHVtYW4gbWVudG9yXG4gKi9cblxuaW1wb3J0IHsgQ2xhdWRlRXh0ZW5zaW9uIH0gZnJvbSBcIi4vQ2xhdWRlRXh0ZW5zaW9uXCI7XG5cbmNvbnNvbGUubG9nKFwiQ2xhdWRlIEV4dGVuc2lvbiBsb2FkaW5nLi4uXCIpO1xuXG4vLyBQcmV2ZW50IG11bHRpcGxlIGluaXRpYWxpemF0aW9uc1xuaWYgKCh3aW5kb3cgYXMgYW55KS5jbGF1ZGVFeHRJbml0aWFsaXplZCkge1xuICBjb25zb2xlLmxvZyhcIkNsYXVkZSBFeHRlbnNpb24gYWxyZWFkeSBpbml0aWFsaXplZCwgc2tpcHBpbmcuLi5cIik7XG59IGVsc2Uge1xuICBjb25zb2xlLmxvZyhcIkNsYXVkZSBFeHRlbnNpb24gaW5pdGlhbGl6aW5nLi4uXCIpO1xuXG4gIC8vIFNpbXBsZSBlbGVtZW50IHdhaXRlciAtIGtlZXBpbmcgd2hhdCB3b3Jrc1xuICBmdW5jdGlvbiB3YWl0Rm9yRWxlbWVudChzZWxlY3Rvcjogc3RyaW5nKTogUHJvbWlzZTxFbGVtZW50PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBUaW1lb3V0IHdhaXRpbmcgZm9yIGVsZW1lbnQ6ICR7c2VsZWN0b3J9YCkpO1xuICAgICAgfSwgMzAwMDApO1xuXG4gICAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFbGVtZW50IGZvdW5kIGltbWVkaWF0ZWx5OlwiLCBzZWxlY3Rvcik7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikhKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXCJXYWl0aW5nIGZvciBlbGVtZW50OlwiLCBzZWxlY3Rvcik7XG4gICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJFbGVtZW50IGZvdW5kIGFmdGVyIG11dGF0aW9uOlwiLCBzZWxlY3Rvcik7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICByZXNvbHZlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpISk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmJvZHksIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIHdpdGggc2FtZSBwYXR0ZXJuIGFzIHdvcmtpbmcgdmVyc2lvblxuICBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIGluaXRpYWxpemF0aW9uLi4uXCIpO1xuXG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbiBjbGF1ZGUuYWlcbiAgICAgIGlmICghd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lLmluY2x1ZGVzKFwiY2xhdWRlLmFpXCIpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiTm90IG9uIGNsYXVkZS5haSwgc2tpcHBpbmcgaW5pdGlhbGl6YXRpb25cIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coXCJXYWl0aW5nIGZvciBDbGF1ZGUgY2hhdCBpbnRlcmZhY2UuLi5cIik7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGVsZW1lbnRzIEJFRk9SRSBjcmVhdGluZyBhbnkgVUlcbiAgICAgIGF3YWl0IHdhaXRGb3JFbGVtZW50KCdkaXZbZW50ZXJrZXloaW50PVwiZW50ZXJcIl0nKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiQ2hhdCBjb250YWluZXIgZm91bmRcIik7XG5cbiAgICAgIC8vIE9ubHkgbm93IGNyZWF0ZSB0aGUgVUlcbiAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBDbGF1ZGVFeHRlbnNpb24oKTtcbiAgICAgIGF3YWl0IGV4dGVuc2lvbi5pbml0aWFsaXplVUkoKTtcblxuICAgICAgLy8gT25seSBOT1cgbWFyayBhcyBpbml0aWFsaXplZCAtIGFmdGVyIGV2ZXJ5dGhpbmcgaXMgY29tcGxldGVcbiAgICAgICh3aW5kb3cgYXMgYW55KS5jbGF1ZGVFeHRJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmxvZyhcIkluaXRpYWxpemF0aW9uIGNvbXBsZXRlXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW5pdGlhbGl6YXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICAvLyBTaG93IGVycm9yIHRvIHVzZXJcbiAgICAgIGNvbnN0IGVycm9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGVycm9yRGl2LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgICAgIHRvcDogMjBweDtcbiAgICAgICAgICAgICAgICByaWdodDogMjBweDtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZmZlYmVlO1xuICAgICAgICAgICAgICAgIGNvbG9yOiAjYzYyODI4O1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDE1cHg7XG4gICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICAgICAgICAgIHotaW5kZXg6IDk5OTk5OTtcbiAgICAgICAgICAgICAgICBmb250LWZhbWlseTogQXJpYWwsIHNhbnMtc2VyaWY7XG4gICAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggNnB4IHJnYmEoMCwwLDAsMC4yKTtcbiAgICAgICAgICAgIGA7XG4gICAgICBlcnJvckRpdi50ZXh0Q29udGVudCA9IGBDbGF1ZGUgRXh0ZW5zaW9uIEVycm9yOiAke1xuICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiXG4gICAgICB9YDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZXJyb3JEaXYpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBlcnJvckRpdi5yZW1vdmUoKSwgNTAwMCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlIHByb3BlciBhc3luYy9hd2FpdCBmb3IgaW5pdGlhbGl6YXRpb24gdGltaW5nXG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgIGNvbnNvbGUubG9nKFwiRG9jdW1lbnQgbG9hZGluZywgYWRkaW5nIERPTUNvbnRlbnRMb2FkZWQgbGlzdGVuZXIuLi5cIik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gV2FpdCBmb3IgaW5pdGlhbGl6YXRpb24gdG8gY29tcGxldGUgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgIGF3YWl0IGluaXRpYWxpemUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhcIkRvY3VtZW50IGFscmVhZHkgbG9hZGVkLCBpbml0aWFsaXppbmcuLi5cIik7XG4gICAgLy8gV2FpdCBmb3IgaW5pdGlhbGl6YXRpb24gdG8gY29tcGxldGUgYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgaW5pdGlhbGl6ZSgpO1xuICAgIH0pKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==
```

## dist/ConversationAnalyzer.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/ConversationAnalyzer.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
// Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
// This software is licensed under the MIT License.
// Path: src/ConversationAnalyzer.ts
// This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
// Analyzes conversation data to extract metrics about message lengths and totals
// "I analyze conversations so thoroughly, I can tell you how many characters it takes to say 'hello' in every language!"
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationAnalyzer = void 0;
/**
 * Analyzes conversation data to extract various metrics about message lengths
 */
var ConversationAnalyzer = /** @class */ (function () {
    /**
     * Creates a new ConversationAnalyzer instance
     * @param data Array of conversations to analyze
     */
    function ConversationAnalyzer(data) {
        this.conversations = data;
    }
    /**
     * Analyzes all conversations and returns comprehensive metrics
     * @returns Analysis results including per-conversation metrics and total size
     */
    ConversationAnalyzer.prototype.analyze = function () {
        var _this = this;
        var metrics = this.conversations.map(function (conv) {
            return _this.analyzeConversation(conv);
        });
        var totalSize = metrics.reduce(function (sum, conv) { return sum + conv.totalSize; }, 0);
        return {
            conversationMetrics: metrics,
            totalSize: totalSize,
        };
    };
    /**
     * Analyzes a single conversation to extract its metrics
     * @param conversation The conversation to analyze
     * @returns Metrics for the specific conversation
     */
    ConversationAnalyzer.prototype.analyzeConversation = function (conversation) {
        var messageLengths = conversation.messages.map(function (msg) {
            var content = msg.content;
            // Get byte length using TextEncoder
            var byteLength = new TextEncoder().encode(content).length;
            return {
                length: content.length,
                byteLength: byteLength,
                messageId: msg.id,
            };
        });
        var longestMessage = messageLengths.reduce(function (max, current) { return (current.byteLength > max.byteLength ? current : max); }, messageLengths[0]);
        var totalSize = messageLengths.reduce(function (sum, msg) { return sum + msg.byteLength; }, 0);
        return {
            conversationId: conversation.id,
            conversationName: conversation.name,
            messageLengths: messageLengths,
            longestMessage: longestMessage,
            totalSize: totalSize,
            conversations: [conversation], // Add conversation for message lookup
        };
    };
    /**
     * Finds a message by ID across all conversations
     * @param messageId The ID of the message to find
     * @returns The message details with conversation context or null if not found
     */
    ConversationAnalyzer.prototype.findMessageById = function (messageId) {
        for (var _i = 0, _a = this.conversations; _i < _a.length; _i++) {
            var conversation = _a[_i];
            var message = conversation.messages.find(function (msg) { return msg.id === messageId; });
            if (message) {
                return {
                    message: message,
                    conversation: {
                        id: conversation.id,
                        name: conversation.name,
                    },
                };
            }
        }
        return null;
    };
    return ConversationAnalyzer;
}());
exports.ConversationAnalyzer = ConversationAnalyzer;

```

## dist/jest.config.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/jest.config.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** @type {import('jest').Config} */
const config = {
    preset: "ts-jest",
    testEnvironment: "node",
    moduleNameMapper: {
        "^@/(.*)$": "<rootDir>/src/$1",
    },
    testMatch: ["**/tests/**/*.test.ts"],
};
exports.default = config;
//# sourceMappingURL=jest.config.js.map
```

## dist/lib/prism-javascript.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/lib/prism-javascript.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

Prism.languages.javascript=Prism.languages.extend("clike",{"class-name":[Prism.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,lookbehind:!0}],keyword:[{pattern:/((?:^|\})\s*)catch\b/,lookbehind:!0},{pattern:/(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],function:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,number:{pattern:RegExp("(^|[^\\w$])(?:NaN|Infinity|0[bB][01]+(?:_[01]+)*n?|0[oO][0-7]+(?:_[0-7]+)*n?|0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?|\\d+(?:_\\d+)*n|(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?)(?![\\w$])"),lookbehind:!0},operator:/--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/}),Prism.languages.javascript["class-name"][0].pattern=/(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/,Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:RegExp("((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/(?:(?:\\[(?:[^\\]\\\\\r\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\r\n])+/[dgimyus]{0,7}|(?:\\[(?:[^[\\]\\\\\r\n]|\\\\.|\\[(?:[^[\\]\\\\\r\n]|\\\\.|\\[(?:[^[\\]\\\\\r\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\r\n])+/[dgimyus]{0,7}v[dgimyus]{0,7})(?=(?:\\s|/\\*(?:[^*]|\\*(?!/))*\\*/)*(?:$|[\r\n,.;:})\\]]|//))"),lookbehind:!0,greedy:!0,inside:{"regex-source":{pattern:/^(\/)[\s\S]+(?=\/[a-z]*$)/,lookbehind:!0,alias:"language-regex",inside:Prism.languages.regex},"regex-delimiter":/^\/|\/$/,"regex-flags":/^[a-z]+$/}},"function-variable":{pattern:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,alias:"function"},parameter:[{pattern:/(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,lookbehind:!0,inside:Prism.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/}),Prism.languages.insertBefore("javascript","string",{hashbang:{pattern:/^#!.*/,greedy:!0,alias:"comment"},"template-string":{pattern:/`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,greedy:!0,inside:{"template-punctuation":{pattern:/^`|`$/,alias:"string"},interpolation:{pattern:/((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,lookbehind:!0,inside:{"interpolation-punctuation":{pattern:/^\$\{|\}$/,alias:"punctuation"},rest:Prism.languages.javascript}},string:/[\s\S]+/}},"string-property":{pattern:/((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,lookbehind:!0,greedy:!0,alias:"property"}}),Prism.languages.insertBefore("javascript","operator",{"literal-property":{pattern:/((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,lookbehind:!0,alias:"property"}}),Prism.languages.markup&&(Prism.languages.markup.tag.addInlined("script","javascript"),Prism.languages.markup.tag.addAttribute("on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)","javascript")),Prism.languages.js=Prism.languages.javascript;
```

## dist/lib/prism-json.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/lib/prism-json.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

Prism.languages.json={property:{pattern:/(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,lookbehind:!0,greedy:!0},string:{pattern:/(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,lookbehind:!0,greedy:!0},comment:{pattern:/\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,greedy:!0},number:/-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,punctuation:/[{}[\],]/,operator:/:/,boolean:/\b(?:false|true)\b/,null:{pattern:/\bnull\b/,alias:"keyword"}},Prism.languages.webmanifest=Prism.languages.json;
```

## dist/lib/prism-markdown.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/lib/prism-markdown.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

!function(n){function e(n){return n=n.replace(/<inner>/g,(function(){return"(?:\\\\.|[^\\\\\n\r]|(?:\n|\r\n?)(?![\r\n]))"})),RegExp("((?:^|[^\\\\])(?:\\\\{2})*)(?:"+n+")")}var t="(?:\\\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\\\|\r\n`])+",a="\\|?__(?:\\|__)+\\|?(?:(?:\n|\r\n?)|(?![^]))".replace(/__/g,(function(){return t})),i="\\|?[ \t]*:?-{3,}:?[ \t]*(?:\\|[ \t]*:?-{3,}:?[ \t]*)+\\|?(?:\n|\r\n?)";n.languages.markdown=n.languages.extend("markup",{}),n.languages.insertBefore("markdown","prolog",{"front-matter-block":{pattern:/(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,lookbehind:!0,greedy:!0,inside:{punctuation:/^---|---$/,"front-matter":{pattern:/\S+(?:\s+\S+)*/,alias:["yaml","language-yaml"],inside:n.languages.yaml}}},blockquote:{pattern:/^>(?:[\t ]*>)*/m,alias:"punctuation"},table:{pattern:RegExp("^"+a+i+"(?:"+a+")*","m"),inside:{"table-data-rows":{pattern:RegExp("^("+a+i+")(?:"+a+")*$"),lookbehind:!0,inside:{"table-data":{pattern:RegExp(t),inside:n.languages.markdown},punctuation:/\|/}},"table-line":{pattern:RegExp("^("+a+")"+i+"$"),lookbehind:!0,inside:{punctuation:/\||:?-{3,}:?/}},"table-header-row":{pattern:RegExp("^"+a+"$"),inside:{"table-header":{pattern:RegExp(t),alias:"important",inside:n.languages.markdown},punctuation:/\|/}}}},code:[{pattern:/((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,lookbehind:!0,alias:"keyword"},{pattern:/^```[\s\S]*?^```$/m,greedy:!0,inside:{"code-block":{pattern:/^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,lookbehind:!0},"code-language":{pattern:/^(```).+/,lookbehind:!0},punctuation:/```/}}],title:[{pattern:/\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,alias:"important",inside:{punctuation:/==+$|--+$/}},{pattern:/(^\s*)#.+/m,lookbehind:!0,alias:"important",inside:{punctuation:/^#+|#+$/}}],hr:{pattern:/(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,lookbehind:!0,alias:"punctuation"},list:{pattern:/(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,lookbehind:!0,alias:"punctuation"},"url-reference":{pattern:/!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,inside:{variable:{pattern:/^(!?\[)[^\]]+/,lookbehind:!0},string:/(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,punctuation:/^[\[\]!:]|[<>]/},alias:"url"},bold:{pattern:e("\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*"),lookbehind:!0,greedy:!0,inside:{content:{pattern:/(^..)[\s\S]+(?=..$)/,lookbehind:!0,inside:{}},punctuation:/\*\*|__/}},italic:{pattern:e("\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*"),lookbehind:!0,greedy:!0,inside:{content:{pattern:/(^.)[\s\S]+(?=.$)/,lookbehind:!0,inside:{}},punctuation:/[*_]/}},strike:{pattern:e("(~~?)(?:(?!~)<inner>)+\\2"),lookbehind:!0,greedy:!0,inside:{content:{pattern:/(^~~?)[\s\S]+(?=\1$)/,lookbehind:!0,inside:{}},punctuation:/~~?/}},"code-snippet":{pattern:/(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,lookbehind:!0,greedy:!0,alias:["code","keyword"]},url:{pattern:e('!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\t ]+"(?:\\\\.|[^"\\\\])*")?\\)|[ \t]?\\[(?:(?!\\])<inner>)+\\])'),lookbehind:!0,greedy:!0,inside:{operator:/^!/,content:{pattern:/(^\[)[^\]]+(?=\])/,lookbehind:!0,inside:{}},variable:{pattern:/(^\][ \t]?\[)[^\]]+(?=\]$)/,lookbehind:!0},url:{pattern:/(^\]\()[^\s)]+/,lookbehind:!0},string:{pattern:/(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,lookbehind:!0}}}}),["url","bold","italic","strike"].forEach((function(e){["url","bold","italic","strike","code-snippet"].forEach((function(t){e!==t&&(n.languages.markdown[e].inside.content.inside[t]=n.languages.markdown[t])}))})),n.hooks.add("after-tokenize",(function(n){"markdown"!==n.language&&"md"!==n.language||function n(e){if(e&&"string"!=typeof e)for(var t=0,a=e.length;t<a;t++){var i=e[t];if("code"===i.type){var r=i.content[1],o=i.content[3];if(r&&o&&"code-language"===r.type&&"code-block"===o.type&&"string"==typeof r.content){var l=r.content.replace(/\b#/g,"sharp").replace(/\b\+\+/g,"pp"),s="language-"+(l=(/[a-z][\w-]*/i.exec(l)||[""])[0].toLowerCase());o.alias?"string"==typeof o.alias?o.alias=[o.alias,s]:o.alias.push(s):o.alias=[s]}}else n(i.content)}}(n.tokens)})),n.hooks.add("wrap",(function(e){if("code-block"===e.type){for(var t="",a=0,i=e.classes.length;a<i;a++){var s=e.classes[a],d=/language-(.+)/.exec(s);if(d){t=d[1];break}}var p=n.languages[t];if(p)e.content=n.highlight(e.content.replace(r,"").replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi,(function(n,e){var t;return"#"===(e=e.toLowerCase())[0]?(t="x"===e[1]?parseInt(e.slice(2),16):Number(e.slice(1)),l(t)):o[e]||n})),p,t);else if(t&&"none"!==t&&n.plugins.autoloader){var u="md-"+(new Date).valueOf()+"-"+Math.floor(1e16*Math.random());e.attributes.id=u,n.plugins.autoloader.loadLanguages(t,(function(){var e=document.getElementById(u);e&&(e.innerHTML=n.highlight(e.textContent,n.languages[t],t))}))}}}));var r=RegExp(n.languages.markup.tag.pattern.source,"gi"),o={amp:"&",lt:"<",gt:">",quot:'"'},l=String.fromCodePoint||String.fromCharCode;n.languages.md=n.languages.markdown}(Prism);
```

## dist/lib/prism-python.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/lib/prism-python.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

Prism.languages.python={comment:{pattern:/(^|[^\\])#.*/,lookbehind:!0,greedy:!0},"string-interpolation":{pattern:/(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,greedy:!0,inside:{interpolation:{pattern:/((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,lookbehind:!0,inside:{"format-spec":{pattern:/(:)[^:(){}]+(?=\}$)/,lookbehind:!0},"conversion-option":{pattern:/![sra](?=[:}]$)/,alias:"punctuation"},rest:null}},string:/[\s\S]+/}},"triple-quoted-string":{pattern:/(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,greedy:!0,alias:"string"},string:{pattern:/(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,greedy:!0},function:{pattern:/((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,lookbehind:!0},"class-name":{pattern:/(\bclass\s+)\w+/i,lookbehind:!0},decorator:{pattern:/(^[\t ]*)@\w+(?:\.\w+)*/m,lookbehind:!0,alias:["annotation","punctuation"],inside:{punctuation:/\./}},keyword:/\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,builtin:/\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,boolean:/\b(?:False|None|True)\b/,number:/\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,operator:/[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,punctuation:/[{}[\];(),.:]/},Prism.languages.python["string-interpolation"].inside.interpolation.inside.rest=Prism.languages.python,Prism.languages.py=Prism.languages.python;
```

## dist/lib/prism-typescript.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/lib/prism-typescript.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

!function(e){e.languages.typescript=e.languages.extend("javascript",{"class-name":{pattern:/(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,lookbehind:!0,greedy:!0,inside:null},builtin:/\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/}),e.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/,/\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,/\btype\b(?=\s*(?:[\{*]|$))/),delete e.languages.typescript.parameter,delete e.languages.typescript["literal-property"];var s=e.languages.extend("typescript",{});delete s["class-name"],e.languages.typescript["class-name"].inside=s,e.languages.insertBefore("typescript","function",{decorator:{pattern:/@[$\w\xA0-\uFFFF]+/,inside:{at:{pattern:/^@/,alias:"operator"},function:/^[\s\S]+/}},"generic-function":{pattern:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,greedy:!0,inside:{function:/^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,generic:{pattern:/<[\s\S]+/,alias:"class-name",inside:s}}}}),e.languages.ts=e.languages.typescript}(Prism);
```

## dist/lib/prism.css

```css
/*
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/lib/prism.css
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
*/

code[class*=language-],pre[class*=language-]{color:#000;background:0 0;text-shadow:0 1px #fff;font-family:Consolas,Monaco,'Andale Mono','Ubuntu Mono',monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-] ::-moz-selection,code[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection{text-shadow:none;background:#b3d4fc}code[class*=language-] ::selection,code[class*=language-]::selection,pre[class*=language-] ::selection,pre[class*=language-]::selection{text-shadow:none;background:#b3d4fc}@media print{code[class*=language-],pre[class*=language-]{text-shadow:none}}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*=language-],pre[class*=language-]{background:#f5f2f0}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#999}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#905}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#690}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url{color:#9a6e3a;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.class-name,.token.function{color:#dd4a68}.token.important,.token.regex,.token.variable{color:#e90}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}
```

## dist/lib/prism.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/lib/prism.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(l){var n=/(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i,t=0,e={},j={manual:l.Prism&&l.Prism.manual,disableWorkerMessageHandler:l.Prism&&l.Prism.disableWorkerMessageHandler,util:{encode:function e(t){return t instanceof C?new C(t.type,e(t.content),t.alias):Array.isArray(t)?t.map(e):t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function n(e,a){var r,t;switch(a=a||{},j.util.type(e)){case"Object":if(t=j.util.objId(e),a[t])return a[t];for(var s in r={},a[t]=r,e)e.hasOwnProperty(s)&&(r[s]=n(e[s],a));return r;case"Array":return(t=j.util.objId(e),a[t])?a[t]:(r=[],a[t]=r,e.forEach(function(e,t){r[t]=n(e,a)}),r);default:return e}},getLanguage:function(e){for(;e;){var t=n.exec(e.className);if(t)return t[1].toLowerCase();e=e.parentElement}return"none"},setLanguage:function(e,t){e.className=e.className.replace(RegExp(n,"gi"),""),e.classList.add("language-"+t)},currentScript:function(){if("undefined"==typeof document)return null;if("currentScript"in document)return document.currentScript;try{throw new Error}catch(e){var t=(/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(e.stack)||[])[1];if(t){var n,a=document.getElementsByTagName("script");for(n in a)if(a[n].src==t)return a[n]}return null}},isActive:function(e,t,n){for(var a="no-"+t;e;){var r=e.classList;if(r.contains(t))return!0;if(r.contains(a))return!1;e=e.parentElement}return!!n}},languages:{plain:e,plaintext:e,text:e,txt:e,extend:function(e,t){var n,a=j.util.clone(j.languages[e]);for(n in t)a[n]=t[n];return a},insertBefore:function(n,e,t,a){var r,s=(a=a||j.languages)[n],i={};for(r in s)if(s.hasOwnProperty(r)){if(r==e)for(var o in t)t.hasOwnProperty(o)&&(i[o]=t[o]);t.hasOwnProperty(r)||(i[r]=s[r])}var l=a[n];return a[n]=i,j.languages.DFS(j.languages,function(e,t){t===l&&e!=n&&(this[e]=i)}),i},DFS:function e(t,n,a,r){r=r||{};var s,i,o,l=j.util.objId;for(s in t)t.hasOwnProperty(s)&&(n.call(t,s,t[s],a||s),i=t[s],"Object"!==(o=j.util.type(i))||r[l(i)]?"Array"!==o||r[l(i)]||(r[l(i)]=!0,e(i,n,s,r)):(r[l(i)]=!0,e(i,n,null,r)))}},plugins:{},highlightAll:function(e,t){j.highlightAllUnder(document,e,t)},highlightAllUnder:function(e,t,n){var a={callback:n,container:e,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};j.hooks.run("before-highlightall",a),a.elements=Array.prototype.slice.apply(a.container.querySelectorAll(a.selector)),j.hooks.run("before-all-elements-highlight",a);for(var r,s=0;r=a.elements[s++];)j.highlightElement(r,!0===t,a.callback)},highlightElement:function(e,t,n){var a=j.util.getLanguage(e),r=j.languages[a],s=(j.util.setLanguage(e,a),e.parentElement);s&&"pre"===s.nodeName.toLowerCase()&&j.util.setLanguage(s,a);var i={element:e,language:a,grammar:r,code:e.textContent};function o(e){i.highlightedCode=e,j.hooks.run("before-insert",i),i.element.innerHTML=i.highlightedCode,j.hooks.run("after-highlight",i),j.hooks.run("complete",i),n&&n.call(i.element)}if(j.hooks.run("before-sanity-check",i),(s=i.element.parentElement)&&"pre"===s.nodeName.toLowerCase()&&!s.hasAttribute("tabindex")&&s.setAttribute("tabindex","0"),!i.code)return j.hooks.run("complete",i),void(n&&n.call(i.element));j.hooks.run("before-highlight",i),i.grammar?t&&l.Worker?((a=new Worker(j.filename)).onmessage=function(e){o(e.data)},a.postMessage(JSON.stringify({language:i.language,code:i.code,immediateClose:!0}))):o(j.highlight(i.code,i.grammar,i.language)):o(j.util.encode(i.code))},highlight:function(e,t,n){e={code:e,grammar:t,language:n};if(j.hooks.run("before-tokenize",e),e.grammar)return e.tokens=j.tokenize(e.code,e.grammar),j.hooks.run("after-tokenize",e),C.stringify(j.util.encode(e.tokens),e.language);throw new Error('The language "'+e.language+'" has no grammar.')},tokenize:function(e,t){var n=t.rest;if(n){for(var a in n)t[a]=n[a];delete t.rest}for(var r=new u,s=(z(r,r.head,e),!function e(t,n,a,r,s,i){for(var o in a)if(a.hasOwnProperty(o)&&a[o]){var l=a[o];l=Array.isArray(l)?l:[l];for(var u=0;u<l.length;++u){if(i&&i.cause==o+","+u)return;for(var g,c=l[u],d=c.inside,p=!!c.lookbehind,m=!!c.greedy,h=c.alias,f=(m&&!c.pattern.global&&(g=c.pattern.toString().match(/[imsuy]*$/)[0],c.pattern=RegExp(c.pattern.source,g+"g")),c.pattern||c),b=r.next,y=s;b!==n.tail&&!(i&&y>=i.reach);y+=b.value.length,b=b.next){var v=b.value;if(n.length>t.length)return;if(!(v instanceof C)){var F,x=1;if(m){if(!(F=L(f,y,t,p))||F.index>=t.length)break;var k=F.index,w=F.index+F[0].length,A=y;for(A+=b.value.length;A<=k;)b=b.next,A+=b.value.length;if(A-=b.value.length,y=A,b.value instanceof C)continue;for(var P=b;P!==n.tail&&(A<w||"string"==typeof P.value);P=P.next)x++,A+=P.value.length;x--,v=t.slice(y,A),F.index-=y}else if(!(F=L(f,0,v,p)))continue;var k=F.index,$=F[0],S=v.slice(0,k),E=v.slice(k+$.length),v=y+v.length,_=(i&&v>i.reach&&(i.reach=v),b.prev),S=(S&&(_=z(n,_,S),y+=S.length),O(n,_,x),new C(o,d?j.tokenize($,d):$,h,$));b=z(n,_,S),E&&z(n,b,E),1<x&&($={cause:o+","+u,reach:v},e(t,n,a,b.prev,y,$),i&&$.reach>i.reach&&(i.reach=$.reach))}}}}}(e,r,t,r.head,0),r),i=[],o=s.head.next;o!==s.tail;)i.push(o.value),o=o.next;return i},hooks:{all:{},add:function(e,t){var n=j.hooks.all;n[e]=n[e]||[],n[e].push(t)},run:function(e,t){var n=j.hooks.all[e];if(n&&n.length)for(var a,r=0;a=n[r++];)a(t)}},Token:C};function C(e,t,n,a){this.type=e,this.content=t,this.alias=n,this.length=0|(a||"").length}function L(e,t,n,a){e.lastIndex=t;t=e.exec(n);return t&&a&&t[1]&&(e=t[1].length,t.index+=e,t[0]=t[0].slice(e)),t}function u(){var e={value:null,prev:null,next:null},t={value:null,prev:e,next:null};e.next=t,this.head=e,this.tail=t,this.length=0}function z(e,t,n){var a=t.next,n={value:n,prev:t,next:a};return t.next=n,a.prev=n,e.length++,n}function O(e,t,n){for(var a=t.next,r=0;r<n&&a!==e.tail;r++)a=a.next;(t.next=a).prev=t,e.length-=r}if(l.Prism=j,C.stringify=function t(e,n){if("string"==typeof e)return e;var a;if(Array.isArray(e))return a="",e.forEach(function(e){a+=t(e,n)}),a;var r,s={type:e.type,content:t(e.content,n),tag:"span",classes:["token",e.type],attributes:{},language:n},e=e.alias,i=(e&&(Array.isArray(e)?Array.prototype.push.apply(s.classes,e):s.classes.push(e)),j.hooks.run("wrap",s),"");for(r in s.attributes)i+=" "+r+'="'+(s.attributes[r]||"").replace(/"/g,"&quot;")+'"';return"<"+s.tag+' class="'+s.classes.join(" ")+'"'+i+">"+s.content+"</"+s.tag+">"},!l.document)return l.addEventListener&&(j.disableWorkerMessageHandler||l.addEventListener("message",function(e){var e=JSON.parse(e.data),t=e.language,n=e.code,e=e.immediateClose;l.postMessage(j.highlight(n,j.languages[t],t)),e&&l.close()},!1)),j;var a,e=j.util.currentScript();function r(){j.manual||j.highlightAll()}return e&&(j.filename=e.src,e.hasAttribute("data-manual")&&(j.manual=!0)),j.manual||("loading"===(a=document.readyState)||"interactive"===a&&e&&e.defer?document.addEventListener("DOMContentLoaded",r):window.requestAnimationFrame?window.requestAnimationFrame(r):window.setTimeout(r,16)),j}(_self);"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism),Prism.languages.markup={comment:{pattern:/<!--(?:(?!<!--)[\s\S])*?-->/,greedy:!0},prolog:{pattern:/<\?[\s\S]+?\?>/,greedy:!0},doctype:{pattern:/<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,greedy:!0,inside:{"internal-subset":{pattern:/(^[^\[]*\[)[\s\S]+(?=\]>$)/,lookbehind:!0,greedy:!0,inside:null},string:{pattern:/"[^"]*"|'[^']*'/,greedy:!0},punctuation:/^<!|>$|[[\]]/,"doctype-tag":/^DOCTYPE/i,name:/[^\s<>'"]+/}},cdata:{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,greedy:!0},tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"special-attr":[],"attr-value":{pattern:/=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,inside:{punctuation:[{pattern:/^=/,alias:"attr-equals"},{pattern:/^(\s*)["']|["']$/,lookbehind:!0}]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:[{pattern:/&[\da-z]{1,8};/i,alias:"named-entity"},/&#x?[\da-f]{1,8};/i]},Prism.languages.markup.tag.inside["attr-value"].inside.entity=Prism.languages.markup.entity,Prism.languages.markup.doctype.inside["internal-subset"].inside=Prism.languages.markup,Prism.hooks.add("wrap",function(e){"entity"===e.type&&(e.attributes.title=e.content.replace(/&amp;/,"&"))}),Object.defineProperty(Prism.languages.markup.tag,"addInlined",{value:function(e,t){var n={},n=(n["language-"+t]={pattern:/(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,lookbehind:!0,inside:Prism.languages[t]},n.cdata=/^<!\[CDATA\[|\]\]>$/i,{"included-cdata":{pattern:/<!\[CDATA\[[\s\S]*?\]\]>/i,inside:n}}),t=(n["language-"+t]={pattern:/[\s\S]+/,inside:Prism.languages[t]},{});t[e]={pattern:RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g,function(){return e}),"i"),lookbehind:!0,greedy:!0,inside:n},Prism.languages.insertBefore("markup","cdata",t)}}),Object.defineProperty(Prism.languages.markup.tag,"addAttribute",{value:function(e,t){Prism.languages.markup.tag.inside["special-attr"].push({pattern:RegExp(/(^|["'\s])/.source+"(?:"+e+")"+/\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,"i"),lookbehind:!0,inside:{"attr-name":/^[^\s=]+/,"attr-value":{pattern:/=[\s\S]+/,inside:{value:{pattern:/(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,lookbehind:!0,alias:[t,"language-"+t],inside:Prism.languages[t]},punctuation:[{pattern:/^=/,alias:"attr-equals"},/"|'/]}}}})}}),Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup,Prism.languages.xml=Prism.languages.extend("markup",{}),Prism.languages.ssml=Prism.languages.xml,Prism.languages.atom=Prism.languages.xml,Prism.languages.rss=Prism.languages.xml,function(e){var t=/(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/,t=(e.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:RegExp("@[\\w-](?:"+/[^;{\s"']|\s+(?!\s)/.source+"|"+t.source+")*?"+/(?:;|(?=\s*\{))/.source),inside:{rule:/^@[\w-]+/,"selector-function-argument":{pattern:/(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,lookbehind:!0,alias:"selector"},keyword:{pattern:/(^|[^\w-])(?:and|not|only|or)(?![\w-])/,lookbehind:!0}}},url:{pattern:RegExp("\\burl\\((?:"+t.source+"|"+/(?:[^\\\r\n()"']|\\[\s\S])*/.source+")\\)","i"),greedy:!0,inside:{function:/^url/i,punctuation:/^\(|\)$/,string:{pattern:RegExp("^"+t.source+"$"),alias:"url"}}},selector:{pattern:RegExp("(^|[{}\\s])[^{}\\s](?:[^{};\"'\\s]|\\s+(?![\\s{])|"+t.source+")*(?=\\s*\\{)"),lookbehind:!0},string:{pattern:t,greedy:!0},property:{pattern:/(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,lookbehind:!0},important:/!important\b/i,function:{pattern:/(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,lookbehind:!0},punctuation:/[(){};:,]/},e.languages.css.atrule.inside.rest=e.languages.css,e.languages.markup);t&&(t.tag.addInlined("style","css"),t.tag.addAttribute("style","css"))}(Prism),Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0,greedy:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,boolean:/\b(?:false|true)\b/,function:/\b\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,punctuation:/[{}[\];(),.:]/},Prism.languages.javascript=Prism.languages.extend("clike",{"class-name":[Prism.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,lookbehind:!0}],keyword:[{pattern:/((?:^|\})\s*)catch\b/,lookbehind:!0},{pattern:/(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],function:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,number:{pattern:RegExp(/(^|[^\w$])/.source+"(?:"+/NaN|Infinity/.source+"|"+/0[bB][01]+(?:_[01]+)*n?/.source+"|"+/0[oO][0-7]+(?:_[0-7]+)*n?/.source+"|"+/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source+"|"+/\d+(?:_\d+)*n/.source+"|"+/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source+")"+/(?![\w$])/.source),lookbehind:!0},operator:/--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/}),Prism.languages.javascript["class-name"][0].pattern=/(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/,Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source+/\//.source+"(?:"+/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source+"|"+/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source+")"+/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source),lookbehind:!0,greedy:!0,inside:{"regex-source":{pattern:/^(\/)[\s\S]+(?=\/[a-z]*$)/,lookbehind:!0,alias:"language-regex",inside:Prism.languages.regex},"regex-delimiter":/^\/|\/$/,"regex-flags":/^[a-z]+$/}},"function-variable":{pattern:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,alias:"function"},parameter:[{pattern:/(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,lookbehind:!0,inside:Prism.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/}),Prism.languages.insertBefore("javascript","string",{hashbang:{pattern:/^#!.*/,greedy:!0,alias:"comment"},"template-string":{pattern:/`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,greedy:!0,inside:{"template-punctuation":{pattern:/^`|`$/,alias:"string"},interpolation:{pattern:/((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,lookbehind:!0,inside:{"interpolation-punctuation":{pattern:/^\$\{|\}$/,alias:"punctuation"},rest:Prism.languages.javascript}},string:/[\s\S]+/}},"string-property":{pattern:/((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,lookbehind:!0,greedy:!0,alias:"property"}}),Prism.languages.insertBefore("javascript","operator",{"literal-property":{pattern:/((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,lookbehind:!0,alias:"property"}}),Prism.languages.markup&&(Prism.languages.markup.tag.addInlined("script","javascript"),Prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,"javascript")),Prism.languages.js=Prism.languages.javascript,function(){var l,u,g,c,e;void 0!==Prism&&"undefined"!=typeof document&&(Element.prototype.matches||(Element.prototype.matches=Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector),l={js:"javascript",py:"python",rb:"ruby",ps1:"powershell",psm1:"powershell",sh:"bash",bat:"batch",h:"c",tex:"latex"},c="pre[data-src]:not(["+(u="data-src-status")+'="loaded"]):not(['+u+'="'+(g="loading")+'"])',Prism.hooks.add("before-highlightall",function(e){e.selector+=", "+c}),Prism.hooks.add("before-sanity-check",function(e){var r,t,n,a,s,i,o=e.element;o.matches(c)&&(e.code="",o.setAttribute(u,g),(r=o.appendChild(document.createElement("CODE"))).textContent="Loading",t=o.getAttribute("data-src"),"none"===(e=e.language)&&(n=(/\.(\w+)$/.exec(t)||[,"none"])[1],e=l[n]||n),Prism.util.setLanguage(r,e),Prism.util.setLanguage(o,e),(n=Prism.plugins.autoloader)&&n.loadLanguages(e),n=t,a=function(e){o.setAttribute(u,"loaded");var t,n,a=function(e){var t,n;if(e=/^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(e||""))return t=Number(e[1]),n=e[2],e=e[3],n?e?[t,Number(e)]:[t,void 0]:[t,t]}(o.getAttribute("data-range"));a&&(t=e.split(/\r\n?|\n/g),n=a[0],a=null==a[1]?t.length:a[1],n<0&&(n+=t.length),n=Math.max(0,Math.min(n-1,t.length)),a<0&&(a+=t.length),a=Math.max(0,Math.min(a,t.length)),e=t.slice(n,a).join("\n"),o.hasAttribute("data-start")||o.setAttribute("data-start",String(n+1))),r.textContent=e,Prism.highlightElement(r)},s=function(e){o.setAttribute(u,"failed"),r.textContent=e},(i=new XMLHttpRequest).open("GET",n,!0),i.onreadystatechange=function(){4==i.readyState&&(i.status<400&&i.responseText?a(i.responseText):400<=i.status?s(" Error "+i.status+" while fetching file: "+i.statusText):s(" Error: File does not exist or is empty"))},i.send(null))}),e=!(Prism.plugins.fileHighlight={highlight:function(e){for(var t,n=(e||document).querySelectorAll(c),a=0;t=n[a++];)Prism.highlightElement(t)}}),Prism.fileHighlight=function(){e||(console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."),e=!0),Prism.plugins.fileHighlight.highlight.apply(this,arguments)})}();
```

## dist/manifest.json

```json
{
  "_copyright": "Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>",
  "_license": "This software is licensed under the MIT License.",
  "_file": "/Users/martinbechard/dev/claudeext/dist/manifest.json",
  "manifest_version": 3,
  "name": "Claude Input Extension",
  "version": "1.0.0",
  "description": "Enhances interaction with Claude AI interface",
  "permissions": [
    "activeTab",
    "scripting",
    "storage",
    "downloads"
  ],
  "host_permissions": [
    "https://claude.ai/*",
    "https://api.anthropic.com/*"
  ],
  "background": {
    "service_worker": "background.js",
    "type": "module"
  },
  "options_ui": {
    "page": "options.html",
    "open_in_tab": true
  },
  "content_scripts": [
    {
      "matches": [
        "https://claude.ai/*"
      ],
      "js": [
        "lib/prism.js",
        "lib/prism-typescript.js",
        "lib/prism-javascript.js",
        "lib/prism-python.js",
        "lib/prism-json.js",
        "lib/prism-markdown.js",
        "content.js"
      ],
      "css": [
        "lib/prism.css",
        "styles.css"
      ],
      "run_at": "document_idle",
      "type": "module"
    }
  ],
  "web_accessible_resources": [
    {
      "resources": [
        "styles.css"
      ],
      "matches": [
        "https://claude.ai/*"
      ]
    }
  ]
}
```

## dist/options.html

```html
<!--
Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
This software is licensed under the MIT License.
File: /Users/martinbechard/dev/claudeext/dist/options.html
This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
-->

<!DOCTYPE html>
<html>
  <head>
    <title>Claude Extension Settings</title>
    <style>
      body {
        padding: 20px;
        font-family: system-ui, -apple-system, sans-serif;
      }
      .container {
        max-width: 600px;
        margin: 0 auto;
      }
      .form-group {
        margin-bottom: 20px;
      }
      label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
      }
      input[type="text"] {
        width: 100%;
        padding: 8px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 14px;
      }
      .error {
        color: #dc3545;
        font-size: 14px;
        margin-top: 5px;
        display: none;
      }
      .success {
        color: #28a745;
        font-size: 14px;
        margin-top: 5px;
        display: none;
      }
      .button-group {
        display: flex;
        gap: 10px;
      }
      button {
        background: #0066cc;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
      }
      button:hover {
        background: #0052a3;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      #testApiKey {
        background: #28a745;
      }
      #testApiKey:hover {
        background: #218838;
      }
      #testApiKey:disabled {
        background: #ccc;
      }
      .status {
        margin-top: 10px;
        padding: 10px;
        border-radius: 4px;
        display: none;
      }
      .status.testing {
        display: block;
        background: #fff3cd;
        color: #856404;
        border: 1px solid #ffeeba;
      }
      .status.success {
        display: block;
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }
      .status.error {
        display: block;
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Claude Extension Settings</h1>
      <form id="settingsForm">
        <div class="form-group">
          <label for="apiKey">Anthropic API Key</label>
          <input type="text" id="apiKey" placeholder="sk-ant-..." required />
          <div class="error" id="apiKeyError"></div>
          <div class="success" id="apiKeySuccess"></div>
          <div class="status" id="apiKeyStatus"></div>
        </div>
        <div class="form-group">
          <label for="model">Claude Model</label>
          <input
            type="text"
            id="model"
            placeholder="claude-3-5-sonnet-20241022"
            value="claude-3-5-sonnet-20241022"
            required
          />
          <div class="error" id="modelError"></div>
          <div class="success" id="modelSuccess"></div>
        </div>
        <div class="button-group">
          <button type="submit">Save</button>
          <button type="button" id="testApiKey">Test API Key</button>
        </div>
      </form>
    </div>
    <script src="options.js"></script>
  </body>
</html>

```

## dist/options.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/options.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

(() => { // webpackBootstrap
/*!************************!*\
  !*** ./src/options.js ***!
  \************************/
const STORAGE_KEY = "anthropic_api_settings";

// Load saved settings
async function loadSettings() {
  try {
    const result = await chrome.storage.sync.get([STORAGE_KEY]);
    const settings = result[STORAGE_KEY] || {};
    if (settings.anthropicApiKey) {
      document.getElementById("apiKey").value = settings.anthropicApiKey;
    }
    if (settings.model) {
      document.getElementById("model").value = settings.model;
    }
  } catch (error) {
    console.error("Failed to load settings:", error);
  }
}

// Initial load
document.addEventListener("DOMContentLoaded", () => {
  loadSettings();
});

function validateApiKey(key) {
  if (!key) {
    return "API key is required";
  }
  if (!key.startsWith("sk-ant-")) {
    return 'Invalid API key format. Must start with "sk-ant-"';
  }
  if (key.length < 32) {
    return "API key appears too short";
  }
  return null;
}

function validateModel(model) {
  if (!model) {
    return "Model is required";
  }
  if (!model.startsWith("claude-")) {
    return 'Invalid model format. Must start with "claude-"';
  }
  return null;
}

async function testApiKey(apiKey) {
  const statusDiv = document.getElementById("apiKeyStatus");
  const testButton = document.getElementById("testApiKey");

  // Reset status
  statusDiv.className = "status testing";
  statusDiv.textContent = "Testing API key...";
  testButton.disabled = true;

  try {
    const response = await new Promise((resolve) => {
      chrome.runtime.sendMessage(
        {
          type: "anthropic_test",
          apiKey,
        },
        (response) => {
          if (chrome.runtime.lastError) {
            resolve({ error: chrome.runtime.lastError.message });
          } else {
            resolve(response);
          }
        }
      );
    });

    if (response.error) {
      statusDiv.className = "status error";
      statusDiv.textContent = `API key test failed: ${response.error}`;
    } else {
      statusDiv.className = "status success";
      statusDiv.textContent = `API key is valid! Using model: ${response.model}`;
    }
  } catch (error) {
    statusDiv.className = "status error";
    statusDiv.textContent = `Error testing API key: ${error.message}`;
  } finally {
    testButton.disabled = false;
  }
}

document.getElementById("testApiKey").addEventListener("click", async () => {
  const apiKey = document.getElementById("apiKey").value.trim();
  const error = validateApiKey(apiKey);

  if (error) {
    const statusDiv = document.getElementById("apiKeyStatus");
    statusDiv.className = "status error";
    statusDiv.textContent = error;
    return;
  }

  await testApiKey(apiKey);
});

document
  .getElementById("settingsForm")
  .addEventListener("submit", async (e) => {
    e.preventDefault();

    const apiKey = document.getElementById("apiKey").value.trim();
    const model = document.getElementById("model").value.trim();
    const apiKeyErrorDiv = document.getElementById("apiKeyError");
    const modelErrorDiv = document.getElementById("modelError");
    const apiKeySuccessDiv = document.getElementById("apiKeySuccess");
    const modelSuccessDiv = document.getElementById("modelSuccess");

    // Reset messages
    apiKeyErrorDiv.style.display = "none";
    modelErrorDiv.style.display = "none";
    apiKeySuccessDiv.style.display = "none";
    modelSuccessDiv.style.display = "none";

    const apiKeyError = validateApiKey(apiKey);
    const modelError = validateModel(model);

    if (apiKeyError) {
      apiKeyErrorDiv.textContent = apiKeyError;
      apiKeyErrorDiv.style.display = "block";
      return;
    }

    if (modelError) {
      modelErrorDiv.textContent = modelError;
      modelErrorDiv.style.display = "block";
      return;
    }

    try {
      // Save settings
      await chrome.storage.sync.set({
        [STORAGE_KEY]: {
          anthropicApiKey: apiKey,
          model: model,
        },
      });

      // In dev mode, also save to localStorage
      if (true) {
        localStorage.setItem(
          STORAGE_KEY,
          JSON.stringify({
            anthropicApiKey: apiKey,
            model: model,
          })
        );
      }

      // Keep the form values
      document.getElementById("apiKey").value = apiKey;
      document.getElementById("model").value = model;

      apiKeySuccessDiv.textContent = "Settings saved successfully";
      apiKeySuccessDiv.style.display = "block";
      setTimeout(() => {
        apiKeySuccessDiv.style.display = "none";
      }, 3000);
    } catch (error) {
      apiKeyErrorDiv.textContent = "Failed to save settings: " + error.message;
      apiKeyErrorDiv.style.display = "block";
    }
  });

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQix5Q0FBeUM7QUFDL0QsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0Esc0RBQXNELGVBQWU7QUFDckUsTUFBTTtBQUNOO0FBQ0EsZ0VBQWdFLGVBQWU7QUFDL0U7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzREFBc0QsY0FBYztBQUNwRSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0EsVUFBVSxJQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2xhdWRlLWV4dGVuc2lvbi8uL3NyYy9vcHRpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNUT1JBR0VfS0VZID0gXCJhbnRocm9waWNfYXBpX3NldHRpbmdzXCI7XG5cbi8vIExvYWQgc2F2ZWQgc2V0dGluZ3NcbmFzeW5jIGZ1bmN0aW9uIGxvYWRTZXR0aW5ncygpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjaHJvbWUuc3RvcmFnZS5zeW5jLmdldChbU1RPUkFHRV9LRVldKTtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHJlc3VsdFtTVE9SQUdFX0tFWV0gfHwge307XG4gICAgaWYgKHNldHRpbmdzLmFudGhyb3BpY0FwaUtleSkge1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhcGlLZXlcIikudmFsdWUgPSBzZXR0aW5ncy5hbnRocm9waWNBcGlLZXk7XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy5tb2RlbCkge1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb2RlbFwiKS52YWx1ZSA9IHNldHRpbmdzLm1vZGVsO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgc2V0dGluZ3M6XCIsIGVycm9yKTtcbiAgfVxufVxuXG4vLyBJbml0aWFsIGxvYWRcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsICgpID0+IHtcbiAgbG9hZFNldHRpbmdzKCk7XG59KTtcblxuZnVuY3Rpb24gdmFsaWRhdGVBcGlLZXkoa2V5KSB7XG4gIGlmICgha2V5KSB7XG4gICAgcmV0dXJuIFwiQVBJIGtleSBpcyByZXF1aXJlZFwiO1xuICB9XG4gIGlmICgha2V5LnN0YXJ0c1dpdGgoXCJzay1hbnQtXCIpKSB7XG4gICAgcmV0dXJuICdJbnZhbGlkIEFQSSBrZXkgZm9ybWF0LiBNdXN0IHN0YXJ0IHdpdGggXCJzay1hbnQtXCInO1xuICB9XG4gIGlmIChrZXkubGVuZ3RoIDwgMzIpIHtcbiAgICByZXR1cm4gXCJBUEkga2V5IGFwcGVhcnMgdG9vIHNob3J0XCI7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTW9kZWwobW9kZWwpIHtcbiAgaWYgKCFtb2RlbCkge1xuICAgIHJldHVybiBcIk1vZGVsIGlzIHJlcXVpcmVkXCI7XG4gIH1cbiAgaWYgKCFtb2RlbC5zdGFydHNXaXRoKFwiY2xhdWRlLVwiKSkge1xuICAgIHJldHVybiAnSW52YWxpZCBtb2RlbCBmb3JtYXQuIE11c3Qgc3RhcnQgd2l0aCBcImNsYXVkZS1cIic7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRlc3RBcGlLZXkoYXBpS2V5KSB7XG4gIGNvbnN0IHN0YXR1c0RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYXBpS2V5U3RhdHVzXCIpO1xuICBjb25zdCB0ZXN0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0ZXN0QXBpS2V5XCIpO1xuXG4gIC8vIFJlc2V0IHN0YXR1c1xuICBzdGF0dXNEaXYuY2xhc3NOYW1lID0gXCJzdGF0dXMgdGVzdGluZ1wiO1xuICBzdGF0dXNEaXYudGV4dENvbnRlbnQgPSBcIlRlc3RpbmcgQVBJIGtleS4uLlwiO1xuICB0ZXN0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNocm9tZS5ydW50aW1lLnNlbmRNZXNzYWdlKFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJhbnRocm9waWNfdGVzdFwiLFxuICAgICAgICAgIGFwaUtleSxcbiAgICAgICAgfSxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKGNocm9tZS5ydW50aW1lLmxhc3RFcnJvcikge1xuICAgICAgICAgICAgcmVzb2x2ZSh7IGVycm9yOiBjaHJvbWUucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZSB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICBzdGF0dXNEaXYuY2xhc3NOYW1lID0gXCJzdGF0dXMgZXJyb3JcIjtcbiAgICAgIHN0YXR1c0Rpdi50ZXh0Q29udGVudCA9IGBBUEkga2V5IHRlc3QgZmFpbGVkOiAke3Jlc3BvbnNlLmVycm9yfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXR1c0Rpdi5jbGFzc05hbWUgPSBcInN0YXR1cyBzdWNjZXNzXCI7XG4gICAgICBzdGF0dXNEaXYudGV4dENvbnRlbnQgPSBgQVBJIGtleSBpcyB2YWxpZCEgVXNpbmcgbW9kZWw6ICR7cmVzcG9uc2UubW9kZWx9YDtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgc3RhdHVzRGl2LmNsYXNzTmFtZSA9IFwic3RhdHVzIGVycm9yXCI7XG4gICAgc3RhdHVzRGl2LnRleHRDb250ZW50ID0gYEVycm9yIHRlc3RpbmcgQVBJIGtleTogJHtlcnJvci5tZXNzYWdlfWA7XG4gIH0gZmluYWxseSB7XG4gICAgdGVzdEJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICB9XG59XG5cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidGVzdEFwaUtleVwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhcGlLZXkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFwaUtleVwiKS52YWx1ZS50cmltKCk7XG4gIGNvbnN0IGVycm9yID0gdmFsaWRhdGVBcGlLZXkoYXBpS2V5KTtcblxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zdCBzdGF0dXNEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFwaUtleVN0YXR1c1wiKTtcbiAgICBzdGF0dXNEaXYuY2xhc3NOYW1lID0gXCJzdGF0dXMgZXJyb3JcIjtcbiAgICBzdGF0dXNEaXYudGV4dENvbnRlbnQgPSBlcnJvcjtcbiAgICByZXR1cm47XG4gIH1cblxuICBhd2FpdCB0ZXN0QXBpS2V5KGFwaUtleSk7XG59KTtcblxuZG9jdW1lbnRcbiAgLmdldEVsZW1lbnRCeUlkKFwic2V0dGluZ3NGb3JtXCIpXG4gIC5hZGRFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIGFzeW5jIChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgYXBpS2V5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJhcGlLZXlcIikudmFsdWUudHJpbSgpO1xuICAgIGNvbnN0IG1vZGVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb2RlbFwiKS52YWx1ZS50cmltKCk7XG4gICAgY29uc3QgYXBpS2V5RXJyb3JEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImFwaUtleUVycm9yXCIpO1xuICAgIGNvbnN0IG1vZGVsRXJyb3JEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1vZGVsRXJyb3JcIik7XG4gICAgY29uc3QgYXBpS2V5U3VjY2Vzc0RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYXBpS2V5U3VjY2Vzc1wiKTtcbiAgICBjb25zdCBtb2RlbFN1Y2Nlc3NEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1vZGVsU3VjY2Vzc1wiKTtcblxuICAgIC8vIFJlc2V0IG1lc3NhZ2VzXG4gICAgYXBpS2V5RXJyb3JEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIG1vZGVsRXJyb3JEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGFwaUtleVN1Y2Nlc3NEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIG1vZGVsU3VjY2Vzc0Rpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICBjb25zdCBhcGlLZXlFcnJvciA9IHZhbGlkYXRlQXBpS2V5KGFwaUtleSk7XG4gICAgY29uc3QgbW9kZWxFcnJvciA9IHZhbGlkYXRlTW9kZWwobW9kZWwpO1xuXG4gICAgaWYgKGFwaUtleUVycm9yKSB7XG4gICAgICBhcGlLZXlFcnJvckRpdi50ZXh0Q29udGVudCA9IGFwaUtleUVycm9yO1xuICAgICAgYXBpS2V5RXJyb3JEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobW9kZWxFcnJvcikge1xuICAgICAgbW9kZWxFcnJvckRpdi50ZXh0Q29udGVudCA9IG1vZGVsRXJyb3I7XG4gICAgICBtb2RlbEVycm9yRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFNhdmUgc2V0dGluZ3NcbiAgICAgIGF3YWl0IGNocm9tZS5zdG9yYWdlLnN5bmMuc2V0KHtcbiAgICAgICAgW1NUT1JBR0VfS0VZXToge1xuICAgICAgICAgIGFudGhyb3BpY0FwaUtleTogYXBpS2V5LFxuICAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJbiBkZXYgbW9kZSwgYWxzbyBzYXZlIHRvIGxvY2FsU3RvcmFnZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgU1RPUkFHRV9LRVksXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgYW50aHJvcGljQXBpS2V5OiBhcGlLZXksXG4gICAgICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gS2VlcCB0aGUgZm9ybSB2YWx1ZXNcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYXBpS2V5XCIpLnZhbHVlID0gYXBpS2V5O1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb2RlbFwiKS52YWx1ZSA9IG1vZGVsO1xuXG4gICAgICBhcGlLZXlTdWNjZXNzRGl2LnRleHRDb250ZW50ID0gXCJTZXR0aW5ncyBzYXZlZCBzdWNjZXNzZnVsbHlcIjtcbiAgICAgIGFwaUtleVN1Y2Nlc3NEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBhcGlLZXlTdWNjZXNzRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIH0sIDMwMDApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBhcGlLZXlFcnJvckRpdi50ZXh0Q29udGVudCA9IFwiRmFpbGVkIHRvIHNhdmUgc2V0dGluZ3M6IFwiICsgZXJyb3IubWVzc2FnZTtcbiAgICAgIGFwaUtleUVycm9yRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfVxuICB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==
```

## dist/services/DocumentDownload.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/services/DocumentDownload.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/services/DocumentDownload.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for handling document downloads and markdown creation
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentDownload = void 0;
/**
 * Service for managing document downloads and markdown formatting.
 */
class DocumentDownload {
    /**
     * Creates a markdown formatted string containing all selected documents.
     * @param docs - Array of documents to include
     * @returns Formatted markdown string
     */
    static createMarkdownContent(docs) {
        const sections = [];
        const groupedDocs = this.groupDocumentsByDirectory(docs);
        // Add header section
        sections.push("# src\n");
        // Process each directory group
        Object.entries(groupedDocs).forEach(([directory, dirDocs]) => {
            // Add directory header if there's more than the root directory
            if (directory !== "" && Object.keys(groupedDocs).length > 1) {
                sections.push(`## ${directory}\n`);
            }
            // Add each file in the directory
            dirDocs.forEach((doc) => {
                // Get file extension to determine code block language
                const extension = doc.fileName.split(".").pop() || "";
                const language = this.getLanguageFromExtension(extension);
                sections.push(`## ${doc.filePath}\n`);
                sections.push("```" + language);
                sections.push(doc.content);
                sections.push("```\n");
            });
        });
        return sections.join("\n");
    }
    /**
     * Groups documents by their directory path.
     * @param docs - Array of documents to group
     * @returns Object with directory paths as keys and document arrays as values
     */
    static groupDocumentsByDirectory(docs) {
        const groups = {};
        docs.forEach((doc) => {
            const path = doc.filePath;
            const lastSlash = path.lastIndexOf("/");
            const directory = lastSlash > 0 ? path.substring(0, lastSlash) : "";
            if (!groups[directory]) {
                groups[directory] = [];
            }
            groups[directory].push(doc);
        });
        // Sort directories and files for consistent output
        return Object.keys(groups)
            .sort()
            .reduce((obj, key) => {
            obj[key] = groups[key].sort((a, b) => a.fileName.localeCompare(b.fileName));
            return obj;
        }, {});
    }
    /**
     * Maps file extensions to markdown code block languages.
     * @param extension - File extension
     * @returns Language identifier for markdown
     */
    static getLanguageFromExtension(extension) {
        const languageMap = {
            ts: "typescript",
            js: "javascript",
            jsx: "jsx",
            tsx: "tsx",
            css: "css",
            scss: "scss",
            html: "html",
            json: "json",
            md: "markdown",
            py: "python",
            rb: "ruby",
            java: "java",
            cpp: "cpp",
            c: "c",
            cs: "csharp",
            go: "go",
            rs: "rust",
            php: "php",
            sql: "sql",
            yaml: "yaml",
            yml: "yaml",
            xml: "xml",
            sh: "bash",
            bash: "bash",
            zsh: "bash",
            swift: "swift",
        };
        return languageMap[extension.toLowerCase()] || "";
    }
    /**
     * Downloads the content as a markdown file.
     * @param content - Markdown content to download
     * @param defaultFilename - Default filename to suggest
     */
    static downloadMarkdown(content, defaultFilename) {
        // Create blob from content
        const blob = new Blob([content], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        try {
            // Use Chrome downloads API
            chrome.downloads.download({
                url: url,
                filename: defaultFilename,
                saveAs: true,
            }, (downloadId) => {
                if (chrome.runtime.lastError) {
                    console.error("Download failed:", chrome.runtime.lastError);
                    alert("Failed to start download. Please try again.");
                }
            });
        }
        finally {
            // Clean up the blob URL after a short delay
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }
    }
    /**
     * Handles the export of selected documents.
     * @param selectedDocs - Array of documents to export
     */
    static async handleExport(selectedDocs) {
        if (selectedDocs.length === 0) {
            throw new Error("No documents selected for export");
        }
        try {
            // Create markdown content
            const markdownContent = this.createMarkdownContent(selectedDocs);
            // Generate default filename based on current date/time
            const timestamp = new Date()
                .toISOString()
                .replace(/[:]/g, "-")
                .split(".")[0];
            const defaultFilename = `claude-export-${timestamp}.md`;
            // Download the file
            this.downloadMarkdown(markdownContent, defaultFilename);
            console.log(`Successfully prepared export for ${selectedDocs.length} documents`);
        }
        catch (error) {
            throw new Error(`Failed to export documents: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
}
exports.DocumentDownload = DocumentDownload;
//# sourceMappingURL=DocumentDownload.js.map
```

## dist/services/DocumentRetrieval.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/services/DocumentRetrieval.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/services/DocumentRetrieval.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for retrieving and displaying documents from Claude API
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentRetrieval = void 0;
const DocumentDownload_1 = require("./DocumentDownload");
/**
 * Service for retrieving and displaying Claude-generated documents.
 */
class DocumentRetrieval {
    /**
     * Gets the project or conversation ID from the URL based on the URL pattern.
     * @returns Object containing either direct project ID or conversation ID
     */
    static getIdsFromUrl() {
        // Check for direct project URL pattern
        const projectMatch = window.location.pathname.match(/\/project\/([^\/]+)/);
        if (projectMatch) {
            return { projectId: projectMatch[1], conversationId: null };
        }
        // Check for chat conversation URL pattern
        const chatMatch = window.location.pathname.match(/\/chat\/([^\/]+)/);
        if (!chatMatch) {
            throw new Error("Please navigate to a Claude chat or project page before using the /docs command");
        }
        return {
            projectId: null,
            conversationId: chatMatch ? chatMatch[1] : null,
        };
    }
    /**
     * Gets the project UUID either directly from URL or from conversation details.
     * @param organizationId - Organization ID to use
     * @returns Promise resolving to project UUID
     * @throws Error if project UUID cannot be determined
     */
    static async getProjectUuid(organizationId) {
        const { projectId, conversationId } = this.getIdsFromUrl();
        // If we have a direct project ID, use it
        if (projectId) {
            return projectId;
        }
        // If we have a conversation ID, fetch project UUID from conversation details
        if (conversationId) {
            const response = await fetch(`${this.API_URL}/${organizationId}/chat_conversations/${conversationId}?tree=True&rendering_mode=messages`, {
                method: "GET",
                headers: this.getHeaders(),
                credentials: "include",
            });
            if (!response.ok) {
                throw new Error(`Failed to fetch conversation details: ${response.status}`);
            }
            const data = await response.json();
            const projectUuid = data.project_uuid;
            if (!projectUuid) {
                throw new Error("Project UUID not found in conversation details");
            }
            return projectUuid;
        }
        throw new Error("No project or conversation ID found in URL");
    }
    /**
     * Gets the organization ID from cookies.
     * @returns Organization ID from cookies or null if not found
     */
    static getOrganizationId() {
        const cookie = document.cookie
            .split("; ")
            .find((row) => row.startsWith("lastActiveOrg="));
        if (cookie) {
            try {
                const value = decodeURIComponent(cookie.split("=")[1]);
                // Remove any quotes from the value
                return value.replace(/^"|"$/g, "");
            }
            catch (error) {
                console.error("Error parsing organization ID from cookie:", error);
                return null;
            }
        }
        return null;
    }
    /**
     * Retrieves documents from the Claude API.
     * @returns Promise containing array of document information
     * @throws Error if API request fails or required IDs are missing
     */
    static async fetchDocuments() {
        const organizationId = this.getOrganizationId();
        if (!organizationId) {
            throw new Error("Organization ID not found in cookies");
        }
        console.log("Determining project UUID...");
        const projectUuid = await this.getProjectUuid(organizationId);
        console.log("Fetching documents from Claude API...");
        const response = await fetch(`${this.API_URL}/${organizationId}/projects/${projectUuid}/docs`, {
            method: "GET",
            headers: this.getHeaders(),
            credentials: "include",
        });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        return this.processDocuments(data);
    }
    /**
     * Displays document information in a tabular format.
     * @param docs - Array of document information to display
     * @param outputElement - Element to render the table in
     * @returns Promise resolving when display is complete
     */
    static async displayDocuments(docs, outputElement) {
        outputElement.innerHTML = "";
        if (docs.length === 0) {
            this.displayEmptyState(outputElement);
            return;
        }
        const table = this.createTable();
        const headerRow = this.createTableHeader();
        table.appendChild(headerRow);
        const tbody = table.createTBody();
        docs.forEach((doc) => {
            const row = this.createDocumentRow(doc);
            tbody.appendChild(row);
        });
        outputElement.appendChild(table);
        this.addExportButton(outputElement, docs);
    }
    /**
     * Creates the main table element with styling.
     * @returns Styled table element
     */
    static createTable() {
        const table = document.createElement("table");
        table.style.width = "100%";
        table.style.borderCollapse = "collapse";
        table.style.marginTop = "10px";
        return table;
    }
    /**
     * Creates the table header row with column headers.
     * @returns Header row element
     */
    static createTableHeader() {
        const header = document.createElement("thead");
        const headerRow = document.createElement("tr");
        this.TABLE_HEADERS.forEach((headerConfig) => {
            const th = document.createElement("th");
            th.style.border = "1px solid #ccc";
            th.style.padding = "4px";
            th.style.textAlign = headerConfig.id === "checkbox" ? "center" : "left";
            if (headerConfig.width) {
                th.style.width = headerConfig.width;
            }
            if (headerConfig.id === "checkbox") {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.addEventListener("change", (e) => {
                    const target = e.target;
                    const table = target.closest("table");
                    if (table) {
                        const checkboxes = table.querySelectorAll('tbody input[type="checkbox"]');
                        checkboxes.forEach((cb) => (cb.checked = target.checked));
                    }
                });
                th.appendChild(checkbox);
            }
            else {
                th.textContent = headerConfig.label;
            }
            headerRow.appendChild(th);
        });
        header.appendChild(headerRow);
        return header;
    }
    /**
     * Creates a table row for a document.
     * @param doc - Document information to display
     * @returns Table row element
     */
    static createDocumentRow(doc) {
        const row = document.createElement("tr");
        row.style.borderBottom = "1px solid #ccc";
        // Checkbox cell
        const checkCell = document.createElement("td");
        checkCell.style.padding = "4px";
        checkCell.style.border = "1px solid #ccc";
        checkCell.style.textAlign = "center";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkCell.appendChild(checkbox);
        row.appendChild(checkCell);
        // Document info cells
        [doc.fileName, doc.filePath].forEach((text) => {
            const cell = document.createElement("td");
            cell.style.padding = "4px";
            cell.style.border = "1px solid #ccc";
            cell.textContent = text;
            row.appendChild(cell);
        });
        return row;
    }
    /**
     * Adds an export button for selected documents.
     * @param container - Container element for the button
     * @param docs - Array of available documents
     */
    static addExportButton(container, docs) {
        const exportButton = document.createElement("button");
        exportButton.textContent = "Export Selected Files";
        exportButton.className = "export-button";
        exportButton.addEventListener("click", async () => {
            const table = container.querySelector("table");
            if (!table) {
                console.error("Table not found"); // Log error
                return;
            }
            const selectedFiles = [];
            const checkboxes = table.querySelectorAll('tbody input[type="checkbox"]');
            checkboxes.forEach((checkbox, index) => {
                if (checkbox.checked) {
                    selectedFiles.push(docs[index]);
                }
            });
            if (selectedFiles.length === 0) {
                alert("Please select files to export"); // User feedback
                return;
            }
            try {
                await DocumentDownload_1.DocumentDownload.handleExport(selectedFiles); // Await the async call
            }
            catch (error) {
                console.error("Export failed:", error);
                alert("Export failed: " +
                    (error instanceof Error ? error.message : "Unknown error"));
            }
        });
        container.appendChild(exportButton);
    }
    /**
     * Displays an empty state message when no documents are found.
     * @param container - Container element for the message
     */
    static displayEmptyState(container) {
        const message = document.createElement("div");
        message.style.textAlign = "center";
        message.style.padding = "20px";
        message.style.color = "#666";
        message.textContent = "No Claude-generated documents found";
        container.appendChild(message);
    }
    /**
     * Processes raw document data into structured format.
     * @param data - Raw document data from API
     * @returns Array of processed document information
     */
    static processDocuments(data) {
        return data
            .filter((doc) => doc.content?.includes("This was generated by Claude Sonnet"))
            .map((doc) => {
            const filePathMatch = doc.content.match(/File: (.+)/);
            return filePathMatch
                ? {
                    fileName: doc.file_name,
                    filePath: filePathMatch[1],
                    content: doc.content,
                }
                : null;
        })
            .filter((doc) => doc !== null);
    }
    /**
     * Returns headers required for API requests.
     * @returns Object containing required headers
     */
    static getHeaders() {
        return {
            Accept: "*/*",
            "Accept-Encoding": "gzip, deflate, br, zstd",
            "Accept-Language": "en-US,en;q=0.9,fr-CA;q=0.8,fr;q=0.7",
            "Anthropic-Client-Sha": "unknown",
            "Anthropic-Client-Version": "unknown",
            "Cache-Control": "no-cache",
            "Content-Type": "application/json",
            Origin: "https://claude.ai",
            Pragma: "no-cache",
            Referer: "https://claude.ai/",
            "Sec-Ch-Ua": '"Chromium";v="128", "Not;A=Brand";v="24", "Google Chrome";v="128"',
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": '"macOS"',
            Priority: "u=1, i",
        };
    }
}
exports.DocumentRetrieval = DocumentRetrieval;
DocumentRetrieval.API_URL = "https://api.claude.ai/api/organizations";
DocumentRetrieval.TABLE_HEADERS = [
    { id: "checkbox", label: "", width: "40px" },
    { id: "fileName", label: "Name" },
    { id: "filePath", label: "Path" },
];
//# sourceMappingURL=DocumentRetrieval.js.map
```

## dist/services/ScriptRunner.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/services/ScriptRunner.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/*
 * Copyright (c) 2024 Martin Bechard (martin.bechard@DevConsult.ca)
 * This software is licensed under the MIT License.
 * File: services/ScriptRunner.ts
 * Credit: This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 * Summary: Service for executing scripts and managing script execution state
 * Witty remark: Running scripts like a marathon runner, but with better error handling!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptRunner = void 0;
/**
 * Manages script execution and streaming state.
 */
class ScriptRunner {
    constructor(logCallback) {
        this.isRunning = false;
        this.MAX_ATTEMPTS = 300;
        this.CHECK_INTERVAL = 100;
        this.logCallback = logCallback;
    }
    /**
     * Executes a script with the provided configuration.
     * @param script - Script configuration to execute
     * @throws Error if script execution fails
     */
    async runScript(script) {
        if (this.isRunning) {
            throw new Error("Script is already running");
        }
        try {
            this.isRunning = true;
            this.logCallback(`Executing script with ${script.maxTries} maximum tries`);
            const targetDiv = await this.findInputElement();
            await this.executeScriptContent(script, targetDiv);
        }
        catch (error) {
            this.logCallback(`Script execution failed: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
            throw error;
        }
        finally {
            this.isRunning = false;
        }
    }
    /**
     * Monitors the streaming state of Claude's response.
     * @returns The final response text
     * @throws Error if monitoring times out
     */
    async checkStreaming() {
        let stableCount = 0;
        let attempts = 0;
        let lastContent = "";
        let lastStreamingDiv = null;
        while (attempts < this.MAX_ATTEMPTS && this.isRunning) {
            const streamingDiv = document.querySelector('div[data-is-streaming="true"]');
            if (streamingDiv) {
                if (streamingDiv.textContent !== lastContent) {
                    stableCount = 0;
                    lastContent = streamingDiv.textContent || "";
                    lastStreamingDiv = streamingDiv;
                }
                else {
                    stableCount++;
                }
            }
            else if (lastStreamingDiv) {
                return lastStreamingDiv.textContent || "";
            }
            else {
                stableCount++;
            }
            if (stableCount >= 20) {
                return lastContent;
            }
            await new Promise((resolve) => setTimeout(resolve, this.CHECK_INTERVAL));
            attempts++;
        }
        if (!this.isRunning) {
            throw new Error("Operation cancelled");
        }
        throw new Error("Response timeout");
    }
    /**
     * Finds the input element for script execution.
     * @returns Promise resolving to the input element
     * @throws Error if element not found
     */
    async findInputElement() {
        const targetDiv = document.querySelector('div[enterkeyhint="enter"]');
        if (!targetDiv) {
            throw new Error("Input element not found");
        }
        return targetDiv;
    }
    /**
     * Executes the content of a script.
     * @param script - Script to execute
     * @param targetDiv - Element to input the script
     */
    async executeScriptContent(script, targetDiv) {
        targetDiv.innerHTML = `<p>${script.prompt}</p>`;
        targetDiv.focus();
        await new Promise((resolve) => setTimeout(resolve, 100));
        await this.simulateEnterKey(targetDiv);
        const response = await this.checkStreaming();
        if (script.findText && !response.includes(script.findText)) {
            throw new Error(`Text "${script.findText}" not found in response`);
        }
    }
    /**
     * Simulates pressing the Enter key.
     * @param element - Element to receive the key event
     */
    simulateEnterKey(element) {
        const events = [
            new KeyboardEvent("keydown", {
                key: "Enter",
                code: "Enter",
                keyCode: 13,
                which: 13,
                bubbles: true,
            }),
            new KeyboardEvent("keypress", {
                key: "Enter",
                code: "Enter",
                keyCode: 13,
                which: 13,
                bubbles: true,
            }),
            new KeyboardEvent("keyup", {
                key: "Enter",
                code: "Enter",
                keyCode: 13,
                which: 13,
                bubbles: true,
            }),
        ];
        events.forEach((event) => element.dispatchEvent(event));
    }
    /**
     * Cancels the currently running script.
     */
    cancel() {
        this.isRunning = false;
    }
}
exports.ScriptRunner = ScriptRunner;
//# sourceMappingURL=ScriptRunner.js.map
```

## dist/src/analyzeConversations.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/analyzeConversations.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
// Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
// This software is licensed under the MIT License.
// Path: src/analyzeConversations.ts
// This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
// Script to analyze conversation data from a JSON file
// "I count characters so you don't have to!"
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ConversationAnalyzer_1 = require("./ConversationAnalyzer");
const promises_1 = __importDefault(require("fs/promises"));
async function analyzeFile(filePath) {
    try {
        const data = await promises_1.default.readFile(filePath, "utf8");
        const analyzer = ConversationAnalyzer_1.ConversationAnalyzer.fromJson(data);
        const results = analyzer.analyze();
        // Print results in a formatted way
        console.log("Conversation Analysis Results\n");
        results.conversationMetrics.forEach((conv) => {
            console.log(`Conversation: ${conv.conversationName} (${conv.conversationId})`);
            console.log("Message Lengths:");
            conv.messageLengths.forEach((msg) => {
                console.log(`  Message ${msg.messageId}: ${msg.length} characters`);
            });
            console.log(`Longest Message: ${conv.longestMessage.length} characters (ID: ${conv.longestMessage.messageId})`);
            console.log(`Total Size: ${conv.totalSize} characters\n`);
        });
        console.log(`Overall Total Size: ${results.totalSize} characters`);
    }
    catch (error) {
        console.error("Error analyzing file:", error);
        process.exit(1);
    }
}
// Get file path from command line arguments
const filePath = process.argv[2];
if (!filePath) {
    console.error("Please provide a file path as an argument");
    process.exit(1);
}
analyzeFile(filePath);
//# sourceMappingURL=analyzeConversations.js.map
```

## dist/src/ClaudeExtension.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/ClaudeExtension.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ClaudeExtension.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Main extension class that handles UI and script execution after required elements exist.
 * Note: This class assumes elements are already present - initialization happens in content.ts
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClaudeExtension = void 0;
const FloatingWindow_1 = require("./ui/components/FloatingWindow");
const DraggableManager_1 = require("./ui/components/DraggableManager");
const StatusManager_1 = require("./ui/components/StatusManager");
const ScriptRunner_1 = require("./services/ScriptRunner");
const ScriptParser_1 = require("./utils/ScriptParser");
const DocumentRetrieval_1 = require("./services/DocumentRetrieval");
const ProjectRetrieval_1 = require("./services/ProjectRetrieval");
const ProjectSearchService_1 = require("./services/ProjectSearchService");
const ConversationRetrieval_1 = require("./services/ConversationRetrieval");
const HelpManager_1 = require("./ui/components/HelpManager");
const ClaudeCache_1 = require("./services/ClaudeCache");
class ClaudeExtension {
    /**
     * Initialize UI components and bind event listeners.
     * Should only be called after required elements exist in the DOM.
     */
    async initializeUI() {
        console.log("Initializing UI components...");
        try {
            // Create UI components
            this.floatingWindow = new FloatingWindow_1.FloatingWindow();
            this.scriptRunner = new ScriptRunner_1.ScriptRunner(this.handleLog.bind(this));
            const windowElement = await this.floatingWindow.create();
            const elements = this.floatingWindow.getElements();
            // Set up status elements
            const statusElements = {
                statusElement: elements.status,
                statusText: elements.statusText,
                statusDetails: elements.statusDetails,
                scriptInput: elements.scriptText,
                runButton: elements.runButton,
            };
            // Initialize managers
            this.statusManager = new StatusManager_1.StatusManager(statusElements);
            this.draggableManager = new DraggableManager_1.DraggableManager(windowElement, elements.status);
            this.helpManager = new HelpManager_1.HelpManager(elements.output);
            // Bind event listeners
            this.bindEventListeners(elements);
            console.log("UI initialization complete");
        }
        catch (error) {
            console.error("UI initialization failed:", error);
            throw error;
        }
    }
    /**
     * Binds event listeners to UI elements
     */
    bindEventListeners(elements) {
        elements.runButton.addEventListener("click", () => this.handleRunScript(elements.scriptText));
        elements.scriptText.addEventListener("keydown", (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
                this.handleRunScript(elements.scriptText);
                e.preventDefault();
            }
        });
        elements.helpButton.addEventListener("click", () => this.helpManager?.show());
        elements.minimizeButton.addEventListener("click", () => this.floatingWindow?.toggleMinimize());
        elements.collapseButton.addEventListener("click", () => this.floatingWindow?.toggleCollapse());
    }
    /**
     * Handles script execution from the UI
     */
    async handleRunScript(scriptText) {
        const text = scriptText.value.trim();
        if (!text) {
            this.handleLog("Please enter a script", "error");
            return;
        }
        // Clear cache at start of any new execution
        ClaudeCache_1.ClaudeCache.clearCache();
        this.handleLog("Cache cleared", "info");
        try {
            const script = ScriptParser_1.ScriptParser.parse(text);
            await this.statusManager?.setStatus("working", "Running script...");
            if (!script.isCommand) {
                throw new Error("Not a valid command");
            }
            if (!script.command) {
                throw new Error("No command specified");
            }
            switch (script.command) {
                case "docs":
                    await this.handleDocsCommand();
                    break;
                case "project":
                    await this.handleProjectCommand();
                    break;
                case "search_project":
                    await this.handleSearchProjectCommand(script);
                    break;
                case "conversation":
                case "artifacts":
                    await this.handleConversationCommand(script.options);
                    break;
                default:
                    throw new Error(`Unknown command: ${script.command}`);
            }
            await this.statusManager?.setStatus("ready", "Complete");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Script error: ${message}`, "error");
            await this.statusManager?.setStatus("error", message);
            setTimeout(() => this.statusManager?.setStatus("ready"), 2000);
        }
    }
    /**
     * Handles the /docs command execution
     */
    async handleDocsCommand() {
        try {
            if (this.floatingWindow) {
                this.floatingWindow.clearOutput();
            }
            this.handleLog("Fetching documents...");
            const docs = await DocumentRetrieval_1.DocumentRetrieval.fetchDocuments();
            if (this.floatingWindow) {
                await DocumentRetrieval_1.DocumentRetrieval.displayDocuments(docs, this.floatingWindow.getOutputElement());
            }
            await this.statusManager?.setStatus("ready", "Complete");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Error fetching documents: ${message}`, "error");
            await this.statusManager?.setStatus("ready", "");
        }
    }
    /**
     * Handles the /project command execution
     */
    async handleProjectCommand() {
        try {
            if (this.floatingWindow) {
                this.floatingWindow.clearOutput();
            }
            this.handleLog("Fetching project conversations...");
            if (this.floatingWindow) {
                await ProjectRetrieval_1.ProjectRetrieval.displayCurrentProject(this.floatingWindow.getOutputElement());
            }
            await this.statusManager?.setStatus("ready", "Complete");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Error fetching project conversations: ${message}`, "error");
            await this.statusManager?.setStatus("error", message);
            setTimeout(() => this.statusManager?.setStatus("ready"), 2000);
        }
    }
    /**
     * Handles the /search_project command execution
     */
    async handleSearchProjectCommand(script) {
        try {
            if (this.floatingWindow) {
                this.floatingWindow.clearOutput();
            }
            this.handleLog(script.searchText
                ? `Searching projects for: ${script.searchText}`
                : "Retrieving project conversations...");
            if (this.floatingWindow) {
                await ProjectSearchService_1.ProjectSearchService.searchAndDisplayResults(script.searchText, this.floatingWindow.getOutputElement());
            }
            await this.statusManager?.setStatus("ready", script.searchText
                ? "Search completed successfully"
                : "Projects retrieved successfully");
            this.handleLog(script.searchText
                ? "Search completed successfully"
                : "Projects retrieved successfully", "success");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Error during project search: ${message}`, "error");
            await this.statusManager?.setStatus("error", message);
            setTimeout(() => this.statusManager?.setStatus("ready"), 2000);
        }
    }
    /**
     * Handles conversation-related commands execution
     */
    async handleConversationCommand(options) {
        try {
            if (this.floatingWindow) {
                this.floatingWindow.clearOutput();
            }
            this.handleLog("Retrieving conversation...");
            if (this.floatingWindow) {
                await ConversationRetrieval_1.ConversationRetrieval.displayCurrentConversation(options, this.floatingWindow.getOutputElement());
            }
            await this.statusManager?.setStatus("ready", "Conversation retrieved successfully");
            this.handleLog("Conversation retrieved successfully", "success");
        }
        catch (error) {
            const message = error instanceof Error ? error.message : "Unknown error";
            this.handleLog(`Error retrieving conversation: ${message}`, "error");
            await this.statusManager?.setStatus("error", message);
            setTimeout(() => this.statusManager?.setStatus("ready"), 2000);
        }
    }
    /**
     * Handles logging output to the UI
     */
    handleLog(message, type = "info") {
        console.log(message);
        this.floatingWindow?.log(message, type);
    }
}
exports.ClaudeExtension = ClaudeExtension;
//# sourceMappingURL=ClaudeExtension.js.map
```

## dist/src/content.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/content.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/content.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", { value: true });
const ClaudeExtension_1 = require("./ClaudeExtension");
console.log("Claude Extension loading...");
// Prevent multiple initializations
if (window.claudeExtInitialized) {
    console.log("Claude Extension already initialized, skipping...");
}
else {
    console.log("Claude Extension initializing...");
    // Simple element waiter - keeping what works
    function waitForElement(selector) {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                observer.disconnect();
                reject(new Error(`Timeout waiting for element: ${selector}`));
            }, 30000);
            if (document.querySelector(selector)) {
                console.log("Element found immediately:", selector);
                clearTimeout(timeout);
                return resolve(document.querySelector(selector));
            }
            console.log("Waiting for element:", selector);
            const observer = new MutationObserver(() => {
                if (document.querySelector(selector)) {
                    console.log("Element found after mutation:", selector);
                    clearTimeout(timeout);
                    observer.disconnect();
                    resolve(document.querySelector(selector));
                }
            });
            observer.observe(document.body, {
                childList: true,
                subtree: true,
            });
        });
    }
    // Initialize with same pattern as working version
    async function initialize() {
        try {
            console.log("Starting initialization...");
            // Check if we're on claude.ai
            if (!window.location.hostname.includes("claude.ai")) {
                console.log("Not on claude.ai, skipping initialization");
                return;
            }
            console.log("Waiting for Claude chat interface...");
            // Wait for elements BEFORE creating any UI
            await waitForElement('div[enterkeyhint="enter"]');
            console.log("Chat container found");
            // Only now create the UI
            const extension = new ClaudeExtension_1.ClaudeExtension();
            await extension.initializeUI();
            // Only NOW mark as initialized - after everything is complete
            window.claudeExtInitialized = true;
            console.log("Initialization complete");
        }
        catch (error) {
            console.error("Initialization failed:", error);
            // Show error to user
            const errorDiv = document.createElement("div");
            errorDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #ffebee;
                color: #c62828;
                padding: 15px;
                border-radius: 8px;
                z-index: 999999;
                font-family: Arial, sans-serif;
                box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            `;
            errorDiv.textContent = `Claude Extension Error: ${error instanceof Error ? error.message : "Unknown error"}`;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 5000);
        }
    }
    // Use proper async/await for initialization timing
    if (document.readyState === "loading") {
        console.log("Document loading, adding DOMContentLoaded listener...");
        document.addEventListener("DOMContentLoaded", async () => {
            // Wait for initialization to complete before continuing
            await initialize();
        });
    }
    else {
        console.log("Document already loaded, initializing...");
        // Wait for initialization to complete before continuing
        (async () => {
            await initialize();
        })();
    }
}
//# sourceMappingURL=content.js.map
```

## dist/src/ConversationAnalyzer.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/ConversationAnalyzer.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
// Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
// This software is licensed under the MIT License.
// Path: src/ConversationAnalyzer.ts
// This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
// Analyzes conversation data to extract metrics about message lengths and totals
// "I analyze conversations so thoroughly, I can tell you how many characters it takes to say 'hello' in every language!"
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationAnalyzer = void 0;
/**
 * Analyzes conversation data to extract various metrics about message lengths
 */
class ConversationAnalyzer {
    /**
     * Creates a new ConversationAnalyzer instance
     * @param data Array of conversations to analyze
     */
    constructor(data) {
        this.conversations = data;
    }
    /**
     * Analyzes all conversations and returns comprehensive metrics
     * @returns Analysis results including per-conversation metrics and total size
     */
    analyze() {
        const metrics = this.conversations.map((conv) => this.analyzeConversation(conv));
        const totalSize = metrics.reduce((sum, conv) => sum + conv.totalSize, 0);
        return {
            conversationMetrics: metrics,
            totalSize,
        };
    }
    /**
     * Analyzes a single conversation to extract its metrics
     * @param conversation The conversation to analyze
     * @returns Metrics for the specific conversation
     */
    analyzeConversation(conversation) {
        const messageLengths = conversation.messages.map((msg) => ({
            length: msg.content.length,
            messageId: msg.id,
        }));
        const longestMessage = messageLengths.reduce((max, current) => (current.length > max.length ? current : max), messageLengths[0]);
        const totalSize = messageLengths.reduce((sum, msg) => sum + msg.length, 0);
        return {
            conversationId: conversation.id,
            conversationName: conversation.name,
            messageLengths,
            longestMessage,
            totalSize,
        };
    }
    /**
     * Creates an instance from a JSON file
     * @param jsonString The JSON string containing conversation data
     * @returns A new ConversationAnalyzer instance
     */
    static fromJson(jsonString) {
        const data = JSON.parse(jsonString);
        return new ConversationAnalyzer(data);
    }
}
exports.ConversationAnalyzer = ConversationAnalyzer;
//# sourceMappingURL=ConversationAnalyzer.js.map
```

## dist/src/services/ClaudeCache.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/services/ClaudeCache.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
// Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
// This software is licensed under the MIT License.
// File: src/services/ClaudeCache.ts
// Simple caching utility for Claude API responses
// The cache that remembers so you don't have to!
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClaudeCache = void 0;
const getHeaders_1 = require("../utils/getHeaders");
class ClaudeCache {
    /**
     * Clears all entries from the cache
     */
    static clearCache() {
        ClaudeCache.cache.clear();
    }
    /**
     * Fetches data with caching support
     * @param url The URL to fetch from
     * @param options Optional fetch configuration
     * @returns Promise resolving to the fetched data
     */
    static async fetchWithCache(url, options = {}) {
        const { timeoutMs = ClaudeCache.DEFAULT_TIMEOUT_MS, forceRefresh = false } = options;
        // Always use fresh data if requested
        if (forceRefresh) {
            ClaudeCache.cache.delete(url);
        }
        // Check cache first
        const cachedEntry = ClaudeCache.cache.get(url);
        if (cachedEntry) {
            const now = Date.now();
            if (now - cachedEntry.timestamp < timeoutMs) {
                return cachedEntry.data;
            }
            // Remove expired entry
            ClaudeCache.cache.delete(url);
        }
        // If not in cache or expired, fetch new data
        const response = await fetch(url, {
            headers: options.headers || (0, getHeaders_1.getHeaders)(),
            credentials: "include",
        });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        // Cache the new data
        ClaudeCache.cache.set(url, {
            data,
            timestamp: Date.now(),
        });
        return data;
    }
    /**
     * Gets a cached entry directly
     * @param key Cache key to retrieve
     * @returns Cached data if found and not expired
     */
    static getCached(key) {
        const entry = ClaudeCache.cache.get(key);
        if (!entry)
            return null;
        const now = Date.now();
        if (now - entry.timestamp < ClaudeCache.DEFAULT_TIMEOUT_MS) {
            return entry.data;
        }
        // Remove expired entry
        ClaudeCache.cache.delete(key);
        return null;
    }
    /**
     * Sets a cache entry directly
     * @param key Cache key
     * @param data Data to cache
     */
    static setCached(key, data) {
        ClaudeCache.cache.set(key, {
            data,
            timestamp: Date.now(),
        });
    }
    /**
     * Removes a specific entry from the cache
     * @param key Cache key to remove
     */
    static removeCached(key) {
        ClaudeCache.cache.delete(key);
    }
}
exports.ClaudeCache = ClaudeCache;
ClaudeCache.cache = new Map();
ClaudeCache.DEFAULT_TIMEOUT_MS = 5 * 60 * 1000; // 5 minutes
//# sourceMappingURL=ClaudeCache.js.map
```

## dist/src/services/ConversationRetrieval.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/services/ConversationRetrieval.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/services/ConversationRetrieval.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for managing Claude conversations and artifacts
 * Note: Making conversation history as easy to browse as your social media feed!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationRetrieval = void 0;
const ClaudeCache_1 = require("./ClaudeCache");
const DownloadTable_1 = require("../ui/components/DownloadTable");
const getClaudeIds_1 = require("../utils/getClaudeIds");
const PathExtractor_1 = require("@/utils/PathExtractor");
/**
 * Service for managing Claude conversations and artifacts
 */
class ConversationRetrieval {
    /**
     * Gets the conversation ID from the current URL
     * @returns Conversation ID if found
     * @throws Error if not on a conversation page
     */
    static getConversationIdFromUrl() {
        const match = window.location.pathname.match(/\/chat\/([^\/]+)/);
        if (!match) {
            throw new Error("Please navigate to a Claude chat page before using conversation commands");
        }
        return match[1];
    }
    /**
     * Retrieves a conversation by ID with caching
     * @param orgId - Organization ID
     * @param conversationId - Conversation ID to retrieve
     * @returns Promise resolving to conversation data
     * @throws Error if retrieval fails
     */
    static async getConversation(orgId, conversationId, forceRefresh = false) {
        const url = `${this.API_URL}/${orgId}/chat_conversations/${conversationId}?tree=True&rendering_mode=messages`;
        try {
            return await ClaudeCache_1.ClaudeCache.fetchWithCache(url, {
                forceRefresh,
                timeoutMs: 60000, // Cache for 1 minute since conversations can update frequently
            });
        }
        catch (error) {
            throw new Error(`Error retrieving conversation: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Gets appropriate file extension based on language
     * @param language - Programming language or file type
     * @returns File extension including dot
     */
    static getFileExtension(language) {
        if (!language)
            return ".txt";
        const extensionMap = {
            typescript: ".ts",
            javascript: ".js",
            python: ".py",
            java: ".java",
            "text/markdown": ".md",
            "application/json": ".json",
            html: ".html",
            css: ".css",
            "text/html": ".html",
            "application/vnd.ant.code": ".txt",
            "application/vnd.ant.react": ".tsx",
            "application/vnd.ant.mermaid": ".mmd",
            "image/svg+xml": ".svg",
        };
        return extensionMap[language.toLowerCase()] || ".txt";
    }
    /**
     * Extracts artifacts from a conversation
     * @param conversation - Conversation to extract artifacts from
     * @returns Array of artifacts
     */
    static extractArtifacts(conversation) {
        const artifacts = [];
        conversation.chat_messages.forEach((message) => {
            message.content.forEach((item) => {
                const input = item.input;
                if (!input) {
                    return;
                }
                if (item.type === "tool_use" && input) {
                    const content = input.content;
                    const filePath = (content && this.extractFilePath(content)) || "";
                    // Extract file name from file path or content
                    let fileName = "";
                    if (filePath) {
                        fileName = filePath.split("/").pop() || "";
                    }
                    if (!fileName && content) {
                        // Try to extract filename from content if it contains file path
                        const fileMatch = content.match(/File: .*?([^\/\n]+)\s*$/m);
                        fileName = fileMatch ? fileMatch[1] : "";
                    }
                    // Generate a name based on title if no filename found
                    if (!fileName) {
                        const title = input.title || item.name || "Untitled";
                        const ext = this.getFileExtension(input.language);
                        fileName = `${title}${ext}`;
                    }
                    artifacts.push({
                        id: input.id,
                        title: fileName,
                        language: input.language,
                        content: content,
                        delta: input.new_str || input.old_str
                            ? { old: input.old_str || "", new: input.new_str || "" }
                            : undefined,
                        filePath: filePath || fileName,
                    });
                }
            });
        });
        return artifacts;
    }
    /**
     * Extracts file path from artifact content if present
     * @param content - Artifact content to search
     * @returns File path if found, undefined otherwise
     */
    static extractFilePath(content) {
        const filePathMatch = (0, PathExtractor_1.extractRelPath)(content);
        return filePathMatch;
    }
    /**
     * Converts artifacts to DocumentInfo format for DownloadTable
     * @param artifacts - Array of conversation artifacts
     * @returns Array of DocumentInfo objects
     */
    static convertArtifactsToDocumentInfo(artifacts) {
        const unique = new Map();
        // Keep only the latest version of each artifact
        artifacts.forEach((artifact) => {
            if (artifact.content) {
                unique.set(artifact.id, artifact);
            }
        });
        return Array.from(unique.values()).map((artifact) => ({
            fileName: artifact.title,
            filePath: artifact.filePath || artifact.title,
            content: artifact.content || "",
            isSelected: true,
            metadata: {
                language: artifact.language,
                id: artifact.id,
            },
        }));
    }
    /**
     * Displays conversation elements in the output element
     * @param docs - Documents to display
     * @param outputElement - Element to display documents in
     */
    static async displayConversation(docs, outputElement) {
        outputElement.innerHTML = "";
        const table = new DownloadTable_1.DownloadTable(outputElement, docs);
        table.render();
    }
    /**
     * Retrieves and displays the current conversation based on command options
     * @param options - Command options for the export
     * @param outputElement - Element to display the conversation in
     * @returns Promise that resolves when display is complete
     */
    static async displayCurrentConversation(options, outputElement) {
        try {
            const orgId = this.getOrganizationId();
            const conversationId = this.getConversationIdFromUrl();
            const conversation = await this.getConversation(orgId, conversationId, true);
            // Extract and process artifacts if requested
            if (options?.includeArtifacts) {
                const artifacts = this.extractArtifacts(conversation);
                const docs = this.convertArtifactsToDocumentInfo(artifacts);
                if (docs.length === 0) {
                    throw new Error("No artifacts found in conversation");
                }
                await this.displayConversation(docs, outputElement);
            }
            else {
                // Display conversation as a single document
                const content = this.conversationToMarkdown(conversation);
                const docs = [
                    {
                        fileName: `${conversation.name}.md`,
                        filePath: `conversations/${conversation.name}.md`,
                        content: content,
                        isSelected: true,
                    },
                ];
                await this.displayConversation(docs, outputElement);
            }
        }
        catch (error) {
            throw new Error(`Failed to display conversation: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Gets the organization ID from cookies
     * @throws Error if organization ID is not found or invalid
     */
    static getOrganizationId() {
        const cookie = document.cookie
            .split("; ")
            .find((row) => row.startsWith("lastActiveOrg="));
        if (!cookie) {
            throw new Error("Organization ID not found in cookies");
        }
        try {
            const value = decodeURIComponent(cookie.split("=")[1]);
            return value.replace(/^"|"$/g, "");
        }
        catch (error) {
            throw new Error("Invalid organization ID format in cookie");
        }
    }
    /**
     * Converts a conversation to markdown format
     * @param conversation - Conversation to convert
     * @returns Markdown string of the conversation
     */
    static conversationToMarkdown(conversation) {
        const sections = [];
        sections.push(`# ${conversation.name}\n`);
        conversation.chat_messages.forEach((message, index) => {
            sections.push(`## ${message.sender === "human" ? "Human" : "Assistant"}\n`);
            message.content.forEach((item) => {
                if (item.type === "text") {
                    sections.push(item.text || "");
                }
            });
            if (index < conversation.chat_messages.length - 1) {
                sections.push("\n---\n");
            }
        });
        return sections.join("\n");
    }
    /**
     * Gets current conversation details including latest message ID
     * @returns Promise resolving to { conversationId, parentMessageUuid }
     * @throws Error if conversation details cannot be retrieved
     */
    static async getCurrentConversationDetails() {
        // Get conversation ID from URL
        const conversationId = this.getConversationIdFromUrl();
        const orgId = (0, getClaudeIds_1.getOrganizationId)();
        try {
            // Get conversation details
            const conversation = await this.getConversation(orgId, conversationId, true);
            return {
                conversationId,
                parentMessageUuid: conversation.current_leaf_message_uuid,
            };
        }
        catch (error) {
            throw new Error(`Failed to get conversation details: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
}
exports.ConversationRetrieval = ConversationRetrieval;
ConversationRetrieval.API_URL = "https://api.claude.ai/api/organizations";
//# sourceMappingURL=ConversationRetrieval.js.map
```

## dist/src/services/DocumentDownload.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/services/DocumentDownload.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/services/DocumentDownload.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for handling document downloads with support for dynamic content retrieval
 * Note: Your friendly neighborhood file downloader!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentDownload = void 0;
class DocumentDownload {
    /**
     * Creates markdown content from multiple documents
     * @param docs - Array of documents to combine
     * @returns Promise resolving to markdown string
     */
    static async createMarkdownContent(docs) {
        const sections = [];
        const groupedDocs = this.groupDocumentsByDirectory(docs);
        sections.push("# src\n");
        for (const [directory, dirDocs] of Object.entries(groupedDocs)) {
            if (directory !== "" && Object.keys(groupedDocs).length > 1) {
                sections.push(`## ${directory}\n`);
            }
            for (const doc of dirDocs) {
                const extension = doc.fileName.split(".").pop() || "";
                const language = this.getLanguageFromExtension(extension);
                sections.push(`## ${doc.filePath}\n`);
                sections.push("```" + language);
                // Use contentCallback if available, otherwise use static content
                const content = doc.contentCallback
                    ? await doc.contentCallback(doc)
                    : doc.content;
                sections.push(content);
                sections.push("```\n");
            }
        }
        return sections.join("\n");
    }
    /**
     * Groups documents by their directory path
     * @param docs - Documents to group
     * @returns Record of directory paths to document arrays
     */
    static groupDocumentsByDirectory(docs) {
        const groups = {};
        docs.forEach((doc) => {
            const path = doc.filePath;
            const lastSlash = path.lastIndexOf("/");
            const directory = lastSlash > 0 ? path.substring(0, lastSlash) : "";
            if (!groups[directory]) {
                groups[directory] = [];
            }
            groups[directory].push(doc);
        });
        return Object.keys(groups)
            .sort()
            .reduce((obj, key) => {
            obj[key] = groups[key].sort((a, b) => a.fileName.localeCompare(b.fileName));
            return obj;
        }, {});
    }
    /**
     * Maps file extensions to language identifiers for syntax highlighting
     * @param extension - File extension without dot
     * @returns Language identifier string
     */
    static getLanguageFromExtension(extension) {
        const languageMap = {
            ts: "typescript",
            js: "javascript",
            jsx: "jsx",
            tsx: "tsx",
            css: "css",
            scss: "scss",
            html: "html",
            json: "json",
            md: "markdown",
            py: "python",
            rb: "ruby",
            java: "java",
            cpp: "cpp",
            c: "c",
            cs: "csharp",
            go: "go",
            rs: "rust",
            php: "php",
            sql: "sql",
            yaml: "yaml",
            yml: "yaml",
            xml: "xml",
            sh: "bash",
            bash: "bash",
            zsh: "bash",
            swift: "swift",
        };
        return languageMap[extension.toLowerCase()] || "";
    }
    /**
     * Initiates file download through Chrome extension
     * @param content - Content to download
     * @param filename - Name for downloaded file
     */
    static downloadContent(content, filename) {
        const blob = new Blob([content], { type: "text/markdown" });
        const url = URL.createObjectURL(blob);
        try {
            chrome.runtime.sendMessage({
                type: "download",
                url: url,
                filename: filename,
            }, (response) => {
                if (!response.success) {
                    console.error("Download failed:", response.error);
                    alert("Failed to start download. Please try again.");
                }
            });
        }
        finally {
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }
    }
    /**
     * Downloads selected documents as a single markdown file
     * @param selectedDocs - Array of documents to download
     * @throws Error if no documents selected or download fails
     */
    static async handleSingleDownload(selectedDocs) {
        if (selectedDocs.length === 0) {
            throw new Error("No documents selected for export");
        }
        try {
            const markdownContent = await this.createMarkdownContent(selectedDocs);
            const timestamp = new Date()
                .toISOString()
                .replace(/[:]/g, "-")
                .split(".")[0];
            const filename = `claude-export-${timestamp}.md`;
            this.downloadContent(markdownContent, filename);
        }
        catch (error) {
            throw new Error(`Failed to export documents: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Downloads each selected document as a separate file
     * @param selectedDocs - Array of documents to download
     * @throws Error if no documents selected or download fails
     */
    static async handleMultipleDownload(selectedDocs) {
        if (selectedDocs.length === 0) {
            throw new Error("No documents selected for export");
        }
        try {
            for (const doc of selectedDocs) {
                const extension = doc.fileName.split(".").pop() || "";
                const language = this.getLanguageFromExtension(extension);
                // Use contentCallback if available, otherwise use static content
                const content = doc.contentCallback
                    ? await doc.contentCallback(doc)
                    : doc.content;
                const formattedContent = ["```" + language, content, "```"].join("\n");
                const filename = doc.filePath.split("/").pop() || "untitled.md";
                this.downloadContent(formattedContent, filename);
            }
        }
        catch (error) {
            throw new Error(`Failed to export documents: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
}
exports.DocumentDownload = DocumentDownload;
//# sourceMappingURL=DocumentDownload.js.map
```

## dist/src/services/DocumentRetrieval.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/services/DocumentRetrieval.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
// Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
// This software is licensed under the MIT License.
// File: src/services/DocumentRetrieval.ts
// Service for retrieving Claude-generated documents
// Note: Like a librarian for your AI's creative works!
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentRetrieval = void 0;
const DownloadTable_1 = require("../ui/components/DownloadTable");
const getClaudeIds_1 = require("../utils/getClaudeIds");
const ClaudeCache_1 = require("./ClaudeCache");
const PathExtractor_1 = require("@/utils/PathExtractor");
class DocumentRetrieval {
    /**
     * Fetches available documents from the API with caching
     * @param forceRefresh Force refresh from API instead of cache
     * @throws Error if documents cannot be retrieved
     */
    static async fetchDocuments(forceRefresh = false) {
        try {
            const organizationId = (0, getClaudeIds_1.getOrganizationId)();
            const projectUuid = await (0, getClaudeIds_1.getProjectUuid)(organizationId);
            const url = `${this.API_URL}/${organizationId}/projects/${projectUuid}/docs`;
            const data = await ClaudeCache_1.ClaudeCache.fetchWithCache(url, {
                timeoutMs: 300000, // Cache documents for 5 minutes
                forceRefresh,
            });
            return this.processDocuments(data);
        }
        catch (error) {
            throw new Error(`Error fetching documents: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Displays documents in the provided output element
     * @param docs - Documents to display
     * @param outputElement - Element to display documents in
     */
    static async displayDocuments(docs, outputElement) {
        outputElement.innerHTML = "";
        const table = new DownloadTable_1.DownloadTable(outputElement, docs);
        table.render();
    }
    /**
     * Processes raw document data into DocumentInfo objects
     * @param data - Raw document data from API
     * @returns Processed document information
     */
    static processDocuments(data) {
        return data.map((doc) => {
            const filePathMatch = (0, PathExtractor_1.extractRelPath)(doc.content);
            const isGenerated = doc.content?.includes("This was generated by Claude Sonnet");
            return {
                fileName: doc.file_name,
                filePath: filePathMatch?.[1] || doc.file_name,
                content: doc.content || "",
                isSelected: isGenerated,
            };
        });
    }
}
exports.DocumentRetrieval = DocumentRetrieval;
DocumentRetrieval.API_URL = "https://api.claude.ai/api/organizations";
//# sourceMappingURL=DocumentRetrieval.js.map
```

## dist/src/services/ProjectRetrieval.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/services/ProjectRetrieval.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
// Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
// This software is licensed under the MIT License.
// File: src/services/ProjectRetrieval.ts
// Service for retrieving and managing Claude project data
// Note: The project manager that keeps your conversations organized!
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectRetrieval = void 0;
const getClaudeIds_1 = require("../utils/getClaudeIds");
const DownloadTable_1 = require("../ui/components/DownloadTable");
const ConversationRetrieval_1 = require("./ConversationRetrieval");
const ClaudeCache_1 = require("./ClaudeCache");
/**
 * Service for managing Claude projects and their conversations
 */
class ProjectRetrieval {
    /**
     * Retrieves all conversations in the current project with caching
     * @param forceRefresh Force refresh from API instead of cache
     * @returns Promise resolving to array of project conversations
     * @throws Error if retrieval fails
     */
    static async getProjectConversations(forceRefresh = false) {
        try {
            const orgId = (0, getClaudeIds_1.getOrganizationId)();
            const projectId = await (0, getClaudeIds_1.getProjectUuid)(orgId);
            const url = `${this.API_URL}/${orgId}/projects/${projectId}/conversations`;
            return await ClaudeCache_1.ClaudeCache.fetchWithCache(url, {
                timeoutMs: 120000, // Cache project conversations for 2 minutes
                forceRefresh,
            });
        }
        catch (error) {
            throw new Error(`Error retrieving project conversations: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Converts conversations to DocumentInfo format for DownloadTable
     * @param conversations - Array of project conversations
     * @returns Array of DocumentInfo objects
     */
    static convertConversationsToDocumentInfo(conversations) {
        return conversations.map((conversation) => ({
            metadata: {
                conversationId: conversation.uuid,
                url: `https://claude.ai/chat/${conversation.uuid}`,
            },
            contentCallback: async (doc) => {
                const orgId = (0, getClaudeIds_1.getOrganizationId)();
                // Use cached conversation retrieval with force refresh for previews
                const conv = await ConversationRetrieval_1.ConversationRetrieval.getConversation(orgId, conversation.uuid, true);
                return ConversationRetrieval_1.ConversationRetrieval.conversationToMarkdown(conv);
            },
            fileName: conversation.name,
            filePath: `${conversation.name.replace(/\s+/g, "-")}.md`,
            content: this.createConversationSummary(conversation),
            isSelected: false,
        }));
    }
    /**
     * Creates a markdown summary of a conversation
     * @param conversation - Conversation to summarize
     * @returns Markdown formatted summary
     */
    static createConversationSummary(conversation) {
        const sections = [];
        sections.push(`# ${conversation.name}\n`);
        sections.push(`UUID: ${conversation.uuid}`);
        sections.push(`Created: ${new Date(conversation.created_at).toLocaleString()}`);
        sections.push(`Updated: ${new Date(conversation.updated_at).toLocaleString()}`);
        sections.push(`\nMessage Count: ${conversation.message_count}`);
        if (conversation.summary) {
            sections.push(`\n## Summary\n${conversation.summary}`);
        }
        return sections.join("\n");
    }
    /**
     * Displays project conversations in the output element
     * @param docs - Documents to display
     * @param outputElement - Element to display documents in
     */
    static async displayConversations(docs, outputElement) {
        outputElement.innerHTML = "";
        const table = new DownloadTable_1.DownloadTable(outputElement, docs);
        table.render();
    }
    /**
     * Retrieves and displays conversations in the current project
     * @param outputElement - Element to display the conversations in
     * @param forceRefresh Force refresh from API instead of cache
     * @returns Promise that resolves when display is complete
     */
    static async displayCurrentProject(outputElement, forceRefresh = false) {
        try {
            const conversations = await this.getProjectConversations(forceRefresh);
            const docs = this.convertConversationsToDocumentInfo(conversations);
            if (docs.length === 0) {
                throw new Error("No conversations found in project");
            }
            await this.displayConversations(docs, outputElement);
        }
        catch (error) {
            throw new Error(`Failed to display project conversations: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
}
exports.ProjectRetrieval = ProjectRetrieval;
ProjectRetrieval.API_URL = "https://api.claude.ai/api/organizations";
//# sourceMappingURL=ProjectRetrieval.js.map
```

## dist/src/services/ProjectSearchService.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/services/ProjectSearchService.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/services/ProjectSearchService.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for searching through project conversations using semantic search
 * Note: Finding needles in conversational haystacks!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectSearchService = void 0;
const ProjectRetrieval_1 = require("./ProjectRetrieval");
const ConversationRetrieval_1 = require("./ConversationRetrieval");
const getClaudeIds_1 = require("../utils/getClaudeIds");
const getHeaders_1 = require("../utils/getHeaders");
class ProjectSearchService {
    /**
     * Searches project conversations and returns DocumentInfo entries with search results
     * @param searchText - Optional text to search for
     * @param outputElement - Element to display results in
     */
    static async searchAndDisplayResults(searchText, outputElement) {
        try {
            // Get project conversations first
            const conversations = await ProjectRetrieval_1.ProjectRetrieval.getProjectConversations(true);
            let searchResults = [];
            // If search text provided, get detailed conversations and search
            if (searchText) {
                const detailedConversations = await this.getDetailedConversations(conversations);
                searchResults = await this.performSearch(searchText, detailedConversations);
            }
            // Convert to DocumentInfo format with search results
            const docs = await this.createDocumentInfo(conversations, searchResults);
            // Display using existing table component
            await ProjectRetrieval_1.ProjectRetrieval.displayConversations(docs, outputElement);
        }
        catch (error) {
            throw new Error(`Search failed: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Retrieves detailed conversation data for each conversation
     * @param conversations - List of project conversations
     * @returns Array of detailed conversations
     */
    static async getDetailedConversations(conversations) {
        const orgId = (0, getClaudeIds_1.getOrganizationId)();
        const detailedConversations = [];
        for (const conv of conversations) {
            try {
                const conversation = await ConversationRetrieval_1.ConversationRetrieval.getConversation(orgId, conv.uuid, true);
                detailedConversations.push(conversation);
            }
            catch (error) {
                console.error(`Failed to get conversation ${conv.uuid}:`, error);
                // Continue with other conversations
            }
        }
        return detailedConversations;
    }
    /**
     * Makes a completion request to search conversations
     * @param prompt - Prompt to send to Claude
     * @returns Promise resolving to completion response
     */
    static async makeCompletionRequest(prompt) {
        try {
            // Get current conversation details
            const orgId = (0, getClaudeIds_1.getOrganizationId)();
            const { conversationId, parentMessageUuid } = await ConversationRetrieval_1.ConversationRetrieval.getCurrentConversationDetails();
            // Build request
            const endpoint = `${this.API_URL}/${orgId}/chat_conversations/${conversationId}/completion`;
            const response = await fetch(`${endpoint}?rendering_mode=json`, {
                method: "POST",
                headers: (0, getHeaders_1.getHeaders)(),
                credentials: "include",
                body: JSON.stringify({
                    prompt,
                    timezone: "America/Toronto",
                    attachments: [],
                    files: [],
                    sync_sources: [],
                    rendering_mode: "json",
                    parent_message_uuid: parentMessageUuid,
                }),
            });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return await response.json();
        }
        catch (error) {
            throw new Error(`Completion request failed: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Filters and formats message content for search
     * @param message - Chat message to process
     * @returns Filtered message text content
     */
    static formatMessageContent(message) {
        return message.content
            .filter((content) => {
            // Only include text content, exclude tools and artifacts
            return (content.type === "text" &&
                content.text &&
                !content.text.includes("antml:function_calls") &&
                !content.text.includes("antArtifact"));
        })
            .map((content) => content.text)
            .join("\n");
    }
    /**
     * Performs semantic search across conversations
     * @param searchText - Text to search for
     * @param conversations - Array of conversations to search
     * @returns Search results for matching conversations
     */
    static async performSearch(searchText, conversations) {
        // Build conversation summaries for the prompt, excluding artifacts and tools
        const summaries = conversations.map((conv) => ({
            id: conv.uuid,
            name: conv.name,
            messages: conv.chat_messages
                .filter((msg) => {
                // Only include messages that have actual text content after filtering
                const content = this.formatMessageContent(msg);
                return content.trim().length > 0;
            })
                .map((msg) => ({
                id: msg.uuid,
                sender: msg.sender,
                content: this.formatMessageContent(msg),
            })),
        }));
        // Create the search prompt
        const prompt = `Here are the summaries of conversations. Please find the conversations contain information that satisfy this search criteria and output a JSON array of SearchResultInfo: "${searchText}"

${JSON.stringify(summaries, null, 2)}

Return the results as a JSON array of SearchResultInfo objects with this TypeScript type:
interface SearchResultInfo {
  conversationId: string;     // ID of the matching conversation
  messageId: string;          // UUID of the specific message that matches
  matchReason: string;        // Clear explanation of why this conversation matches
  relevantSnippet: string;    // The specific text snippet that matches (max 200 chars)
}

Only include conversations that have relevant matches. Format the matchReason as a clear, concise explanation.`;
        try {
            const response = await this.makeCompletionRequest(prompt);
            const results = JSON.parse(response.completion);
            // Basic validation of required fields
            if (!Array.isArray(results) ||
                results.some((r) => !r.conversationId ||
                    !r.messageId ||
                    !r.matchReason ||
                    !r.relevantSnippet)) {
                throw new Error("Invalid search result format from API");
            }
            return results;
        }
        catch (error) {
            throw new Error(`Search analysis failed: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
    }
    /**
     * Creates DocumentInfo objects with search results
     * @param conversations - Project conversations
     * @param searchResults - Search results to incorporate
     * @returns Array of DocumentInfo objects
     */
    static async createDocumentInfo(conversations, searchResults) {
        // Create a map of search results by conversation ID
        const resultMap = new Map(searchResults.map((result) => [result.conversationId, result]));
        return conversations.map((conversation) => {
            const searchResult = resultMap.get(conversation.uuid);
            return {
                fileName: conversation.name,
                filePath: `${conversation.name.replace(/\s+/g, "-")}.md`,
                content: conversation.summary || "",
                isSelected: !!searchResult, // Pre-select conversations with matches
                metadata: {
                    conversationId: conversation.uuid,
                    url: `https://claude.ai/chat/${conversation.uuid}`,
                },
                searchResult,
                contentCallback: async (doc) => {
                    const orgId = (0, getClaudeIds_1.getOrganizationId)();
                    const conv = await ConversationRetrieval_1.ConversationRetrieval.getConversation(orgId, conversation.uuid, true);
                    return ConversationRetrieval_1.ConversationRetrieval.conversationToMarkdown(conv);
                },
            };
        });
    }
}
exports.ProjectSearchService = ProjectSearchService;
ProjectSearchService.API_URL = "https://api.claude.ai/api/organizations";
//# sourceMappingURL=ProjectSearchService.js.map
```

## dist/src/services/ScriptRunner.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/services/ScriptRunner.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/*
 * Copyright (c) 2024 Martin Bechard (martin.bechard@DevConsult.ca)
 * This software is licensed under the MIT License.
 * File: src/services/ScriptRunner.ts
 * Credit: This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 * Summary: Service for executing scripts and managing script execution state
 * Witty remark: Running scripts like a marathon runner, but with better error handling!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptRunner = void 0;
/**
 * Manages script execution and streaming state.
 */
class ScriptRunner {
    constructor(logCallback) {
        this.isRunning = false;
        this.MAX_ATTEMPTS = 300;
        this.CHECK_INTERVAL = 100;
        this.logCallback = logCallback;
    }
    /**
     * Executes a script with the provided configuration.
     * @param script - Script configuration to execute
     * @throws Error if script execution fails
     */
    async runScript(script) {
        if (this.isRunning) {
            throw new Error("Script is already running");
        }
        try {
            this.isRunning = true;
            this.logCallback(`Executing script with ${script.maxTries} maximum tries`);
            const targetDiv = await this.findInputElement();
            await this.executeScriptContent(script, targetDiv);
        }
        catch (error) {
            this.logCallback(`Script execution failed: ${error instanceof Error ? error.message : "Unknown error"}`, "error");
            throw error;
        }
        finally {
            this.isRunning = false;
        }
    }
    /**
     * Monitors the streaming state of Claude's response.
     * @returns The final response text
     * @throws Error if monitoring times out
     */
    async checkStreaming() {
        let stableCount = 0;
        let attempts = 0;
        let lastContent = "";
        let lastStreamingDiv = null;
        while (attempts < this.MAX_ATTEMPTS && this.isRunning) {
            const streamingDiv = document.querySelector('div[data-is-streaming="true"]');
            if (streamingDiv) {
                if (streamingDiv.textContent !== lastContent) {
                    stableCount = 0;
                    lastContent = streamingDiv.textContent || "";
                    lastStreamingDiv = streamingDiv;
                }
                else {
                    stableCount++;
                }
            }
            else if (lastStreamingDiv) {
                return lastStreamingDiv.textContent || "";
            }
            else {
                stableCount++;
            }
            if (stableCount >= 20) {
                return lastContent;
            }
            await new Promise((resolve) => setTimeout(resolve, this.CHECK_INTERVAL));
            attempts++;
        }
        if (!this.isRunning) {
            throw new Error("Operation cancelled");
        }
        throw new Error("Response timeout");
    }
    /**
     * Finds the input element for script execution.
     * @returns Promise resolving to the input element
     * @throws Error if element not found
     */
    async findInputElement() {
        const targetDiv = document.querySelector('div[enterkeyhint="enter"]');
        if (!targetDiv) {
            throw new Error("Input element not found");
        }
        return targetDiv;
    }
    /**
     * Executes the content of a script.
     * @param script - Script to execute
     * @param targetDiv - Element to input the script
     */
    async executeScriptContent(script, targetDiv) {
        targetDiv.innerHTML = `<p>${script.prompt}</p>`;
        targetDiv.focus();
        await new Promise((resolve) => setTimeout(resolve, 100));
        await this.simulateEnterKey(targetDiv);
        const response = await this.checkStreaming();
        if (script.findText && !response.includes(script.findText)) {
            throw new Error(`Text "${script.findText}" not found in response`);
        }
    }
    /**
     * Simulates pressing the Enter key.
     * @param element - Element to receive the key event
     */
    simulateEnterKey(element) {
        const events = [
            new KeyboardEvent("keydown", {
                key: "Enter",
                code: "Enter",
                keyCode: 13,
                which: 13,
                bubbles: true,
            }),
            new KeyboardEvent("keypress", {
                key: "Enter",
                code: "Enter",
                keyCode: 13,
                which: 13,
                bubbles: true,
            }),
            new KeyboardEvent("keyup", {
                key: "Enter",
                code: "Enter",
                keyCode: 13,
                which: 13,
                bubbles: true,
            }),
        ];
        events.forEach((event) => element.dispatchEvent(event));
    }
    /**
     * Cancels the currently running script.
     */
    cancel() {
        this.isRunning = false;
    }
}
exports.ScriptRunner = ScriptRunner;
//# sourceMappingURL=ScriptRunner.js.map
```

## dist/src/types/index.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/types/index.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/types/index.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Type definitions for the Claude Extension
 * Note: Making TypeScript happy, one interface at a time!
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map
```

## dist/src/ui/components/ConversationPreview.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/ui/components/ConversationPreview.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/ConversationPreview.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * A popup dialog component for previewing conversations
 * Note: Making chat previews without any framework dependencies!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConversationPreview = void 0;
class ConversationPreview {
    constructor() {
        this.dialog = document.createElement("div");
        this.content = document.createElement("div");
        this.isOpen = false;
        this.createDialog();
    }
    /**
     * Creates the dialog structure
     */
    createDialog() {
        // Create container with semi-transparent background
        this.dialog.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000000;
    `;
        // Create dialog content container
        this.content.style.cssText = `
      background: white;
      border-radius: 8px;
      width: 500px;
      max-width: 90%;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      position: relative;
    `;
        this.dialog.appendChild(this.content);
        document.body.appendChild(this.dialog);
        // Close on background click
        this.dialog.addEventListener("click", (e) => {
            if (e.target === this.dialog) {
                this.close();
            }
        });
        // Close on escape key
        document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && this.isOpen) {
                this.close();
            }
        });
    }
    /**
     * Creates a message bubble element
     */
    createMessageBubble(message) {
        const isHuman = message.sender === "human";
        const container = document.createElement("div");
        container.style.cssText = `
      display: flex;
      justify-content: ${isHuman ? "flex-end" : "flex-start"};
      margin-bottom: 16px;
    `;
        const bubble = document.createElement("div");
        bubble.style.cssText = `
      max-width: 80%;
      padding: 8px 16px;
      border-radius: 12px;
      ${isHuman
            ? `
        background: #0066cc;
        color: white;
        border-bottom-right-radius: 4px;
      `
            : `
        background: #f0f0f0;
        color: #333;
        border-bottom-left-radius: 4px;
      `}
    `;
        // Add message content
        message.content.forEach((item) => {
            if (item.type === "text" && item.text) {
                const textDiv = document.createElement("div");
                textDiv.style.whiteSpace = "pre-wrap";
                textDiv.textContent = item.text;
                bubble.appendChild(textDiv);
            }
        });
        container.appendChild(bubble);
        return container;
    }
    /**
     * Shows the preview dialog with conversation content
     */
    show(title, messages, conversationUrl) {
        // Reset content
        this.content.innerHTML = "";
        // Create header
        const header = document.createElement("div");
        header.style.cssText = `
      padding: 16px 20px;
      border-bottom: 1px solid #e5e5e5;
    `;
        const titleElement = document.createElement("h2");
        titleElement.style.cssText = `
      margin: 0;
      font-size: 18px;
      font-weight: 600;
      color: #333;
    `;
        // Make title a link if URL is provided
        if (conversationUrl) {
            const titleLink = document.createElement("a");
            titleLink.href = conversationUrl;
            titleLink.target = "_blank";
            titleLink.textContent = title;
            titleLink.style.cssText = `
        color: inherit;
        text-decoration: none;
        transition: color 0.2s ease;
      `;
            titleLink.addEventListener("mouseover", () => {
                titleLink.style.color = "#0066cc";
            });
            titleLink.addEventListener("mouseout", () => {
                titleLink.style.color = "#333";
            });
            titleElement.appendChild(titleLink);
        }
        else {
            titleElement.textContent = title;
        }
        const subtitle = document.createElement("div");
        subtitle.style.cssText = `
      font-size: 14px;
      color: #666;
      margin-top: 4px;
    `;
        subtitle.textContent = `${messages.length} messages in conversation`;
        header.appendChild(titleElement);
        header.appendChild(subtitle);
        // Create close button
        const closeButton = document.createElement("button");
        closeButton.innerHTML = "";
        closeButton.style.cssText = `
      position: absolute;
      top: 12px;
      right: 12px;
      font-size: 24px;
      border: none;
      background: none;
      color: #666;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
    `;
        closeButton.addEventListener("mouseover", () => {
            closeButton.style.backgroundColor = "#f0f0f0";
        });
        closeButton.addEventListener("mouseout", () => {
            closeButton.style.backgroundColor = "transparent";
        });
        closeButton.addEventListener("click", () => this.close());
        // Create messages container
        const messagesContainer = document.createElement("div");
        messagesContainer.style.cssText = `
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      min-height: 200px;
      max-height: calc(80vh - 100px);
    `;
        // Add messages
        messages.forEach((message) => {
            messagesContainer.appendChild(this.createMessageBubble(message));
        });
        // Assemble dialog
        this.content.appendChild(closeButton);
        this.content.appendChild(header);
        this.content.appendChild(messagesContainer);
        // Show dialog with animation
        this.dialog.style.display = "flex";
        this.dialog.style.opacity = "0";
        setTimeout(() => {
            this.dialog.style.transition = "opacity 0.2s ease-out";
            this.dialog.style.opacity = "1";
        }, 0);
        this.isOpen = true;
        // Scroll to bottom of messages
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    /**
     * Closes the preview dialog
     */
    close() {
        if (!this.isOpen)
            return;
        this.dialog.style.opacity = "0";
        setTimeout(() => {
            this.dialog.style.display = "none";
            this.content.innerHTML = "";
        }, 200);
        this.isOpen = false;
    }
    /**
     * Cleans up the component
     */
    destroy() {
        this.dialog.remove();
    }
}
exports.ConversationPreview = ConversationPreview;
//# sourceMappingURL=ConversationPreview.js.map
```

## dist/src/ui/components/DownloadTable.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/ui/components/DownloadTable.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/ui/components/DownloadTable.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * A reusable component for displaying and managing downloadable documents.
 * Note: Making downloads as easy as clicking a button - no more 404 nightmares!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DownloadTable = void 0;
const DocumentDownload_1 = require("../../services/DocumentDownload");
const ConversationPreview_1 = require("./ConversationPreview");
const ConversationRetrieval_1 = require("../../services/ConversationRetrieval");
const getClaudeIds_1 = require("../../utils/getClaudeIds");
const DownloadWidgets_1 = require("./DownloadWidgets");
/**
 * Component for displaying and managing downloadable documents in a table format
 */
class DownloadTable {
    constructor(container, items, showResults = false) {
        this.container = container;
        this.items = items;
        this.previewDialog = new ConversationPreview_1.ConversationPreview();
        this.showResults = showResults;
    }
    getTableHeaders() {
        const baseHeaders = [
            { id: "checkbox", label: "", width: "40px" },
            { id: "fileName", label: "Name" },
        ];
        if (this.showResults) {
            baseHeaders.push({ id: "searchResult", label: "Results" });
        }
        baseHeaders.push({ id: "filePath", label: "Path" });
        return baseHeaders;
    }
    createTable() {
        const table = document.createElement("table");
        table.style.width = "100%";
        table.style.borderCollapse = "collapse";
        table.style.marginTop = "10px";
        return table;
    }
    createTableHeader() {
        const header = document.createElement("thead");
        const headerRow = document.createElement("tr");
        this.getTableHeaders().forEach((config) => {
            const th = (0, DownloadWidgets_1.createTableCell)(true);
            if (config.width) {
                th.style.width = config.width;
            }
            if (config.id === "checkbox") {
                const checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.addEventListener("change", (e) => {
                    const target = e.target;
                    const table = target.closest("table");
                    if (table) {
                        const checkboxes = table.querySelectorAll('tbody input[type="checkbox"]');
                        checkboxes.forEach((cb) => (cb.checked = target.checked));
                    }
                });
                th.appendChild(checkbox);
            }
            else {
                th.textContent = config.label;
            }
            headerRow.appendChild(th);
        });
        header.appendChild(headerRow);
        return header;
    }
    async handlePreview(item) {
        if (!item.metadata?.conversationId)
            return;
        try {
            const orgId = (0, getClaudeIds_1.getOrganizationId)();
            const conversation = await ConversationRetrieval_1.ConversationRetrieval.getConversation(orgId, item.metadata.conversationId);
            this.previewDialog.show(item.fileName, conversation.chat_messages, item.metadata.url);
        }
        catch (error) {
            console.error("Failed to load conversation preview:", error);
            alert("Failed to load conversation preview");
        }
    }
    createItemRow(item) {
        const row = document.createElement("tr");
        row.style.borderBottom = "1px solid #ccc";
        // Checkbox cell
        row.appendChild((0, DownloadWidgets_1.createCheckboxCell)(item.isSelected));
        // Name cell with preview
        const onPreview = item.metadata?.conversationId
            ? () => this.handlePreview(item)
            : undefined;
        row.appendChild((0, DownloadWidgets_1.createNameCell)(item.fileName, item.metadata?.url, onPreview));
        // Results cell (if enabled)
        if (this.showResults) {
            row.appendChild((0, DownloadWidgets_1.createSearchResultCell)(item.searchResult));
        }
        // Path cell
        const pathCell = (0, DownloadWidgets_1.createTableCell)();
        pathCell.textContent = item.filePath;
        row.appendChild(pathCell);
        return row;
    }
    addDownloadButtons() {
        const buttonContainer = (0, DownloadWidgets_1.createButtonContainer)();
        const downloadSelectedButton = (0, DownloadWidgets_1.createButton)("Download Selected", () => this.handleDownload(false));
        const downloadBundleButton = (0, DownloadWidgets_1.createButton)("Download as Bundle", () => this.handleDownload(true));
        buttonContainer.appendChild(downloadSelectedButton);
        buttonContainer.appendChild(downloadBundleButton);
        this.container.appendChild(buttonContainer);
    }
    async handleDownload(asBundle) {
        const table = this.container.querySelector("table");
        if (!table)
            return;
        const selectedItems = [];
        const checkboxes = table.querySelectorAll('tbody input[type="checkbox"]');
        checkboxes.forEach((checkbox, index) => {
            if (checkbox.checked) {
                selectedItems.push(this.items[index]);
            }
        });
        if (selectedItems.length === 0) {
            alert("Please select items to download");
            return;
        }
        try {
            if (asBundle) {
                await DocumentDownload_1.DocumentDownload.handleSingleDownload(selectedItems);
            }
            else {
                await DocumentDownload_1.DocumentDownload.handleMultipleDownload(selectedItems);
            }
        }
        catch (error) {
            console.error("Download failed:", error);
            alert("Download failed: " +
                (error instanceof Error ? error.message : "Unknown error"));
        }
    }
    render() {
        this.container.innerHTML = "";
        if (this.items.length === 0) {
            this.container.appendChild((0, DownloadWidgets_1.createEmptyState)("No documents found"));
            return;
        }
        const table = this.createTable();
        const headerRow = this.createTableHeader();
        table.appendChild(headerRow);
        const tbody = table.createTBody();
        this.items.forEach((item) => {
            const row = this.createItemRow(item);
            tbody.appendChild(row);
        });
        this.container.appendChild(table);
        this.addDownloadButtons();
    }
    destroy() {
        this.container.innerHTML = "";
        this.previewDialog.destroy();
    }
}
exports.DownloadTable = DownloadTable;
//# sourceMappingURL=DownloadTable.js.map
```

## dist/src/ui/components/DownloadWidgets.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/ui/components/DownloadWidgets.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/DownloadWidgets.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * UI widget utilities for the download table components
 * Note: Making UI elements as reusable as Lego blocks!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPreviewIcon = createPreviewIcon;
exports.createButton = createButton;
exports.createLink = createLink;
exports.createPreviewButton = createPreviewButton;
exports.createButtonContainer = createButtonContainer;
exports.createTableCell = createTableCell;
exports.createCheckboxCell = createCheckboxCell;
exports.createEmptyState = createEmptyState;
exports.createNameCell = createNameCell;
exports.createSearchResultCell = createSearchResultCell;
// Base styles that can be used across components
const styles = {
    colors: {
        primary: "#0066cc",
        primaryHover: "#0052a3",
        border: "#ccc",
        text: "#333",
        textMuted: "#666",
        background: "#f8f9fa",
        backgroundMuted: "#dee2e6",
    },
    spacing: {
        sm: "4px",
        md: "8px",
        lg: "12px",
        xl: "16px",
    },
    borderRadius: "4px",
    fontSize: {
        sm: "12px",
        md: "14px",
        lg: "16px",
    },
};
/**
 * Creates a preview (eye) icon SVG element
 */
function createPreviewIcon({ size = 16, color = styles.colors.textMuted, } = {}) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", size.toString());
    svg.setAttribute("height", size.toString());
    svg.setAttribute("viewBox", "0 0 24 24");
    svg.setAttribute("fill", "none");
    svg.setAttribute("stroke", color);
    svg.setAttribute("stroke-width", "2");
    svg.innerHTML = `
      <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
      <circle cx="12" cy="12" r="3"></circle>
    `;
    return svg;
}
/**
 * Creates a styled button element
 */
function createButton(text, onClick, options = {}) {
    const button = document.createElement("button");
    button.textContent = text;
    const baseStyles = `
      cursor: pointer;
      border: none;
      font-size: ${styles.fontSize.md};
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    `;
    let variantStyles = "";
    switch (options.variant) {
        case "secondary":
            variantStyles = `
          background: ${styles.colors.background};
          color: ${styles.colors.text};
          padding: ${styles.spacing.md} ${styles.spacing.xl};
          border-radius: ${styles.borderRadius};
          border: 1px solid ${styles.colors.border};
        `;
            break;
        case "icon":
            variantStyles = `
          background: none;
          color: ${styles.colors.textMuted};
          padding: ${styles.spacing.sm};
        `;
            break;
        default: // primary
            variantStyles = `
          background: ${styles.colors.primary};
          color: white;
          padding: ${styles.spacing.md} ${styles.spacing.xl};
          border-radius: ${styles.borderRadius};
        `;
    }
    button.style.cssText = baseStyles + variantStyles;
    // Add hover effects
    button.addEventListener("mouseover", () => {
        if (options.variant === "icon") {
            button.style.color = styles.colors.primary;
        }
        else if (options.variant === "secondary") {
            button.style.backgroundColor = styles.colors.backgroundMuted;
        }
        else {
            button.style.backgroundColor = styles.colors.primaryHover;
        }
    });
    button.addEventListener("mouseout", () => {
        if (options.variant === "icon") {
            button.style.color = styles.colors.textMuted;
        }
        else if (options.variant === "secondary") {
            button.style.backgroundColor = styles.colors.background;
        }
        else {
            button.style.backgroundColor = styles.colors.primary;
        }
    });
    button.addEventListener("click", onClick);
    return button;
}
/**
 * Creates a styled link element
 */
function createLink(text, url) {
    const link = document.createElement("a");
    link.href = url;
    link.textContent = text;
    link.target = "_blank";
    link.style.cssText = `
      color: ${styles.colors.primary};
      text-decoration: none;
      margin-right: ${styles.spacing.md};
      font-size: ${styles.fontSize.md};
    `;
    link.addEventListener("mouseover", () => {
        link.style.textDecoration = "underline";
    });
    link.addEventListener("mouseout", () => {
        link.style.textDecoration = "none";
    });
    return link;
}
/**
 * Creates a preview button with icon
 */
function createPreviewButton(onClick) {
    const button = createButton("", onClick, { variant: "icon" });
    button.title = "Preview conversation";
    button.appendChild(createPreviewIcon());
    return button;
}
/**
 * Creates a container for buttons with consistent styling
 */
function createButtonContainer() {
    const container = document.createElement("div");
    container.style.cssText = `
      display: flex;
      gap: ${styles.spacing.md};
      margin-top: ${styles.spacing.lg};
    `;
    return container;
}
/**
 * Creates a styled table cell
 */
function createTableCell(isHeader = false) {
    const cell = document.createElement(isHeader ? "th" : "td");
    cell.style.cssText = `
      padding: ${styles.spacing.md};
      border: 1px solid ${styles.colors.border};
      ${isHeader
        ? `
        background-color: ${styles.colors.background};
        font-weight: 600;
      `
        : ""}
    `;
    return cell;
}
/**
 * Creates a checkbox cell with consistent styling
 */
function createCheckboxCell(isChecked = false) {
    const cell = createTableCell();
    cell.style.textAlign = "center";
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.checked = isChecked;
    cell.appendChild(checkbox);
    return cell;
}
/**
 * Creates a styled empty state message
 */
function createEmptyState(message) {
    const container = document.createElement("div");
    container.style.cssText = `
      text-align: center;
      padding: ${styles.spacing.xl};
      color: ${styles.colors.textMuted};
      background-color: ${styles.colors.background};
      border: 1px solid ${styles.colors.backgroundMuted};
      border-radius: ${styles.borderRadius};
      margin-top: ${styles.spacing.lg};
    `;
    container.textContent = message;
    return container;
}
/**
 * Creates a name cell with optional link and preview button
 */
function createNameCell(name, url, onPreview) {
    const cell = createTableCell();
    // Create container for inline elements
    const container = document.createElement("div");
    container.style.cssText = `
      display: flex;
      align-items: center;
      gap: ${styles.spacing.md};
    `;
    if (url) {
        // Add link
        container.appendChild(createLink(name, url));
        // If we have a URL, this is a conversation so add preview button
        if (onPreview) {
            container.appendChild(createPreviewButton(onPreview));
        }
    }
    else {
        const text = document.createElement("span");
        text.textContent = name;
        container.appendChild(text);
    }
    cell.appendChild(container);
    return cell;
}
/**
 * Creates a cell displaying search result information with expandable content
 */
function createSearchResultCell(searchResult) {
    const cell = createTableCell();
    if (!searchResult) {
        return cell;
    }
    const container = document.createElement("div");
    container.style.cssText = `
      display: flex;
      flex-direction: column;
      gap: ${styles.spacing.sm};
      max-width: 400px;
      min-width: 200px;
    `;
    // Add match reason with truncation
    const reasonContainer = document.createElement("div");
    reasonContainer.style.cssText = `
      position: relative;
      overflow: hidden;
    `;
    const reason = document.createElement("div");
    reason.textContent = searchResult.matchReason;
    reason.style.cssText = `
      font-size: ${styles.fontSize.sm};
      color: ${styles.colors.text};
      line-height: 1.4;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2;
      overflow: hidden;
    `;
    reasonContainer.appendChild(reason);
    // Add snippet with expandable container
    const snippetContainer = document.createElement("div");
    snippetContainer.style.cssText = `
      position: relative;
      overflow: hidden;
      transition: max-height 0.3s ease-out;
      max-height: 48px;
    `;
    const snippet = document.createElement("div");
    snippet.textContent = searchResult.relevantSnippet;
    snippet.style.cssText = `
      font-size: ${styles.fontSize.sm};
      color: ${styles.colors.textMuted};
      font-style: italic;
      background: ${styles.colors.background};
      padding: ${styles.spacing.md};
      border-radius: ${styles.borderRadius};
      border-left: 3px solid ${styles.colors.primary};
      line-height: 1.4;
      margin-bottom: ${styles.spacing.sm};
    `;
    snippetContainer.appendChild(snippet);
    // Add expand/collapse button
    const toggleButton = document.createElement("button");
    toggleButton.style.cssText = `
      border: none;
      background: none;
      color: ${styles.colors.primary};
      font-size: ${styles.fontSize.sm};
      padding: ${styles.spacing.sm};
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: ${styles.spacing.sm};
      margin-top: ${styles.spacing.sm};
    `;
    const toggleIcon = document.createElement("span");
    toggleIcon.textContent = "";
    toggleIcon.style.transition = "transform 0.3s ease";
    toggleButton.appendChild(toggleIcon);
    const toggleText = document.createElement("span");
    toggleText.textContent = "Show more";
    toggleButton.appendChild(toggleText);
    let isExpanded = false;
    toggleButton.addEventListener("click", () => {
        isExpanded = !isExpanded;
        if (isExpanded) {
            snippetContainer.style.maxHeight = `${snippet.scrollHeight + 32}px`;
            toggleIcon.style.transform = "rotate(180deg)";
            toggleText.textContent = "Show less";
            reason.style.webkitLineClamp = "none";
        }
        else {
            snippetContainer.style.maxHeight = "48px";
            toggleIcon.style.transform = "rotate(0deg)";
            toggleText.textContent = "Show more";
            reason.style.webkitLineClamp = "2";
        }
    });
    // Check if we need the expand button by comparing heights
    window.setTimeout(() => {
        if (snippet.scrollHeight <= 48 &&
            reason.scrollHeight <= reason.clientHeight) {
            toggleButton.style.display = "none";
        }
    }, 0);
    container.appendChild(reasonContainer);
    container.appendChild(snippetContainer);
    container.appendChild(toggleButton);
    cell.appendChild(container);
    return cell;
}
//# sourceMappingURL=DownloadWidgets.js.map
```

## dist/src/ui/components/DraggableManager.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/ui/components/DraggableManager.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/*
 * Copyright (c) 2024 Martin Bechard (martin.bechard@DevConsult.ca)
 * This software is licensed under the MIT License.
 * File: src/ui/components/DraggableManager.ts
 * Credit: This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 * Summary: Manages draggable behavior for floating windows
 * Witty remark: Making elements draggable since 2024 - no weightlifting required!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DraggableManager = void 0;
/**
 * Manages draggable behavior for HTML elements.
 */
class DraggableManager {
    /**
     * Creates a new DraggableManager instance.
     * @param window - Element to make draggable
     * @param handle - Element that triggers dragging
     */
    constructor(window, handle) {
        this.isDragging = false;
        this.currentX = 0;
        this.currentY = 0;
        this.initialX = 0;
        this.initialY = 0;
        this.window = window;
        this.handle = handle;
        this.setupEventListeners();
    }
    /**
     * Sets up event listeners for drag behavior.
     */
    setupEventListeners() {
        this.handle.addEventListener("mousedown", this.handleMouseDown.bind(this));
        document.addEventListener("mousemove", this.handleMouseMove.bind(this));
        document.addEventListener("mouseup", this.handleMouseUp.bind(this));
    }
    /**
     * Handles the start of a drag operation.
     * @param e - Mouse event
     */
    handleMouseDown(e) {
        if (e.target === this.handle || this.handle.contains(e.target)) {
            this.isDragging = true;
            this.initialX = e.clientX - this.window.offsetLeft;
            this.initialY = e.clientY - this.window.offsetTop;
            this.window.style.position = "absolute";
            this.window.style.right = "auto";
        }
    }
    /**
     * Handles the drag movement.
     * @param e - Mouse event
     */
    handleMouseMove(e) {
        if (!this.isDragging)
            return;
        e.preventDefault();
        this.currentX = e.clientX - this.initialX;
        this.currentY = e.clientY - this.initialY;
        const bounds = this.calculateBounds();
        this.constrainToBounds(bounds);
        this.window.style.left = `${this.currentX}px`;
        this.window.style.top = `${this.currentY}px`;
    }
    /**
     * Calculates the bounds for dragging.
     * @returns Bounds object with min/max values
     */
    calculateBounds() {
        return {
            minX: 0,
            maxX: window.innerWidth - this.window.offsetWidth,
            minY: 0,
            maxY: window.innerHeight - this.window.offsetHeight,
        };
    }
    /**
     * Constrains the current position to the specified bounds.
     * @param bounds - Bounds to constrain to
     */
    constrainToBounds(bounds) {
        this.currentX = Math.max(bounds.minX, Math.min(this.currentX, bounds.maxX));
        this.currentY = Math.max(bounds.minY, Math.min(this.currentY, bounds.maxY));
    }
    /**
     * Handles the end of a drag operation.
     */
    handleMouseUp() {
        this.isDragging = false;
    }
    /**
     * Removes all event listeners.
     */
    destroy() {
        this.handle.removeEventListener("mousedown", this.handleMouseDown.bind(this));
        document.removeEventListener("mousemove", this.handleMouseMove.bind(this));
        document.removeEventListener("mouseup", this.handleMouseUp.bind(this));
    }
}
exports.DraggableManager = DraggableManager;
//# sourceMappingURL=DraggableManager.js.map
```

## dist/src/ui/components/FloatingWindow.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/ui/components/FloatingWindow.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/*
 * Copyright (c) 2024 Martin Bechard (martin.bechard@DevConsult.ca)
 * This software is licensed under the MIT License.
 * File: src/components/FloatingWindow.ts
 * Credit: This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 * Summary: Manages the floating window interface for the extension
 * Witty remark: Making windows float like butterflies, but typing like bees!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FloatingWindow = void 0;
/**
 * Manages the floating window interface for the extension.
 */
class FloatingWindow {
    constructor() {
        this.element = null;
        this.outputDiv = null;
        this.isCollapsed = false;
        this.isMinimized = false;
        this.template = `
    <div class="floating-window">
      <div class="status ready">
        <div style="display: flex; align-items: center; gap: 5px; flex-grow: 1;">
          <span class="status-label">ClaudeScript - </span>
          <span class="status-text">READY</span>
          <span class="status-details"></span>
        </div>
        <button id="minimizeButton" style="font-size: 12px; padding: 2px 8px;">_</button>
        <button id="helpButton" style="font-size: 12px; padding: 2px 8px;">?</button>
      </div>
      <div class="input-container">
        <div class="script-container">
          <textarea id="scriptText" placeholder="Simple prompt:
Type your prompt here

-- or --

DO MAX 3 UNTIL success
Your prompt here"></textarea>
          <div class="resize-handle"></div>
        </div>
        <button id="runScript">Run Script</button>
        <div class="output-container">
          <div id="scriptOutput"></div>
          <div id="collapseButton" style="cursor: pointer; user-select: none; padding: 5px;"></div>
        </div>
      </div>
    </div>
  `;
    }
    /**
     * Creates and injects the floating window into the DOM.
     * @returns The floating window element
     * @throws Error if window creation fails
     */
    async create() {
        const container = document.createElement("div");
        container.innerHTML = this.template.trim();
        const window = container.querySelector(".floating-window");
        if (!window) {
            throw new Error("Failed to create floating window");
        }
        document.body.appendChild(container);
        this.element = window;
        this.outputDiv = this.element.querySelector("#scriptOutput");
        return this.element;
    }
    /**
     * Retrieves all UI elements managed by the floating window.
     * @returns Object containing all UI elements
     * @throws Error if any element is not found
     */
    getElements() {
        if (!this.element) {
            throw new Error("Floating window not initialized");
        }
        const elements = {
            window: this.element,
            status: this.element.querySelector(".status"),
            statusText: this.element.querySelector(".status-text"),
            statusDetails: this.element.querySelector(".status-details"),
            scriptText: this.element.querySelector("#scriptText"),
            runButton: this.element.querySelector("#runScript"),
            output: this.element.querySelector("#scriptOutput"),
            helpButton: this.element.querySelector("#helpButton"),
            collapseButton: this.element.querySelector("#collapseButton"),
            minimizeButton: this.element.querySelector("#minimizeButton"),
        };
        // Validate all elements exist and are of correct type
        for (const [key, value] of Object.entries(elements)) {
            if (!value) {
                throw new Error(`Failed to find element: ${key}`);
            }
        }
        // Type assertion is safe here because we validated all elements exist
        return elements;
    }
    /**
     * Retrieves the output element.
     * @returns The output element
     * @throws Error if output element not found
     */
    getOutputElement() {
        if (!this.outputDiv) {
            throw new Error("Output element not initialized");
        }
        return this.outputDiv;
    }
    /**
     * Logs a message to the output area.
     * @param message - Message to log
     * @param type - Type of message for styling
     */
    log(message, type = "info") {
        if (!this.outputDiv)
            return;
        const log = document.createElement("div");
        log.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        log.style.color =
            type === "error" ? "red" : type === "success" ? "green" : "black";
        this.outputDiv.appendChild(log);
        this.outputDiv.scrollTop = this.outputDiv.scrollHeight;
    }
    /**
     * Toggles the minimize state of the window.
     */
    toggleMinimize() {
        if (!this.element)
            return;
        // Save current dimensions before toggling
        const currentWidth = this.element.style.width;
        const currentHeight = this.element.style.height;
        this.isMinimized = !this.isMinimized;
        if (this.isMinimized) {
            // Store dimensions for restoration
            if (currentWidth && currentHeight) {
                this.element.dataset.prevWidth = currentWidth;
                this.element.dataset.prevHeight = currentHeight;
            }
            // Clear dimensions to allow shrinking
            this.element.style.width = "";
            this.element.style.height = "";
        }
        else {
            // Restore previous dimensions if they exist
            const prevWidth = this.element.dataset.prevWidth;
            const prevHeight = this.element.dataset.prevHeight;
            if (prevWidth && prevHeight) {
                this.element.style.width = prevWidth;
                this.element.style.height = prevHeight;
            }
        }
        // Toggle minimized class for CSS styling
        this.element.classList.toggle("minimized", this.isMinimized);
        const minimizeButton = this.element.querySelector("#minimizeButton");
        if (minimizeButton) {
            minimizeButton.textContent = this.isMinimized ? "" : "_";
            minimizeButton.title = this.isMinimized ? "Restore" : "Minimize";
        }
    }
    /**
     * Toggles the collapse state of the output panel.
     */
    toggleCollapse() {
        if (!this.outputDiv || !this.element)
            return;
        this.isCollapsed = !this.isCollapsed;
        if (this.isCollapsed) {
            // Store current window height for restoration
            const currentWindowHeight = this.element.style.height;
            if (currentWindowHeight) {
                this.element.dataset.prevHeight = currentWindowHeight;
            }
            // Store output height for restoration
            const currentOutputHeight = this.outputDiv.style.height;
            if (currentOutputHeight) {
                this.outputDiv.dataset.prevHeight = currentOutputHeight;
            }
            // Collapse output area
            this.outputDiv.style.maxHeight = "3em";
            this.outputDiv.style.overflowY = "hidden";
            // Shrink window to fit collapsed content
            this.element.style.height = "auto";
            this.element.style.minHeight = "auto";
        }
        else {
            // Restore window height
            const prevWindowHeight = this.element.dataset.prevHeight;
            if (prevWindowHeight) {
                this.element.style.height = prevWindowHeight;
                this.element.style.minHeight = "200px"; // Restore default min-height
            }
            // Restore output height
            const prevOutputHeight = this.outputDiv.dataset.prevHeight;
            if (prevOutputHeight) {
                this.outputDiv.style.height = prevOutputHeight;
            }
            this.outputDiv.style.maxHeight = "";
            this.outputDiv.style.overflowY = "auto";
        }
        const collapseButton = this.element?.querySelector("#collapseButton");
        if (collapseButton) {
            collapseButton.textContent = this.isCollapsed ? "" : "";
            collapseButton.title = this.isCollapsed ? "Expand" : "Collapse";
        }
    }
    /**
     * Waits for a DOM element to be available.
     * @param selector - CSS selector for the element
     * @param timeoutMs - Maximum time to wait in milliseconds
     * @returns The found element
     * @throws Error if element not found within timeout
     */
    async waitForElement(selector, timeoutMs = 30000) {
        console.log(`Waiting for element: ${selector} (timeout: ${timeoutMs}ms)`);
        return new Promise((resolve, reject) => {
            // First check if element already exists
            const existingElement = document.querySelector(selector);
            if (existingElement) {
                console.log(`Element ${selector} found immediately`);
                return resolve(existingElement);
            }
            let timeoutId;
            let startTime = Date.now();
            const observer = new MutationObserver((mutations, obs) => {
                const element = document.querySelector(selector);
                if (element) {
                    clearTimeout(timeoutId);
                    obs.disconnect();
                    console.log(`Element ${selector} found after ${Date.now() - startTime}ms`);
                    resolve(element);
                }
            });
            timeoutId = window.setTimeout(() => {
                observer.disconnect();
                console.log(`Timeout waiting for ${selector} after ${timeoutMs}ms`);
                console.log("Current page HTML:", document.body.innerHTML);
                reject(new Error(`Timeout waiting for element: ${selector}`));
            }, timeoutMs);
            observer.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: true,
                characterData: true,
            });
            console.log(`Started observing for ${selector}`);
        });
    }
    /**
     * Clears the output panel.
     */
    clearOutput() {
        if (this.outputDiv) {
            this.outputDiv.innerHTML = "";
        }
    }
    /**
     * Removes the floating window from the DOM.
     */
    destroy() {
        this.element?.parentElement?.remove();
        this.element = null;
        this.outputDiv = null;
    }
}
exports.FloatingWindow = FloatingWindow;
//# sourceMappingURL=FloatingWindow.js.map
```

## dist/src/ui/components/HelpManager.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/ui/components/HelpManager.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/HelpManager.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelpManager = void 0;
/**
 * Manages help text display and formatting for the extension.
 */
class HelpManager {
    /**
     * Creates a new HelpManager instance.
     * @param outputElement - Element to display help text in
     */
    constructor(outputElement) {
        this.outputElement = outputElement;
    }
    /**
     * Displays the help text in the output element.
     */
    show() {
        this.outputElement.innerHTML = "";
        HelpManager.HELP_TEXT.split("\n").forEach((line) => {
            const div = document.createElement("div");
            div.textContent = line;
            div.style.whiteSpace = "pre";
            this.outputElement.appendChild(div);
        });
    }
    /**
     * Updates the help text content dynamically.
     * @param newText - New help text content
     */
    updateContent(newText) {
        this.outputElement.innerHTML = "";
        newText
            .trim()
            .split("\n")
            .forEach((line) => {
            const div = document.createElement("div");
            div.textContent = line;
            div.style.whiteSpace = "pre";
            this.outputElement.appendChild(div);
        });
    }
    /**
     * Clears the help text display.
     */
    clear() {
        this.outputElement.innerHTML = "";
    }
}
exports.HelpManager = HelpManager;
HelpManager.HELP_TEXT = `
    ClaudeScript v1.5
    
    1. Simple Prompt:
    Just type your prompt and it will be sent once.
    
    2. Loop Until Format:
    First line: DO [MAX <number>] UNTIL <text>
    Following lines: Your prompt
    
    3. Commands:
    /d[ocs] - List available documents
    
    /p[roject] - List conversations in current project

    /c[onversation] - Export conversation without artifacts
    /c[onversation] /a[rtifacts] - Export conversation including artifacts
    /c[onversation] /m[ultiple] - Export artifacts as separate files
    
    /a[rtifacts] - Export only artifacts as markdown
    /a[rtifacts] /m[ultiple] - Export artifacts as separate files
    
    Note: Square brackets show optional letters. You can use just the first letter.
    Example: '/c /a' is the same as '/conversation /artifacts'
    
    Examples:
    -------------------
    Simple prompt:
    Tell me a joke
    
    -------------------
    With search:
    DO UNTIL laugh
    Tell me a joke
    
    -------------------
    With max tries:
    DO MAX 3 UNTIL success
    Do something`.trim();
//# sourceMappingURL=HelpManager.js.map
```

## dist/src/ui/components/StatusManager.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/ui/components/StatusManager.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/*
 * Copyright (c) 2024 Martin Bechard (martin.bechard@DevConsult.ca)
 * This software is licensed under the MIT License.
 * File: src/ui/components/StatusManager.ts
 * Credit: This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 * Summary: Manages the status display and state for the floating window
 * Witty remark: Managing states like a traffic light, but with better error messages!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatusManager = void 0;
/**
 * Manages the display and updates of status information.
 */
class StatusManager {
    /**
     * Creates a new StatusManager instance.
     * @param elements - Required DOM elements for status management
     */
    constructor(elements) {
        this.currentState = "ready";
        this.elements = elements;
        this.initializeStatus();
    }
    /**
     * Sets up initial status display.
     */
    initializeStatus() {
        this.setStatus("ready");
    }
    /**
     * Updates the current status display.
     * @param state - New status state to display
     * @param details - Optional details message
     */
    async setStatus(state, details = "") {
        console.log("Status:", state, details);
        const config = StatusManager.STATUS_CONFIGS[state];
        this.elements.statusText.textContent = config.text;
        this.elements.statusDetails.textContent = details;
        this.elements.statusElement.className = `status ${config.class}`;
        this.currentState = state;
        this.updateInputState(state);
        this.updateButtonState(state);
    }
    /**
     * Updates the input field state based on status.
     * @param state - Current status state
     */
    updateInputState(state) {
        this.elements.scriptInput.disabled = state === "working";
    }
    /**
     * Updates the run button state based on status.
     * @param state - Current status state
     */
    updateButtonState(state) {
        if (state === "working") {
            this.elements.runButton.textContent = "Cancel";
            this.elements.runButton.disabled = false;
        }
        else {
            this.elements.runButton.textContent = "Run Script";
            this.elements.runButton.disabled = false;
        }
    }
    /**
     * Gets the current status state.
     * @returns Current status state
     */
    getCurrentState() {
        return this.currentState;
    }
    /**
     * Checks if the status is in a specific state.
     * @param state - State to check
     * @returns True if current state matches
     */
    isInState(state) {
        return this.currentState === state;
    }
}
exports.StatusManager = StatusManager;
StatusManager.STATUS_CONFIGS = {
    ready: { text: "READY", class: "ready" },
    working: { text: "WORKING", class: "working" },
    error: { text: "ERROR", class: "error" },
};
//# sourceMappingURL=StatusManager.js.map
```

## dist/src/utils/ElementWaiter.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/utils/ElementWaiter.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/utils/ElementWaiter.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Utility class for waiting for DOM elements to appear with robust timeout handling.
 * Fun fact: Even the most patient element waiter sometimes wishes elements would show up faster!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElementWaiter = void 0;
class ElementWaiter {
    /**
     * Wait for a single element to appear
     * @param selector CSS selector to wait for
     * @returns Promise resolving to the found element
     * @throws Error if element not found within timeout
     */
    static waitForElement(selector) {
        console.log(`Waiting for element: ${selector}`);
        return new Promise((resolve, reject) => {
            // Set timeout
            const timeout = setTimeout(() => {
                observer.disconnect();
                reject(new Error(`Timeout waiting for element: ${selector}`));
            }, this.TIMEOUT);
            // Check immediately first
            const element = document.querySelector(selector);
            if (element) {
                console.log(`Element found immediately: ${selector}`);
                clearTimeout(timeout);
                return resolve(element);
            }
            // Watch for changes
            const observer = new MutationObserver(() => {
                const element = document.querySelector(selector);
                if (element) {
                    console.log(`Element found after mutation: ${selector}`);
                    clearTimeout(timeout);
                    observer.disconnect();
                    resolve(element);
                }
            });
            // Start observing
            observer.observe(document.body, {
                childList: true,
                subtree: true,
            });
        });
    }
    /**
     * Wait for both required Claude interface elements
     * @returns Promise resolving when both elements are found
     * @throws Error if either element not found within timeout
     */
    static async waitForRequiredElements() {
        console.log("Waiting for Claude chat interface...");
        // Wait for container first
        await this.waitForElement(".chat-messages-container");
        console.log("Chat container found");
        // Then wait for input
        await this.waitForElement(".prompt-textarea");
        console.log("Input area found");
    }
}
exports.ElementWaiter = ElementWaiter;
ElementWaiter.TIMEOUT = 30000;
//# sourceMappingURL=ElementWaiter.js.map
```

## dist/src/utils/getClaudeIds.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/utils/getClaudeIds.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/utils/getClaudeIds.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Utility functions for retrieving organization and project IDs from Claude
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIdsFromUrl = getIdsFromUrl;
exports.getOrganizationId = getOrganizationId;
exports.getProjectUuid = getProjectUuid;
const getHeaders_1 = require("./getHeaders");
const API_URL = "https://api.claude.ai/api/organizations";
/**
 * Gets project and conversation IDs from the current URL
 */
function getIdsFromUrl() {
    const projectMatch = window.location.pathname.match(/\/project\/([^\/]+)/);
    if (projectMatch) {
        return { projectId: projectMatch[1], conversationId: null };
    }
    const chatMatch = window.location.pathname.match(/\/chat\/([^\/]+)/);
    if (!chatMatch) {
        throw new Error("Please navigate to a Claude chat or project page before using this command");
    }
    return {
        projectId: null,
        conversationId: chatMatch[1],
    };
}
/**
 * Gets the organization ID from cookies
 * @throws Error if organization ID is not found or invalid
 */
function getOrganizationId() {
    const cookie = document.cookie
        .split("; ")
        .find((row) => row.startsWith("lastActiveOrg="));
    if (!cookie) {
        throw new Error("Organization ID not found in cookies");
    }
    try {
        const value = decodeURIComponent(cookie.split("=")[1]);
        return value.replace(/^"|"$/g, "");
    }
    catch (error) {
        throw new Error("Invalid organization ID format in cookie");
    }
}
/**
 * Gets the project UUID for API requests
 * @param organizationId - Organization ID to use for API request
 * @returns Promise resolving to project UUID
 * @throws Error if project UUID cannot be retrieved
 */
async function getProjectUuid(organizationId) {
    const { projectId, conversationId } = getIdsFromUrl();
    if (projectId) {
        return projectId;
    }
    if (conversationId) {
        const response = await fetch(`${API_URL}/${organizationId}/chat_conversations/${conversationId}?tree=True&rendering_mode=messages`, {
            method: "GET",
            headers: (0, getHeaders_1.getHeaders)(),
            credentials: "include",
        });
        if (!response.ok) {
            throw new Error(`Failed to fetch conversation details: ${response.status}`);
        }
        const data = await response.json();
        const projectUuid = data.project_uuid;
        if (!projectUuid) {
            throw new Error("Project UUID not found in conversation details");
        }
        return projectUuid;
    }
    throw new Error("No project or conversation ID found in URL");
}
//# sourceMappingURL=getClaudeIds.js.map
```

## dist/src/utils/getConversation.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/utils/getConversation.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/utils/getConversation.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Utility functions for retrieving conversation details from Claude's API
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCurrentConversationDetails = getCurrentConversationDetails;
const getHeaders_1 = require("./getHeaders");
const getClaudeIds_1 = require("./getClaudeIds");
const API_URL = "https://api.claude.ai/api/organizations";
/**
 * Gets current conversation details including latest message ID
 * @returns Promise resolving to { conversationId, parentMessageUuid }
 * @throws Error if conversation details cannot be retrieved
 */
async function getCurrentConversationDetails() {
    // Get conversation ID from URL
    const match = window.location.pathname.match(/\/chat\/([^\/]+)/);
    if (!match) {
        throw new Error("Please navigate to a Claude chat page first");
    }
    const conversationId = match[1];
    const orgId = (0, getClaudeIds_1.getOrganizationId)();
    try {
        // Get conversation details
        const response = await fetch(`${API_URL}/${orgId}/chat_conversations/${conversationId}?tree=True&rendering_mode=messages`, {
            method: "GET",
            headers: (0, getHeaders_1.getHeaders)(),
            credentials: "include",
        });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const conversation = await response.json();
        return {
            conversationId,
            parentMessageUuid: conversation.current_leaf_message_uuid,
        };
    }
    catch (error) {
        throw new Error(`Failed to get conversation details: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
}
//# sourceMappingURL=getConversation.js.map
```

## dist/src/utils/getHeaders.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/utils/getHeaders.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /src/utils/getHeaders.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHeaders = getHeaders;
function getHeaders() {
    return {
        Accept: "*/*",
        "Accept-Encoding": "gzip, deflate, br, zstd",
        "Accept-Language": "en-US,en;q=0.9,fr-CA;q=0.8,fr;q=0.7",
        "Anthropic-Client-Sha": "unknown",
        "Anthropic-Client-Version": "unknown",
        "Cache-Control": "no-cache",
        "Content-Type": "application/json",
        Origin: "https://claude.ai",
        Pragma: "no-cache",
        Referer: "https://claude.ai/",
        "Sec-Ch-Ua": '"Chromium";v="128", "Not;A=Brand";v="24", "Google Chrome";v="128"',
        "Sec-Ch-Ua-Mobile": "?0",
        "Sec-Ch-Ua-Platform": '"macOS"',
        Priority: "u=1, i",
    };
}
//# sourceMappingURL=getHeaders.js.map
```

## dist/src/utils/PathExtractor.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/utils/PathExtractor.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /src/utils/PathExtractor.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Utility functions for extracting file paths from code artifacts
 * Note: Finding needles in comment haystacks since 2024!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPathFromComments = extractPathFromComments;
exports.extractPathFromSpecialCases = extractPathFromSpecialCases;
exports.extractRelPath = extractRelPath;
exports.extractPath = extractPath;
exports.filterPathFromSubdirectories = filterPathFromSubdirectories;
/**
 * Extracts the file path from a code artifact's comments
 * Checks both single-line and block comments at the start of the file
 * @param content - The content to analyze
 * @returns The extracted path or undefined if not found
 */
function extractPathFromComments(content) {
    // Normalize line endings
    const normalizedContent = content.replace(/\r\n/g, "\n");
    const lines = normalizedContent.split("\n");
    let inBlockComment = false;
    let collectedLines = [];
    for (let i = 0; i < Math.min(20, lines.length); i++) {
        // Only check first 20 lines
        const line = lines[i].trim();
        // Skip empty lines
        if (!line)
            continue;
        // Check for start of block comment
        if (line.startsWith("/*")) {
            inBlockComment = true;
            collectedLines.push(line.substring(2).trim());
            continue;
        }
        // Check for end of block comment
        if (inBlockComment && line.includes("*/")) {
            inBlockComment = false;
            collectedLines.push(line.substring(0, line.indexOf("*/")).trim());
            break;
        }
        // Collect block comment lines
        if (inBlockComment) {
            // Remove leading * if present
            const cleanLine = line.startsWith("*") ? line.substring(1).trim() : line;
            collectedLines.push(cleanLine);
            continue;
        }
        // Check for single-line comments
        if (line.startsWith("//")) {
            collectedLines.push(line.substring(2).trim());
            continue;
        }
        // If we hit a non-comment line, stop processing
        if (!inBlockComment)
            break;
    }
    // Look for path in collected lines
    for (const line of collectedLines) {
        // Check for explicit path declarations
        const pathMatches = [
            /File:\s*([^*\n]+)/i, // File: path
            /Path:\s*([^*\n]+)/i, // Path: path
            /FilePath:\s*([^*\n]+)/i, // FilePath: path
            /@path\s+([^*\n]+)/i, // @path path
            /^[\\/].*\.[\w]+$/, // Absolute path with extension
        ];
        for (const pattern of pathMatches) {
            const match = line.match(pattern);
            if (match) {
                const path = match[1] || match[0];
                return path.trim();
            }
        }
    }
    return undefined;
}
/**
 * Handles special cases where the path might be in a non-standard format
 * Such as in JSON files with _path property
 * @param content - The content to analyze
 * @returns The extracted path or undefined if not found
 */
function extractPathFromSpecialCases(content) {
    try {
        // Check if it's a JSON file
        const jsonContent = JSON.parse(content);
        if (jsonContent._path || jsonContent._file) {
            return jsonContent._path || jsonContent._file;
        }
    }
    catch {
        // Not JSON, continue with normal processing
    }
    return undefined;
}
/**
 * Main function to extract a relative path to one of the main project subdirectories
 * Tries different strategies in order of reliability
 * @param content - The content to analyze
 * @param subdirectories - Optional list of subdirectories to match
 * @returns The extracted path or undefined if not found
 */
function extractRelPath(content, subdirectories) {
    return extractPath(content, subdirectories || ["src", "doc", "tests", "web", "api", "app"]);
}
/**
 * Main function to extract path from content
 * Tries different strategies in order of reliability
 * @param content - The content to analyze
 * @param subdirectories - Optional list of subdirectories to match
 * @returns The extracted path or undefined if not found
 */
function extractPath(content, subdirectories) {
    // First try special cases (like JSON)
    const specialCasePath = extractPathFromSpecialCases(content);
    if (specialCasePath) {
        return filterPathFromSubdirectories(specialCasePath, subdirectories);
    }
    // Then try extracting from comments
    const commentPath = extractPathFromComments(content);
    if (commentPath) {
        return filterPathFromSubdirectories(commentPath, subdirectories);
    }
    return undefined;
}
/**
 * Helper function to filter the path based on the provided subdirectories.
 * Keeps only the path segment from the first match of the subdirectory onwards.
 * @param path - The full path extracted from content
 * @param subdirectories - List of subdirectories to search for in the path
 * @returns The filtered path or the original path if no subdirectory match
 */
function filterPathFromSubdirectories(path, subdirectories) {
    if (!subdirectories)
        return path;
    // Join the subdirectories with | for regex OR, ensuring word boundaries
    const subdirectoryPattern = new RegExp(`\\b(${subdirectories.join("|")})\\b`, "i");
    const match = path.match(subdirectoryPattern);
    if (match && match.index !== undefined) {
        return path.slice(match.index);
    }
    return path;
}
//# sourceMappingURL=PathExtractor.js.map
```

## dist/src/utils/requestCompletion.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/utils/requestCompletion.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /src/utils/requestCompletion.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Utility functions for making completion requests to Claude's API
 * Note: Making streaming responses as smooth as butter!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestCompletion = requestCompletion;
exports.requestCompletionStream = requestCompletionStream;
exports.isStreamingSupported = isStreamingSupported;
const getHeaders_1 = require("./getHeaders");
const getClaudeIds_1 = require("./getClaudeIds");
const getConversation_1 = require("./getConversation");
const API_URL = "https://api.claude.ai/api/organizations";
const DEFAULT_TIMEZONE = "America/Toronto";
const DEFAULT_RENDERING_MODE = "messages";
/**
 * Sends a single completion request to Claude's API
 * @param params Request parameters
 * @returns Promise resolving to completion response
 * @throws Error if the request fails
 */
async function requestCompletion(params) {
    try {
        // Get current conversation context
        const { conversationId, parentMessageUuid } = await (0, getConversation_1.getCurrentConversationDetails)();
        const orgId = (0, getClaudeIds_1.getOrganizationId)();
        const endpoint = `${API_URL}/${orgId}/chat_conversations/${conversationId}/completion`;
        const requestBody = {
            prompt: params.prompt,
            parent_message_uuid: parentMessageUuid,
            timezone: params.timezone || DEFAULT_TIMEZONE,
            attachments: params.attachments || [],
            files: params.files || [],
            sync_sources: params.syncSources || [],
            rendering_mode: params.renderingMode || DEFAULT_RENDERING_MODE,
        };
        const queryParams = new URLSearchParams({
            rendering_mode: requestBody.rendering_mode,
        });
        const response = await fetch(`${endpoint}?${queryParams.toString()}`, {
            method: "POST",
            headers: (0, getHeaders_1.getHeaders)(),
            credentials: "include",
            body: JSON.stringify(requestBody),
        });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return await response.json();
    }
    catch (error) {
        throw new Error(`Completion request failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
}
/**
 * Sends a streaming completion request to Claude's API
 * Handles Server-Sent Events (SSE) format with completion chunks
 * @param params Request parameters for the completion
 * @param onChunk Callback function to handle each completion chunk
 * @throws Error if the request fails or stream cannot be processed
 */
async function requestCompletionStream(params, onChunk) {
    try {
        // Get current conversation context
        const { conversationId, parentMessageUuid } = await (0, getConversation_1.getCurrentConversationDetails)();
        const orgId = (0, getClaudeIds_1.getOrganizationId)();
        const endpoint = `${API_URL}/${orgId}/chat_conversations/${conversationId}/completion`;
        const requestBody = {
            prompt: params.prompt,
            parent_message_uuid: parentMessageUuid,
            timezone: params.timezone || DEFAULT_TIMEZONE,
            attachments: params.attachments || [],
            files: params.files || [],
            sync_sources: params.syncSources || [],
            rendering_mode: params.renderingMode || DEFAULT_RENDERING_MODE,
        };
        const queryParams = new URLSearchParams({
            rendering_mode: requestBody.rendering_mode,
        });
        const response = await fetch(`${endpoint}?${queryParams.toString()}`, {
            method: "POST",
            headers: {
                ...(0, getHeaders_1.getHeaders)(),
                Accept: "text/event-stream",
            },
            credentials: "include",
            body: JSON.stringify(requestBody),
        });
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        if (!response.body) {
            throw new Error("Response body is null");
        }
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done)
                    break;
                // Append new data to buffer
                buffer += decoder.decode(value, { stream: true });
                // Process complete events in buffer
                const events = buffer.split("\n\n");
                // Keep last potentially incomplete event in buffer
                buffer = events.pop() || "";
                for (const event of events) {
                    if (!event.trim())
                        continue;
                    const lines = event.split("\n");
                    if (lines.length < 2)
                        continue;
                    const eventType = lines[0].replace("event: ", "");
                    const dataLine = lines[1].replace("data: ", "");
                    if (eventType === "completion") {
                        try {
                            const data = JSON.parse(dataLine);
                            if (data.completion) {
                                onChunk(data.completion);
                            }
                            // Check for completion stop
                            if (data.stop_reason) {
                                return;
                            }
                        }
                        catch (error) {
                            console.error("Error parsing completion event:", error);
                            console.debug("Raw event data:", dataLine);
                        }
                    }
                    // Ignore ping events and other event types
                }
            }
            // Process any remaining complete event in buffer
            if (buffer.trim()) {
                const lines = buffer.split("\n");
                if (lines.length >= 2 && lines[0].includes("completion")) {
                    try {
                        const data = JSON.parse(lines[1].replace("data: ", ""));
                        if (data.completion) {
                            onChunk(data.completion);
                        }
                    }
                    catch (error) {
                        console.error("Error parsing final completion event:", error);
                        console.debug("Raw final event data:", buffer);
                    }
                }
            }
        }
        finally {
            // Ensure reader is released
            reader.releaseLock();
        }
    }
    catch (error) {
        throw new Error(`Streaming request failed: ${error instanceof Error ? error.message : "Unknown error"}`);
    }
}
/**
 * Checks if streaming is supported in the current environment
 * @returns true if streaming is supported
 */
function isStreamingSupported() {
    return (typeof ReadableStream !== "undefined" &&
        typeof TextDecoder !== "undefined" &&
        typeof Response !== "undefined" &&
        "body" in Response.prototype);
}
//# sourceMappingURL=requestCompletion.js.map
```

## dist/src/utils/ScriptParser.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/src/utils/ScriptParser.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/utils/ScriptParser.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptParser = void 0;
/**
 * Utility class for parsing script text into structured commands.
 */
class ScriptParser {
    /**
     * Matches a command input to its full version
     * @param input - Command input to match
     * @param commandMap - Map of valid commands
     * @returns Full command name if matched
     * @throws Error if no match or ambiguous
     */
    static matchCommand(input, commandMap) {
        // First check for exact matches or abbreviation matches
        for (const [key, info] of Object.entries(commandMap)) {
            if (input === key || input === info.abbreviation) {
                return info.full;
            }
        }
        // Then check for partial matches of the full command
        const matches = Object.entries(commandMap).filter(([key, info]) => key.startsWith(input) || info.full.startsWith(input));
        if (matches.length === 0) {
            throw new Error(`Unknown command: ${input}`);
        }
        if (matches.length > 1) {
            throw new Error(`Ambiguous command '${input}'. Could be: ${matches
                .map(([key, info]) => `${info.full} (/${info.abbreviation})`)
                .join(", ")}`);
        }
        return matches[0][1].full;
    }
    /**
     * Checks if the line is a command.
     * @param line - Line to check
     * @returns True if line is a command
     */
    static isCommand(line) {
        if (!line.startsWith(this.COMMAND_PREFIX)) {
            return false;
        }
        try {
            const commandPart = line.slice(1).split(" ")[0];
            this.matchCommand(commandPart, this.COMMANDS);
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * Parses command options from a command line
     * @param commandLine - Full command line after the base command
     * @returns Parsed command options
     */
    static parseCommandOptions(commandLine) {
        const options = {};
        const parts = commandLine.trim().split(/\s+/);
        parts.forEach((part) => {
            if (!part.startsWith("/"))
                return;
            const option = part.slice(1).toLowerCase();
            try {
                const fullOption = this.matchCommand(option, this.OPTIONS);
                switch (fullOption) {
                    case "artifacts":
                        options.includeArtifacts = true;
                        break;
                    case "multiple":
                        options.downloadMultiple = true;
                        break;
                }
            }
            catch (error) {
                throw new Error(`Invalid option: ${part}`);
            }
        });
        return options;
    }
    /**
     * Parses a command line into a script object.
     * @param line - Command line to parse
     * @returns Parsed script object
     */
    static parseCommand(line) {
        const [fullCommand, ...optionParts] = line.slice(1).split(/\s+/);
        const commandPart = fullCommand.toLowerCase();
        const command = this.matchCommand(commandPart, this.COMMANDS);
        const options = this.parseCommandOptions(optionParts.join(" "));
        // Set default options based on command
        if (command === "conversation") {
            options.includeConversation = true;
        }
        if (command === "artifacts") {
            options.includeArtifacts = true;
        }
        // Extract search text for search_project command
        let searchText;
        if (command === "search_project") {
            // Get all non-option text after the command
            let searchParts = [];
            let isCollectingSearch = true;
            for (const part of optionParts) {
                if (part.startsWith("/")) {
                    isCollectingSearch = false; // Stop collecting search text when we hit an option
                    continue;
                }
                if (isCollectingSearch) {
                    searchParts.push(part);
                }
            }
            if (searchParts.length > 0) {
                searchText = searchParts.join(" ").trim();
            }
        }
        // Validate option combinations
        if (options.downloadMultiple && !options.includeArtifacts) {
            throw new Error("/multiple can only be used with /artifacts option");
        }
        return {
            maxTries: 1,
            findText: null,
            prompt: line,
            isCommand: true,
            command,
            options,
            searchText,
        };
    }
    /**
     * Checks if the line is a DO UNTIL script.
     * @param line - Line to check
     * @returns True if line is a DO UNTIL script
     */
    static isDoUntilScript(line) {
        return this.DO_UNTIL_REGEX.test(line);
    }
    /**
     * Parses a DO UNTIL script into a script object.
     * @param firstLine - First line containing DO UNTIL syntax
     * @param lines - Lines of the script
     * @returns Parsed script object
     * @throws Error if DO UNTIL syntax is invalid
     */
    static parseDoUntilScript(firstLine, lines) {
        const match = firstLine.match(this.DO_UNTIL_REGEX);
        if (!match) {
            throw new Error("Invalid DO UNTIL syntax. Use: DO [MAX <number>] UNTIL <text>");
        }
        const [, maxTriesStr, findText] = match;
        const prompt = lines.slice(1).join("\n").trim();
        if (!prompt) {
            throw new Error("No prompt provided after DO UNTIL line");
        }
        return {
            maxTries: maxTriesStr
                ? parseInt(maxTriesStr, 10)
                : this.DEFAULT_MAX_TRIES,
            findText: findText.trim(),
            prompt,
            isCommand: false,
            command: null,
            options: {},
        };
    }
    /**
     * Parses a simple script into a script object.
     * @param lines - Lines of the script
     * @returns Parsed script object
     * @throws Error if script is empty
     */
    static parseSimpleScript(lines) {
        const prompt = lines.join("\n").trim();
        if (!prompt) {
            throw new Error("No prompt provided");
        }
        return {
            maxTries: 1,
            findText: null,
            prompt,
            isCommand: false,
            command: null,
            options: {},
        };
    }
    /**
     * Parses raw script text into structured script object.
     * @param text - Raw script text to parse
     * @returns Parsed script object
     * @throws Error if script syntax is invalid
     */
    static parse(text) {
        const lines = text.split("\n");
        const firstLine = lines[0].trim();
        if (this.isCommand(firstLine)) {
            return this.parseCommand(firstLine);
        }
        if (this.isDoUntilScript(firstLine)) {
            return this.parseDoUntilScript(firstLine, lines);
        }
        return this.parseSimpleScript(lines);
    }
}
exports.ScriptParser = ScriptParser;
ScriptParser.DEFAULT_MAX_TRIES = 5;
ScriptParser.COMMAND_PREFIX = "/";
ScriptParser.DO_UNTIL_REGEX = /DO(?:\s+MAX\s+(\d+))?\s+UNTIL\s+(.+)/i;
// Define commands with their abbreviations
ScriptParser.COMMANDS = {
    docs: { full: "docs", abbreviation: "d" },
    conversation: { full: "conversation", abbreviation: "c" },
    artifacts: { full: "artifacts", abbreviation: "a" },
    project: { full: "project", abbreviation: "p" },
    search_project: { full: "search_project", abbreviation: "sp" },
};
// Define options with their abbreviations
ScriptParser.OPTIONS = {
    artifacts: { full: "artifacts", abbreviation: "a" },
    multiple: { full: "multiple", abbreviation: "m" },
};
//# sourceMappingURL=ScriptParser.js.map
```

## dist/styles.css

```css
/*
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/styles.css
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
*/

.floating-window {
  position: fixed;
  top: 20px;
  left: 20px;
  background: white;
  border: 2px solid #666;
  border-radius: 8px;
  padding: 15px;
  z-index: 999999;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
  width: 400px;
  min-width: 300px;
  min-height: 200px;
  max-height: calc(100vh - 40px);
  font-family: Arial, sans-serif;
  display: flex;
  flex-direction: column;
  resize: both !important;
  overflow: auto !important;
  box-sizing: border-box;
  transition: all 0.3s ease;
}
.floating-window.minimized {
  min-width: unset;
  width: auto;
  min-height: unset;
  padding: 8px;
  resize: none !important;
}

.floating-window.minimized .input-container {
  display: none !important;
}

.floating-window.minimized::after {
  display: none;
}

.status {
  font-weight: bold;
  margin-bottom: 10px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px;
  background: #f5f5f5;
  border-radius: 4px;
  cursor: move;
  flex-shrink: 0;
  user-select: none;
}

.status.ready {
  color: #008000;
}
.status.working {
  color: #cc0000;
}
.status.error {
  color: #ff6600;
}

.status-label {
  font-weight: bold;
  color: #333;
}

.input-container {
  display: flex;
  flex-direction: column;
  gap: 10px;
  flex-grow: 1;
  min-height: 0;
  overflow: auto;
}

.script-container {
  position: relative;
  min-height: 100px;
  flex-shrink: 0;
}

#scriptText {
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
  font-family: monospace;
  resize: none;
  width: 100%;
  height: 100%;
  box-sizing: border-box;
}

.resize-handle {
  position: absolute;
  bottom: -5px;
  left: 0;
  right: 0;
  height: 10px;
  cursor: row-resize;
  background: transparent;
  z-index: 1;
}

.resize-handle:hover::after {
  content: "";
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 30px;
  height: 4px;
  background: #ccc;
  border-radius: 2px;
}

#runScript {
  padding: 8px 16px;
  background: #0066cc;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  flex-shrink: 0;
}

#runScript:hover {
  background: #0052a3;
}
#runScript:disabled {
  background: #cccccc;
}

.output-container {
  flex-grow: 1;
  min-height: 0;
  display: flex;
  flex-direction: row;
  gap: 5px;
  margin-top: 10px;
  overflow: auto;
}

#scriptOutput {
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 8px;
  background: #f8f8f8;
  font-size: 12px;
  line-height: 1.4;
  flex-grow: 1;
  overflow-y: auto;
  min-height: 0;
  box-sizing: border-box;
  max-height: calc(100vh - 200px);
}

/* Export button styles */
.export-button {
  padding: 8px 16px;
  background: #0066cc;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  margin-top: 10px;
}

.export-button:hover {
  background: #0052a3;
}

#minimizeButton {
  cursor: pointer;
  border: none;
  background: none;
  color: #666;
  font-size: 16px;
  line-height: 1;
  padding: 2px 8px;
  border-radius: 4px;
}

#minimizeButton:hover {
  background: #f0f0f0;
}

.simple-button {
  padding: 8px 16px;
  background: #0066cc;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  flex: 1;
  transition: background-color 0.2s ease;
}

.simple-button:hover {
  background: #0052a3;
}

.simple-mode {
  padding: 10px;
}

.command-button {
  padding: 8px 16px;
  background: #0066cc;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  flex: 1;
  transition: background-color 0.2s ease;
}

.command-button:hover {
  background: #0052a3;
}

#modeToggleButton {
  cursor: pointer;
  border: none;
  background: none;
  color: #666;
  font-size: 16px;
  line-height: 1;
  padding: 2px 8px;
  border-radius: 4px;
}

#modeToggleButton:hover {
  background: #f0f0f0;
}

/* Project search styles */
.project-search-container {
  display: none;
  position: relative;
  margin-bottom: 10px;
}

.project-search-input {
  width: 100%;
  padding: 8px 32px 8px 8px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
  box-sizing: border-box;
}

.project-search-glyph {
  position: absolute;
  right: 8px;
  top: 8px;
  cursor: pointer;
  color: #666;
  background: none;
  border: none;
  padding: 4px;
  font-size: 16px;
  line-height: 1;
}

.project-search-glyph:hover {
  color: #0066cc;
}

.project-search-cancel {
  display: none;
  padding: 8px 16px;
  background: #cc0000;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  margin: 8px auto 0;
  width: 33%;
}

.project-search-cancel:hover {
  background: #aa0000;
}

```

## dist/tests/ConversationAnalyzer.test.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/tests/ConversationAnalyzer.test.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
// Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
// This software is licensed under the MIT License.
// Path: tests/ConversationAnalyzer.test.ts
// This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
// Test suite for the ConversationAnalyzer class
// "Testing conversations is like being a detective, but the only clues are message lengths!"
Object.defineProperty(exports, "__esModule", { value: true });
const ConversationAnalyzer_1 = require("@/ConversationAnalyzer");
describe("ConversationAnalyzer", () => {
    const sampleData = [
        {
            id: "conv1",
            name: "First Conversation",
            messages: [
                {
                    id: "msg1",
                    sender: "human",
                    content: "Hello", // length 5
                },
                {
                    id: "msg2",
                    sender: "assistant",
                    content: "Hello there, how can I help you today?", // length 38
                },
            ],
        },
        {
            id: "conv2",
            name: "Second Conversation",
            messages: [
                {
                    id: "msg3",
                    sender: "human",
                    content: "What is the weather?", // length 20
                },
            ],
        },
    ];
    let analyzer;
    beforeEach(() => {
        analyzer = new ConversationAnalyzer_1.ConversationAnalyzer(sampleData);
    });
    test("calculates correct message lengths", () => {
        const results = analyzer.analyze();
        expect(results.conversationMetrics[0].messageLengths).toEqual([
            { length: 5, messageId: "msg1" },
            { length: 38, messageId: "msg2" },
        ]);
        expect(results.conversationMetrics[1].messageLengths).toEqual([
            { length: 20, messageId: "msg3" },
        ]);
    });
    test("identifies longest message in each conversation", () => {
        const results = analyzer.analyze();
        expect(results.conversationMetrics[0].longestMessage).toEqual({
            length: 38,
            messageId: "msg2",
        });
        expect(results.conversationMetrics[1].longestMessage).toEqual({
            length: 20,
            messageId: "msg3",
        });
    });
    test("calculates correct total size for each conversation", () => {
        const results = analyzer.analyze();
        expect(results.conversationMetrics[0].totalSize).toBe(43); // 5 + 38
        expect(results.conversationMetrics[1].totalSize).toBe(20);
    });
    test("calculates correct overall total size", () => {
        const results = analyzer.analyze();
        expect(results.totalSize).toBe(63); // 43 + 20
    });
    test("creates instance from JSON string", () => {
        const jsonString = JSON.stringify(sampleData);
        const analyzerFromJson = ConversationAnalyzer_1.ConversationAnalyzer.fromJson(jsonString);
        const results = analyzerFromJson.analyze();
        expect(results.totalSize).toBe(63);
    });
    test("handles empty conversations", () => {
        const emptyData = [
            {
                id: "empty",
                name: "Empty Conversation",
                messages: [],
            },
        ];
        const emptyAnalyzer = new ConversationAnalyzer_1.ConversationAnalyzer(emptyData);
        const results = emptyAnalyzer.analyze();
        expect(results.conversationMetrics[0].messageLengths).toHaveLength(0);
        expect(results.conversationMetrics[0].totalSize).toBe(0);
        expect(results.totalSize).toBe(0);
    });
});
//# sourceMappingURL=ConversationAnalyzer.test.js.map
```

## dist/tests/utils/PathExtractor.test.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/tests/utils/PathExtractor.test.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /src/utils/__tests__/PathExtractor.test.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Test suite for PathExtractor utility functions
 */
const globals_1 = require("@jest/globals");
const PathExtractor_1 = require("@/utils/PathExtractor");
(0, globals_1.describe)("PathExtractor", () => {
    (0, globals_1.describe)("extractPathFromComments", () => {
        (0, globals_1.it)("extracts path from single-line comments with File:", () => {
            const content = `// Copyright notice
// License info
// File: src/utils/test.ts
function test() {}`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromComments)(content)).toBe("src/utils/test.ts");
        });
        (0, globals_1.it)("extracts path from single-line comments with Path:", () => {
            const content = `// Copyright notice
// Path: src/components/Component.tsx
class Component {}`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromComments)(content)).toBe("src/components/Component.tsx");
        });
        (0, globals_1.it)("extracts path from block comments", () => {
            const content = `/*
 * Copyright notice
 * File: src/services/Service.ts
 */
class Service {}`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromComments)(content)).toBe("src/services/Service.ts");
        });
        (0, globals_1.it)("extracts path from block comments without asterisks", () => {
            const content = `/*
Copyright notice
File: src/models/Model.ts
*/
class Model {}`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromComments)(content)).toBe("src/models/Model.ts");
        });
        (0, globals_1.it)("handles Windows-style paths", () => {
            const content = `// File: C:\\Users\\dev\\src\\utils\\test.ts`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromComments)(content)).toBe("C:\\Users\\dev\\src\\utils\\test.ts");
        });
        (0, globals_1.it)("handles paths with spaces", () => {
            const content = `// File: /User Content/My Project/src/test.ts`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromComments)(content)).toBe("/User Content/My Project/src/test.ts");
        });
        (0, globals_1.it)("extracts path from absolute path format", () => {
            const content = `// /usr/local/src/test.ts`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromComments)(content)).toBe("/usr/local/src/test.ts");
        });
        (0, globals_1.it)("ignores paths after non-comment lines", () => {
            const content = `const x = 1;
// File: src/test.ts`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromComments)(content)).toBeUndefined();
        });
        (0, globals_1.it)("handles empty or whitespace content", () => {
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromComments)("")).toBeUndefined();
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromComments)("   \n   ")).toBeUndefined();
        });
        (0, globals_1.it)("ignores paths after first 20 lines", () => {
            const content = Array(21).fill("// dummy line").join("\n") + "\n// File: src/test.ts";
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromComments)(content)).toBeUndefined();
        });
    });
    (0, globals_1.describe)("extractPathFromSpecialCases", () => {
        (0, globals_1.it)("extracts path from JSON with _path", () => {
            const content = `{
                "_copyright": "Copyright notice",
                "_path": "/src/config.json"
            }`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromSpecialCases)(content)).toBe("/src/config.json");
        });
        (0, globals_1.it)("extracts path from JSON with _file", () => {
            const content = `{
                "_copyright": "Copyright notice",
                "_file": "/src/manifest.json"
            }`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromSpecialCases)(content)).toBe("/src/manifest.json");
        });
        (0, globals_1.it)("prefers _path over _file in JSON", () => {
            const content = `{
                "_path": "/src/config.json",
                "_file": "/src/other.json"
            }`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromSpecialCases)(content)).toBe("/src/config.json");
        });
        (0, globals_1.it)("returns undefined for invalid JSON", () => {
            const content = `{ invalid json }`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromSpecialCases)(content)).toBeUndefined();
        });
        (0, globals_1.it)("returns undefined for JSON without path properties", () => {
            const content = `{ "prop": "value" }`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPathFromSpecialCases)(content)).toBeUndefined();
        });
    });
    (0, globals_1.describe)("extractPath", () => {
        (0, globals_1.it)("extracts path from comments when available", () => {
            const content = `// File: src/test.ts`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPath)(content)).toBe("src/test.ts");
        });
        (0, globals_1.it)("extracts path from JSON when available", () => {
            const content = `{ "_path": "/src/config.json" }`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPath)(content)).toBe("/src/config.json");
        });
        (0, globals_1.it)("returns undefined when no path found", () => {
            const content = `const x = 1;`;
            (0, globals_1.expect)((0, PathExtractor_1.extractPath)(content)).toBeUndefined();
        });
        (0, globals_1.it)("handles real-world examples", () => {
            const examples = [
                {
                    content: `/**
                     * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
                     * This software is licensed under the MIT License.
                     * File: /Users/martinbechard/dev/claudeext/src/ClaudeExtension.ts
                     */`,
                    expected: "/Users/martinbechard/dev/claudeext/src/ClaudeExtension.ts",
                },
                {
                    content: `{
                        "_copyright": "Copyright (c) 2024 Martin Bechard",
                        "_license": "MIT License",
                        "_path": "/Users/martinbechard/dev/claudeext/src/manifest.json"
                    }`,
                    expected: "/Users/martinbechard/dev/claudeext/src/manifest.json",
                },
            ];
            examples.forEach(({ content, expected }) => {
                (0, globals_1.expect)((0, PathExtractor_1.extractPath)(content)).toBe(expected);
            });
        });
    });
});
const PathExtractor_2 = require("@/utils/PathExtractor");
(0, globals_1.describe)("filterPathFromSubdirectories", () => {
    (0, globals_1.it)("should return path from first 'src' occurrence in Unix-style path", () => {
        const path = "/usr/local/myapp/src/utils/test.ts";
        (0, globals_1.expect)((0, PathExtractor_2.filterPathFromSubdirectories)(path, ["src"])).toBe("src/utils/test.ts");
    });
    (0, globals_1.it)("should handle Unix-style path starting with subdirectory", () => {
        const path = "/src/utils/test.ts";
        (0, globals_1.expect)((0, PathExtractor_2.filterPathFromSubdirectories)(path, ["src"])).toBe("src/utils/test.ts");
    });
    (0, globals_1.it)("should return path from first 'src' occurrence in Windows-style path", () => {
        const path = "C:\\Program Files\\MyApp\\src\\utils\\test.ts";
        (0, globals_1.expect)((0, PathExtractor_2.filterPathFromSubdirectories)(path, ["src"])).toBe("src\\utils\\test.ts");
    });
    (0, globals_1.it)("should return full path when no specified subdirectory is found", () => {
        const path = "/usr/local/myapp/utils/test.ts";
        (0, globals_1.expect)((0, PathExtractor_2.filterPathFromSubdirectories)(path, ["src", "docs"])).toBe("/usr/local/myapp/utils/test.ts");
    });
    (0, globals_1.it)("should handle path with multiple subdirectory options", () => {
        const path = "/usr/local/myapp/docs/src/utils/test.ts";
        (0, globals_1.expect)((0, PathExtractor_2.filterPathFromSubdirectories)(path, ["src", "docs"])).toBe("docs/src/utils/test.ts");
    });
});
(0, globals_1.describe)("extractPath with subdirectory filtering in comment blocks", () => {
    (0, globals_1.it)("should extract path from comment and return from first 'src' occurrence", () => {
        const content = `// File: /usr/local/myapp/src/utils/test.ts`;
        (0, globals_1.expect)((0, PathExtractor_1.extractPath)(content, ["src"])).toBe("src/utils/test.ts");
    });
    (0, globals_1.it)("should extract Unix-style path starting with subdirectory from comment", () => {
        const content = `// File: /src/utils/test.ts`;
        (0, globals_1.expect)((0, PathExtractor_1.extractPath)(content, ["src"])).toBe("src/utils/test.ts");
    });
    (0, globals_1.it)("should extract Windows-style path from comment and return from first 'src' occurrence", () => {
        const content = `// File: C:\\Program Files\\MyApp\\src\\utils\\test.ts`;
        (0, globals_1.expect)((0, PathExtractor_1.extractPath)(content, ["src"])).toBe("src\\utils\\test.ts");
    });
    (0, globals_1.it)("should extract full path from comment when no specified subdirectory is found", () => {
        const content = `// File: /usr/local/myapp/utils/test.ts`;
        (0, globals_1.expect)((0, PathExtractor_1.extractPath)(content, ["src", "docs"])).toBe("/usr/local/myapp/utils/test.ts");
    });
    (0, globals_1.it)("should extract path from comment with multiple subdirectory options", () => {
        const content = `// File: /usr/local/myapp/docs/src/utils/test.ts`;
        (0, globals_1.expect)((0, PathExtractor_1.extractPath)(content, ["src", "docs"])).toBe("docs/src/utils/test.ts");
    });
});
//# sourceMappingURL=PathExtractor.test.js.map
```

## dist/types/index.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/types/index.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/*
 * Copyright (c) 2024 Martin Bechard (martin.bechard@DevConsult.ca)
 * This software is licensed under the MIT License.
 * File: types/index.ts
 * Credit: This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 * Summary: Core type definitions for the Claude extension
 * Witty remark: Because even AI needs a type system to keep it honest!
 */
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=index.js.map
```

## dist/ui/components/DraggableManager.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/ui/components/DraggableManager.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/*
 * Copyright (c) 2024 Martin Bechard (martin.bechard@DevConsult.ca)
 * This software is licensed under the MIT License.
 * File: ui/components/DraggableManager.ts
 * Credit: This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 * Summary: Manages draggable behavior for floating windows
 * Witty remark: Making elements draggable since 2024 - no weightlifting required!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DraggableManager = void 0;
/**
 * Manages draggable behavior for HTML elements.
 */
class DraggableManager {
    /**
     * Creates a new DraggableManager instance.
     * @param window - Element to make draggable
     * @param handle - Element that triggers dragging
     */
    constructor(window, handle) {
        this.isDragging = false;
        this.currentX = 0;
        this.currentY = 0;
        this.initialX = 0;
        this.initialY = 0;
        this.window = window;
        this.handle = handle;
        this.setupEventListeners();
    }
    /**
     * Sets up event listeners for drag behavior.
     */
    setupEventListeners() {
        this.handle.addEventListener("mousedown", this.handleMouseDown.bind(this));
        document.addEventListener("mousemove", this.handleMouseMove.bind(this));
        document.addEventListener("mouseup", this.handleMouseUp.bind(this));
    }
    /**
     * Handles the start of a drag operation.
     * @param e - Mouse event
     */
    handleMouseDown(e) {
        if (e.target === this.handle || this.handle.contains(e.target)) {
            this.isDragging = true;
            this.initialX = e.clientX - this.window.offsetLeft;
            this.initialY = e.clientY - this.window.offsetTop;
            this.window.style.position = "absolute";
            this.window.style.right = "auto";
        }
    }
    /**
     * Handles the drag movement.
     * @param e - Mouse event
     */
    handleMouseMove(e) {
        if (!this.isDragging)
            return;
        e.preventDefault();
        this.currentX = e.clientX - this.initialX;
        this.currentY = e.clientY - this.initialY;
        const bounds = this.calculateBounds();
        this.constrainToBounds(bounds);
        this.window.style.left = `${this.currentX}px`;
        this.window.style.top = `${this.currentY}px`;
    }
    /**
     * Calculates the bounds for dragging.
     * @returns Bounds object with min/max values
     */
    calculateBounds() {
        return {
            minX: 0,
            maxX: window.innerWidth - this.window.offsetWidth,
            minY: 0,
            maxY: window.innerHeight - this.window.offsetHeight,
        };
    }
    /**
     * Constrains the current position to the specified bounds.
     * @param bounds - Bounds to constrain to
     */
    constrainToBounds(bounds) {
        this.currentX = Math.max(bounds.minX, Math.min(this.currentX, bounds.maxX));
        this.currentY = Math.max(bounds.minY, Math.min(this.currentY, bounds.maxY));
    }
    /**
     * Handles the end of a drag operation.
     */
    handleMouseUp() {
        this.isDragging = false;
    }
    /**
     * Removes all event listeners.
     */
    destroy() {
        this.handle.removeEventListener("mousedown", this.handleMouseDown.bind(this));
        document.removeEventListener("mousemove", this.handleMouseMove.bind(this));
        document.removeEventListener("mouseup", this.handleMouseUp.bind(this));
    }
}
exports.DraggableManager = DraggableManager;
//# sourceMappingURL=DraggableManager.js.map
```

## dist/ui/components/FloatingWindow.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/ui/components/FloatingWindow.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/*
 * Copyright (c) 2024 Martin Bechard (martin.bechard@DevConsult.ca)
 * This software is licensed under the MIT License.
 * File: ui/components/FloatingWindow.ts
 * Credit: This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 * Summary: Manages the floating window interface for the extension
 * Witty remark: Making windows float like butterflies, but typing like bees!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FloatingWindow = void 0;
/**
 * Manages the floating window interface for the extension.
 */
class FloatingWindow {
    constructor() {
        this.element = null;
        this.outputDiv = null;
        this.isCollapsed = false;
        this.isMinimized = false;
        this.template = `
    <div class="floating-window">
      <div class="status ready">
        <div style="display: flex; align-items: center; gap: 5px; flex-grow: 1;">
          <span class="status-label">ClaudeScript - </span>
          <span class="status-text">READY</span>
          <span class="status-details"></span>
        </div>
        <button id="minimizeButton" style="font-size: 12px; padding: 2px 8px;">_</button>
        <button id="helpButton" style="font-size: 12px; padding: 2px 8px;">?</button>
      </div>
      <div class="input-container">
        <div class="script-container">
          <textarea id="scriptText" placeholder="Simple prompt:
Type your prompt here

-- or --

DO MAX 3 UNTIL success
Your prompt here"></textarea>
          <div class="resize-handle"></div>
        </div>
        <button id="runScript">Run Script</button>
        <div class="output-container">
          <div id="scriptOutput"></div>
          <div id="collapseButton" style="cursor: pointer; user-select: none; padding: 5px;"></div>
        </div>
      </div>
    </div>
  `;
    }
    /**
     * Creates and injects the floating window into the DOM.
     * @returns The floating window element
     * @throws Error if window creation fails
     */
    async create() {
        const container = document.createElement("div");
        container.innerHTML = this.template.trim();
        const window = container.querySelector(".floating-window");
        if (!window) {
            throw new Error("Failed to create floating window");
        }
        document.body.appendChild(container);
        this.element = window;
        this.outputDiv = this.element.querySelector("#scriptOutput");
        return this.element;
    }
    /**
     * Retrieves all UI elements managed by the floating window.
     * @returns Object containing all UI elements
     * @throws Error if any element is not found
     */
    getElements() {
        if (!this.element) {
            throw new Error("Floating window not initialized");
        }
        const elements = {
            window: this.element,
            status: this.element.querySelector(".status"),
            statusText: this.element.querySelector(".status-text"),
            statusDetails: this.element.querySelector(".status-details"),
            scriptText: this.element.querySelector("#scriptText"),
            runButton: this.element.querySelector("#runScript"),
            output: this.element.querySelector("#scriptOutput"),
            helpButton: this.element.querySelector("#helpButton"),
            collapseButton: this.element.querySelector("#collapseButton"),
            minimizeButton: this.element.querySelector("#minimizeButton"),
        };
        // Validate all elements exist and are of correct type
        for (const [key, value] of Object.entries(elements)) {
            if (!value) {
                throw new Error(`Failed to find element: ${key}`);
            }
        }
        // Type assertion is safe here because we validated all elements exist
        return elements;
    }
    /**
     * Retrieves the output element.
     * @returns The output element
     * @throws Error if output element not found
     */
    getOutputElement() {
        if (!this.outputDiv) {
            throw new Error("Output element not initialized");
        }
        return this.outputDiv;
    }
    /**
     * Logs a message to the output area.
     * @param message - Message to log
     * @param type - Type of message for styling
     */
    log(message, type = "info") {
        if (!this.outputDiv)
            return;
        const log = document.createElement("div");
        log.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        log.style.color =
            type === "error" ? "red" : type === "success" ? "green" : "black";
        this.outputDiv.appendChild(log);
        this.outputDiv.scrollTop = this.outputDiv.scrollHeight;
    }
    /**
     * Toggles the minimize state of the window.
     */
    toggleMinimize() {
        if (!this.element)
            return;
        // Save current dimensions before toggling
        const currentWidth = this.element.style.width;
        const currentHeight = this.element.style.height;
        this.isMinimized = !this.isMinimized;
        if (this.isMinimized) {
            // Store dimensions for restoration
            if (currentWidth && currentHeight) {
                this.element.dataset.prevWidth = currentWidth;
                this.element.dataset.prevHeight = currentHeight;
            }
            // Clear dimensions to allow shrinking
            this.element.style.width = "";
            this.element.style.height = "";
        }
        else {
            // Restore previous dimensions if they exist
            const prevWidth = this.element.dataset.prevWidth;
            const prevHeight = this.element.dataset.prevHeight;
            if (prevWidth && prevHeight) {
                this.element.style.width = prevWidth;
                this.element.style.height = prevHeight;
            }
        }
        // Toggle minimized class for CSS styling
        this.element.classList.toggle("minimized", this.isMinimized);
        const minimizeButton = this.element.querySelector("#minimizeButton");
        if (minimizeButton) {
            minimizeButton.textContent = this.isMinimized ? "" : "_";
            minimizeButton.title = this.isMinimized ? "Restore" : "Minimize";
        }
    }
    /**
     * Toggles the collapse state of the output panel.
     */
    toggleCollapse() {
        if (!this.outputDiv || !this.element)
            return;
        this.isCollapsed = !this.isCollapsed;
        if (this.isCollapsed) {
            // Store current window height for restoration
            const currentWindowHeight = this.element.style.height;
            if (currentWindowHeight) {
                this.element.dataset.prevHeight = currentWindowHeight;
            }
            // Store output height for restoration
            const currentOutputHeight = this.outputDiv.style.height;
            if (currentOutputHeight) {
                this.outputDiv.dataset.prevHeight = currentOutputHeight;
            }
            // Collapse output area
            this.outputDiv.style.maxHeight = "3em";
            this.outputDiv.style.overflowY = "hidden";
            // Shrink window to fit collapsed content
            this.element.style.height = "auto";
            this.element.style.minHeight = "auto";
        }
        else {
            // Restore window height
            const prevWindowHeight = this.element.dataset.prevHeight;
            if (prevWindowHeight) {
                this.element.style.height = prevWindowHeight;
                this.element.style.minHeight = "200px"; // Restore default min-height
            }
            // Restore output height
            const prevOutputHeight = this.outputDiv.dataset.prevHeight;
            if (prevOutputHeight) {
                this.outputDiv.style.height = prevOutputHeight;
            }
            this.outputDiv.style.maxHeight = "";
            this.outputDiv.style.overflowY = "auto";
        }
        const collapseButton = this.element?.querySelector("#collapseButton");
        if (collapseButton) {
            collapseButton.textContent = this.isCollapsed ? "" : "";
            collapseButton.title = this.isCollapsed ? "Expand" : "Collapse";
        }
    }
    /**
     * Waits for a DOM element to be available.
     * @param selector - CSS selector for the element
     * @param timeoutMs - Maximum time to wait in milliseconds
     * @returns The found element
     * @throws Error if element not found within timeout
     */
    async waitForElement(selector, timeoutMs = 30000) {
        console.log(`Waiting for element: ${selector} (timeout: ${timeoutMs}ms)`);
        return new Promise((resolve, reject) => {
            // First check if element already exists
            const existingElement = document.querySelector(selector);
            if (existingElement) {
                console.log(`Element ${selector} found immediately`);
                return resolve(existingElement);
            }
            let timeoutId;
            let startTime = Date.now();
            const observer = new MutationObserver((mutations, obs) => {
                const element = document.querySelector(selector);
                if (element) {
                    clearTimeout(timeoutId);
                    obs.disconnect();
                    console.log(`Element ${selector} found after ${Date.now() - startTime}ms`);
                    resolve(element);
                }
            });
            timeoutId = window.setTimeout(() => {
                observer.disconnect();
                console.log(`Timeout waiting for ${selector} after ${timeoutMs}ms`);
                console.log("Current page HTML:", document.body.innerHTML);
                reject(new Error(`Timeout waiting for element: ${selector}`));
            }, timeoutMs);
            observer.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: true,
                characterData: true,
            });
            console.log(`Started observing for ${selector}`);
        });
    }
    /**
     * Clears the output panel.
     */
    clearOutput() {
        if (this.outputDiv) {
            this.outputDiv.innerHTML = "";
        }
    }
    /**
     * Removes the floating window from the DOM.
     */
    destroy() {
        this.element?.parentElement?.remove();
        this.element = null;
        this.outputDiv = null;
    }
}
exports.FloatingWindow = FloatingWindow;
//# sourceMappingURL=FloatingWindow.js.map
```

## dist/ui/components/HelpManager.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/ui/components/HelpManager.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/*
 * Copyright (c) 2024 Martin Bechard (martin.bechard@DevConsult.ca)
 * This software is licensed under the MIT License.
 * File: ui/components/HelpManager.ts
 * Credit: This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 * Summary: Manages help text display and formatting
 * Witty remark: Helping users help themselves, one pre-formatted line at a time!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HelpManager = void 0;
/**
 * Manages help text display and formatting for the extension.
 */
class HelpManager {
    /**
     * Creates a new HelpManager instance.
     * @param outputElement - Element to display help text in
     */
    constructor(outputElement) {
        this.outputElement = outputElement;
    }
    /**
     * Displays the help text in the output element.
     */
    show() {
        this.outputElement.innerHTML = "";
        HelpManager.HELP_TEXT.split("\n").forEach((line) => {
            const div = document.createElement("div");
            div.textContent = line;
            div.style.whiteSpace = "pre";
            this.outputElement.appendChild(div);
        });
    }
    /**
     * Updates the help text content dynamically.
     * @param newText - New help text content
     */
    updateContent(newText) {
        this.outputElement.innerHTML = "";
        newText
            .trim()
            .split("\n")
            .forEach((line) => {
            const div = document.createElement("div");
            div.textContent = line;
            div.style.whiteSpace = "pre";
            this.outputElement.appendChild(div);
        });
    }
    /**
     * Clears the help text display.
     */
    clear() {
        this.outputElement.innerHTML = "";
    }
}
exports.HelpManager = HelpManager;
HelpManager.HELP_TEXT = `
      ClaudeScript v1.5
      
      1. Simple Prompt:
      Just type your prompt and it will be sent once.
      
      2. Loop Until Format:
      First line: DO [MAX <number>] UNTIL <text>
      Following lines: Your prompt
      
      3. Commands:
      /docs - List available documents
      
      Examples:
      -------------------
      Simple prompt:
      Tell me a joke
      
      -------------------
      With search:
      DO UNTIL laugh
      Tell me a joke
      
      -------------------
      With max tries:
      DO MAX 3 UNTIL success
      Do something`.trim();
//# sourceMappingURL=HelpManager.js.map
```

## dist/ui/components/StatusManager.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/ui/components/StatusManager.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/*
 * Copyright (c) 2024 Martin Bechard (martin.bechard@DevConsult.ca)
 * This software is licensed under the MIT License.
 * File: ui/components/StatusManager.ts
 * Credit: This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 * Summary: Manages the status display and state for the floating window
 * Witty remark: Managing states like a traffic light, but with better error messages!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StatusManager = void 0;
/**
 * Manages the display and updates of status information.
 */
class StatusManager {
    /**
     * Creates a new StatusManager instance.
     * @param elements - Required DOM elements for status management
     */
    constructor(elements) {
        this.currentState = "ready";
        this.elements = elements;
        this.initializeStatus();
    }
    /**
     * Sets up initial status display.
     */
    initializeStatus() {
        this.setStatus("ready");
    }
    /**
     * Updates the current status display.
     * @param state - New status state to display
     * @param details - Optional details message
     */
    async setStatus(state, details = "") {
        console.log("Status:", state, details);
        const config = StatusManager.STATUS_CONFIGS[state];
        this.elements.statusText.textContent = config.text;
        this.elements.statusDetails.textContent = details;
        this.elements.statusElement.className = `status ${config.class}`;
        this.currentState = state;
        this.updateInputState(state);
        this.updateButtonState(state);
    }
    /**
     * Updates the input field state based on status.
     * @param state - Current status state
     */
    updateInputState(state) {
        this.elements.scriptInput.disabled = state === "working";
    }
    /**
     * Updates the run button state based on status.
     * @param state - Current status state
     */
    updateButtonState(state) {
        if (state === "working") {
            this.elements.runButton.textContent = "Cancel";
            this.elements.runButton.disabled = false;
        }
        else {
            this.elements.runButton.textContent = "Run Script";
            this.elements.runButton.disabled = false;
        }
    }
    /**
     * Gets the current status state.
     * @returns Current status state
     */
    getCurrentState() {
        return this.currentState;
    }
    /**
     * Checks if the status is in a specific state.
     * @param state - State to check
     * @returns True if current state matches
     */
    isInState(state) {
        return this.currentState === state;
    }
}
exports.StatusManager = StatusManager;
StatusManager.STATUS_CONFIGS = {
    ready: { text: "READY", class: "ready" },
    working: { text: "WORKING", class: "working" },
    error: { text: "ERROR", class: "error" },
};
//# sourceMappingURL=StatusManager.js.map
```

## dist/utils/ElementWaiter.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/utils/ElementWaiter.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/utils/ElementWaiter.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Utility class for waiting for DOM elements to appear with robust timeout handling.
 * Fun fact: Even the most patient element waiter sometimes wishes elements would show up faster!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElementWaiter = void 0;
class ElementWaiter {
    /**
     * Wait for a single element to appear
     * @param selector CSS selector to wait for
     * @returns Promise resolving to the found element
     * @throws Error if element not found within timeout
     */
    static waitForElement(selector) {
        console.log(`Waiting for element: ${selector}`);
        return new Promise((resolve, reject) => {
            // Set timeout
            const timeout = setTimeout(() => {
                observer.disconnect();
                reject(new Error(`Timeout waiting for element: ${selector}`));
            }, this.TIMEOUT);
            // Check immediately first
            const element = document.querySelector(selector);
            if (element) {
                console.log(`Element found immediately: ${selector}`);
                clearTimeout(timeout);
                return resolve(element);
            }
            // Watch for changes
            const observer = new MutationObserver(() => {
                const element = document.querySelector(selector);
                if (element) {
                    console.log(`Element found after mutation: ${selector}`);
                    clearTimeout(timeout);
                    observer.disconnect();
                    resolve(element);
                }
            });
            // Start observing
            observer.observe(document.body, {
                childList: true,
                subtree: true,
            });
        });
    }
    /**
     * Wait for both required Claude interface elements
     * @returns Promise resolving when both elements are found
     * @throws Error if either element not found within timeout
     */
    static async waitForRequiredElements() {
        console.log("Waiting for Claude chat interface...");
        // Wait for container first
        await this.waitForElement(".chat-messages-container");
        console.log("Chat container found");
        // Then wait for input
        await this.waitForElement(".prompt-textarea");
        console.log("Input area found");
    }
}
exports.ElementWaiter = ElementWaiter;
ElementWaiter.TIMEOUT = 30000;
//# sourceMappingURL=ElementWaiter.js.map
```

## dist/utils/ScriptParser.js

```js
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/dist/utils/ScriptParser.js
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

"use strict";
/*
 * Copyright (c) 2024 Martin Bechard (martin.bechard@DevConsult.ca)
 * This software is licensed under the MIT License.
 * File: utils/ScriptParser.ts
 * Credit: This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 * Summary: Parser utility for script commands and syntax
 * Witty remark: Parsing scripts like a Shakespeare editor, but with more regex!
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptParser = void 0;
/**
 * Utility class for parsing script text into structured commands.
 */
class ScriptParser {
    /**
     * Parses raw script text into structured script object.
     * @param text - Raw script text to parse
     * @returns Parsed script object
     * @throws Error if script syntax is invalid
     */
    static parse(text) {
        const lines = text.split("\n");
        const firstLine = lines[0].trim();
        if (this.isCommand(firstLine)) {
            return this.parseCommand(firstLine);
        }
        if (this.isDoUntilScript(firstLine)) {
            return this.parseDoUntilScript(firstLine, lines);
        }
        return this.parseSimpleScript(lines);
    }
    /**
     * Checks if the line is a command.
     * @param line - Line to check
     * @returns True if line is a command
     */
    static isCommand(line) {
        return line.startsWith(this.COMMAND_PREFIX);
    }
    /**
     * Checks if the line is a DO UNTIL script.
     * @param line - Line to check
     * @returns True if line is a DO UNTIL script
     */
    static isDoUntilScript(line) {
        return this.DO_UNTIL_REGEX.test(line);
    }
    /**
     * Parses a command line into a script object.
     * @param line - Command line to parse
     * @returns Parsed script object
     */
    static parseCommand(line) {
        return {
            maxTries: 1,
            findText: null,
            prompt: line,
            isCommand: true,
            command: line.slice(1).trim(),
        };
    }
    /**
     * Parses a DO UNTIL script into a script object.
     * @param firstLine - First line containing DO UNTIL syntax
     * @param lines - All lines of the script
     * @returns Parsed script object
     * @throws Error if DO UNTIL syntax is invalid
     */
    static parseDoUntilScript(firstLine, lines) {
        const match = firstLine.match(this.DO_UNTIL_REGEX);
        if (!match) {
            throw new Error("Invalid DO UNTIL syntax. Use: DO [MAX <number>] UNTIL <text>");
        }
        const [, maxTriesStr, findText] = match;
        const prompt = lines.slice(1).join("\n").trim();
        if (!prompt) {
            throw new Error("No prompt provided after DO UNTIL line");
        }
        return {
            maxTries: maxTriesStr
                ? parseInt(maxTriesStr, 10)
                : this.DEFAULT_MAX_TRIES,
            findText: findText.trim(),
            prompt,
            isCommand: false,
            command: null,
        };
    }
    /**
     * Parses a simple script into a script object.
     * @param lines - Lines of the script
     * @returns Parsed script object
     * @throws Error if script is empty
     */
    static parseSimpleScript(lines) {
        const prompt = lines.join("\n").trim();
        if (!prompt) {
            throw new Error("No prompt provided");
        }
        return {
            maxTries: 1,
            findText: null,
            prompt,
            isCommand: false,
            command: null,
        };
    }
}
exports.ScriptParser = ScriptParser;
ScriptParser.DEFAULT_MAX_TRIES = 5;
ScriptParser.COMMAND_PREFIX = "/";
ScriptParser.DO_UNTIL_REGEX = /DO(?:\s+MAX\s+(\d+))?\s+UNTIL\s+(.+)/i;
//# sourceMappingURL=ScriptParser.js.map
```
