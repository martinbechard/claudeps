# tests

## tests/services/AliasService.test.ts

```ts
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/tests/services/AliasService.test.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import { describe, expect, it, beforeEach } from "@jest/globals";
import { AliasService } from "../../src/services/AliasService";
import { MemoryStorage } from "../../src/types/storage";

describe("AliasService", () => {
  beforeEach(() => {
    // Initialize with fresh MemoryStorage for each test
    AliasService.initialize(new MemoryStorage());
    AliasService.clearAllAliases();
  });

  describe("setAlias", () => {
    it("should store a valid alias", () => {
      AliasService.setAlias("test", "Hello World");
      expect(AliasService.getAlias("test")).toBe("Hello World");
    });

    it("should throw error for invalid alias name", () => {
      expect(() => AliasService.setAlias("test-invalid", "Hello")).toThrow(
        "Invalid alias name"
      );
    });
  });

  describe("deleteAlias", () => {
    it("should delete existing alias", () => {
      AliasService.setAlias("test", "Hello World");
      expect(AliasService.deleteAlias("test")).toBe(true);
      expect(AliasService.getAlias("test")).toBeUndefined();
    });

    it("should return false for non-existent alias", () => {
      expect(AliasService.deleteAlias("nonexistent")).toBe(false);
    });
  });

  describe("processText", () => {
    beforeEach(() => {
      AliasService.setAlias("hello", "Hello World");
      AliasService.setAlias("nested", "@hello there");
    });

    it("should replace simple aliases", () => {
      expect(AliasService.processText("@hello")).toBe("Hello World");
    });

    it("should handle nested aliases", () => {
      expect(AliasService.processText("@nested")).toBe("Hello World there");
    });

    it("should handle multiple aliases in text", () => {
      expect(AliasService.processText("@hello @hello")).toBe(
        "Hello World Hello World"
      );
    });

    it("should not replace partial matches", () => {
      expect(AliasService.processText("email@hello.com")).toBe(
        "email@hello.com"
      );
    });
  });

  describe("getAliasList", () => {
    it("should return formatted list of aliases", () => {
      AliasService.setAlias("test1", "Value 1");
      AliasService.setAlias("test2", "Value 2");
      const list = AliasService.getAliasList();
      expect(list).toContain("@test1: Value 1");
      expect(list).toContain("@test2: Value 2");
    });
  });
});

```

## tests/utils/PathExtractor.test.ts

```ts
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/tests/utils/PathExtractor.test.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Test suite for PathExtractor utility functions
 */
import { describe, expect, it } from "@jest/globals";
import {
  extractPath,
  extractPathFromComments,
  extractPathFromSpecialCases,
} from "@/utils/PathExtractor";

describe("PathExtractor", () => {
  describe("extractPathFromComments", () => {
    it("extracts path from single-line comments with File:", () => {
      const content = `// Copyright notice
// License info
// File: src/utils/test.ts
function test() {}`;
      expect(extractPathFromComments(content)).toBe("src/utils/test.ts");
    });

    it("extracts path from single-line comments with Path:", () => {
      const content = `// Copyright notice
// Path: src/components/Component.tsx
class Component {}`;
      expect(extractPathFromComments(content)).toBe(
        "src/components/Component.tsx"
      );
    });

    it("extracts path from block comments", () => {
      const content = `/*
 * Copyright notice
 * File: src/services/Service.ts
 */
class Service {}`;
      expect(extractPathFromComments(content)).toBe("src/services/Service.ts");
    });

    it("extracts path from block comments without asterisks", () => {
      const content = `/*
Copyright notice
File: src/models/Model.ts
*/
class Model {}`;
      expect(extractPathFromComments(content)).toBe("src/models/Model.ts");
    });

    it("handles Windows-style paths", () => {
      const content = `// File: C:\\Users\\dev\\src\\utils\\test.ts`;
      expect(extractPathFromComments(content)).toBe(
        "C:\\Users\\dev\\src\\utils\\test.ts"
      );
    });

    it("handles paths with spaces", () => {
      const content = `// File: /User Content/My Project/src/test.ts`;
      expect(extractPathFromComments(content)).toBe(
        "/User Content/My Project/src/test.ts"
      );
    });

    it("extracts path from absolute path format", () => {
      const content = `// /usr/local/src/test.ts`;
      expect(extractPathFromComments(content)).toBe("/usr/local/src/test.ts");
    });

    it("ignores paths after non-comment lines", () => {
      const content = `const x = 1;
// File: src/test.ts`;
      expect(extractPathFromComments(content)).toBeUndefined();
    });

    it("handles empty or whitespace content", () => {
      expect(extractPathFromComments("")).toBeUndefined();
      expect(extractPathFromComments("   \n   ")).toBeUndefined();
    });

    it("ignores paths after first 20 lines", () => {
      const content =
        Array(21).fill("// dummy line").join("\n") + "\n// File: src/test.ts";
      expect(extractPathFromComments(content)).toBeUndefined();
    });
  });

  describe("extractPathFromSpecialCases", () => {
    it("extracts path from JSON with _path", () => {
      const content = `{
                "_copyright": "Copyright notice",
                "_path": "/src/config.json"
            }`;
      expect(extractPathFromSpecialCases(content)).toBe("/src/config.json");
    });

    it("extracts path from JSON with _file", () => {
      const content = `{
                "_copyright": "Copyright notice",
                "_file": "/src/manifest.json"
            }`;
      expect(extractPathFromSpecialCases(content)).toBe("/src/manifest.json");
    });

    it("prefers _path over _file in JSON", () => {
      const content = `{
                "_path": "/src/config.json",
                "_file": "/src/other.json"
            }`;
      expect(extractPathFromSpecialCases(content)).toBe("/src/config.json");
    });

    it("returns undefined for invalid JSON", () => {
      const content = `{ invalid json }`;
      expect(extractPathFromSpecialCases(content)).toBeUndefined();
    });

    it("returns undefined for JSON without path properties", () => {
      const content = `{ "prop": "value" }`;
      expect(extractPathFromSpecialCases(content)).toBeUndefined();
    });
  });

  describe("extractPath", () => {
    it("extracts path from comments when available", () => {
      const content = `// File: src/test.ts`;
      expect(extractPath(content)).toBe("src/test.ts");
    });

    it("extracts path from JSON when available", () => {
      const content = `{ "_path": "/src/config.json" }`;
      expect(extractPath(content)).toBe("/src/config.json");
    });

    it("returns undefined when no path found", () => {
      const content = `const x = 1;`;
      expect(extractPath(content)).toBeUndefined();
    });

    it("handles real-world examples", () => {
      const examples = [
        {
          content: `/**
                     * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
                     * This software is licensed under the MIT License.
                     * File: /Users/martinbechard/dev/claudeext/src/ClaudeExtension.ts
                     */`,
          expected: "/Users/martinbechard/dev/claudeext/src/ClaudeExtension.ts",
        },
        {
          content: `{
                        "_copyright": "Copyright (c) 2024 Martin Bechard",
                        "_license": "MIT License",
                        "_path": "/Users/martinbechard/dev/claudeext/src/manifest.json"
                    }`,
          expected: "/Users/martinbechard/dev/claudeext/src/manifest.json",
        },
      ];

      examples.forEach(({ content, expected }) => {
        expect(extractPath(content)).toBe(expected);
      });
    });
  });
});

import { filterPathFromSubdirectories } from "@/utils/PathExtractor";

describe("filterPathFromSubdirectories", () => {
    it("should return path from first 'src' occurrence in Unix-style path", () => {
        const path = "/usr/local/myapp/src/utils/test.ts";
        expect(filterPathFromSubdirectories(path, ["src"])).toBe("src/utils/test.ts");
    });

    it("should handle Unix-style path starting with subdirectory", () => {
        const path = "/src/utils/test.ts";
        expect(filterPathFromSubdirectories(path, ["src"])).toBe("src/utils/test.ts");
    });

    it("should return path from first 'src' occurrence in Windows-style path", () => {
        const path = "C:\\Program Files\\MyApp\\src\\utils\\test.ts";
        expect(filterPathFromSubdirectories(path, ["src"])).toBe("src\\utils\\test.ts");
    });

    it("should return full path when no specified subdirectory is found", () => {
        const path = "/usr/local/myapp/utils/test.ts";
        expect(filterPathFromSubdirectories(path, ["src", "docs"])).toBe("/usr/local/myapp/utils/test.ts");
    });

    it("should handle path with multiple subdirectory options", () => {
        const path = "/usr/local/myapp/docs/src/utils/test.ts";
        expect(filterPathFromSubdirectories(path, ["src", "docs"])).toBe("docs/src/utils/test.ts");
    });
});

describe("extractPath with subdirectory filtering in comment blocks", () => {
    it("should extract path from comment and return from first 'src' occurrence", () => {
        const content = `// File: /usr/local/myapp/src/utils/test.ts`;
        expect(extractPath(content, ["src"])).toBe("src/utils/test.ts");
    });

    it("should extract Unix-style path starting with subdirectory from comment", () => {
        const content = `// File: /src/utils/test.ts`;
        expect(extractPath(content, ["src"])).toBe("src/utils/test.ts");
    });

    it("should extract Windows-style path from comment and return from first 'src' occurrence", () => {
        const content = `// File: C:\\Program Files\\MyApp\\src\\utils\\test.ts`;
        expect(extractPath(content, ["src"])).toBe("src\\utils\\test.ts");
    });

    it("should extract full path from comment when no specified subdirectory is found", () => {
        const content = `// File: /usr/local/myapp/utils/test.ts`;
        expect(extractPath(content, ["src", "docs"])).toBe("/usr/local/myapp/utils/test.ts");
    });

    it("should extract path from comment with multiple subdirectory options", () => {
        const content = `// File: /usr/local/myapp/docs/src/utils/test.ts`;
        expect(extractPath(content, ["src", "docs"])).toBe("docs/src/utils/test.ts");
    });
});

```

## tests/utils/ScriptParser.test.ts

```ts
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/tests/utils/ScriptParser.test.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import { describe, expect, it } from "@jest/globals";
import { ScriptParser } from "@/utils/ScriptParser";

describe("ScriptParser - Basic Structure", () => {
  it("should parse a single prompt", () => {
    const input = "Tell me a joke";
    const result = ScriptParser.parse(input);

    expect(result.statements).toHaveLength(1);
    expect(result.statements[0]).toEqual({
      prompt: "Tell me a joke",
      isCommand: false,
      command: null,
      options: {},
    });
  });

  it("should parse multiple prompts separated by semicolons", () => {
    const input = "Tell me a joke; What is the capital of France?";
    const result = ScriptParser.parse(input);

    expect(result.statements).toHaveLength(2);
    expect(result.statements[0].prompt).toBe("Tell me a joke");
    expect(result.statements[1].prompt).toBe("What is the capital of France?");
  });

  it("should handle semicolons in quoted text", () => {
    const input = 'Tell me a "long; complex" joke';
    const result = ScriptParser.parse(input);

    expect(result.statements).toHaveLength(1);
    expect(result.statements[0].prompt).toBe("Tell me a long; complex joke");
  });
});

describe("ScriptParser - Repeat Command", () => {
  it("should parse basic repeat command", () => {
    const input = `/repeat /max 3
Tell me a joke`;

    const result = ScriptParser.parse(input);
    expect(result.statements[0]).toEqual({
      isCommand: true,
      command: "repeat",
      options: {
        maxTries: 3,
      },
      prompt: "Tell me a joke",
    });
  });

  it("should use default maxTries when not specified", () => {
    const input = `/repeat
Tell me a joke`;

    const result = ScriptParser.parse(input);
    expect(result.statements[0].options?.maxTries).toBe(3);
  });

  it("should parse repeat with stop_if condition", () => {
    const input = `/repeat /max 3 
Tell me a joke /stop_if success`;

    const result = ScriptParser.parse(input);
    expect(result.statements[0].options).toEqual({
      maxTries: 3,
      stopConditions: [{ target: "success", type: "if" }],
    });
  });

  it("should parse repeat with stop_if_not condition", () => {
    const input = `/repeat Tell me a joke /max 3 /stop_if_not failure`;

    const result = ScriptParser.parse(input);
    expect(result.statements[0].options).toEqual({
      maxTries: 3,
      stopConditions: [{ target: "failure", type: "if_not" }],
    });
  });
});

describe("ScriptParser - Stop Conditions", () => {
  it("should parse standalone stop_if condition", () => {
    const input = `Tell me a joke /stop_if laugh`;
    const result = ScriptParser.parse(input);

    expect(result.statements[0].options).toEqual({
      stopConditions: [{ target: "laugh", type: "if" }],
    });
  });

  it("should parse standalone stop_if_not condition", () => {
    const input = `Tell me a joke /stop_if_not groan`;
    const result = ScriptParser.parse(input);

    expect(result.statements[0].options).toEqual({
      stopConditions: [{ target: "groan", type: "if_not" }],
    });
  });

  it("should parse quoted stop conditions", () => {
    const input = `Tell me a joke /stop_if "that was funny"`;
    const result = ScriptParser.parse(input);

    expect(result.statements[0].options).toEqual({
      stopConditions: [{ target: "that was funny", type: "if" }],
    });
  });
});

describe("ScriptParser - Alias Commands", () => {
  it("should parse alias definition", () => {
    const input = `/alias @greet Hello, how can I assist you today?`;
    const result = ScriptParser.parse(input);

    expect(result.statements[0]).toEqual({
      isCommand: true,
      command: "alias",
      aliasCommand: {
        type: "alias",
        name: "greet",
        text: "Hello, how can I assist you today?",
      },
      options: {},
    });
  });

  it("should parse alias deletion", () => {
    const input = `/delete_alias @greet`;
    const result = ScriptParser.parse(input);

    expect(result.statements[0]).toEqual({
      isCommand: true,
      command: "delete_alias",
      aliasCommand: {
        type: "delete_alias",
        name: "greet",
      },
      options: {},
    });
  });

  it("should parse alias list command", () => {
    const input = `/list_alias`;
    const result = ScriptParser.parse(input);

    expect(result.statements[0]).toEqual({
      isCommand: true,
      command: "list_alias",
      aliasCommand: {
        type: "list_alias",
      },
      options: {},
    });
  });
});

describe("ScriptParser - ClaudePS Commands", () => {
  it("should parse docs command", () => {
    const input = `/docs`;
    const result = ScriptParser.parse(input);

    expect(result.statements[0]).toEqual({
      prompt: "",
      isCommand: true,
      command: "docs",
      options: {},
    });
  });

  it("should parse project command", () => {
    const input = `/project`;
    const result = ScriptParser.parse(input);

    expect(result.statements[0]).toEqual({
      prompt: "",
      isCommand: true,
      command: "project",
      options: {},
    });
  });

  it("should parse conversation command with artifacts option", () => {
    const input = `/conversation /artifacts`;
    const result = ScriptParser.parse(input);

    expect(result.statements[0]).toEqual({
      prompt: "",
      isCommand: true,
      command: "conversation",
      options: {
        includeArtifacts: true,
        includeConversation: true,
      },
    });
  });

  it("should parse search_project command", () => {
    const input = `/search_project budget report`;
    const result = ScriptParser.parse(input);

    expect(result.statements[0]).toEqual({
      isCommand: true,
      command: "search_project",
      options: {},
      searchText: "budget report",
    });
  });

  it("should parse query_project command", () => {
    const input = `/query_project Summarize the key points discussed.`;
    const result = ScriptParser.parse(input);

    expect(result.statements[0]).toEqual({
      isCommand: true,
      command: "query_project",
      options: {},
      prompt: "Summarize the key points discussed.",
    });
  });
});

describe("ScriptParser - Command Abbreviations", () => {
  // Tests the /c /a abbreviation for conversation with artifacts
  it("should parse /c /a as conversation command with includeArtifacts option", () => {
    const input = "/c /a";
    const result = ScriptParser.parse(input);

    expect(result.statements[0].command).toBe("conversation");
    expect(result.statements[0]).toMatchObject({
      options: { includeArtifacts: true },
    });
  });

  // Tests the /d abbreviation for docs command
  it("should parse /d as docs command", () => {
    const input = "/d";
    const result = ScriptParser.parse(input);

    expect(result.statements[0].command).toBe("docs");
  });

  // Tests the /sp abbreviation for search_project command with search text
  it("should parse /sp with text as search_project command", () => {
    const input = "/sp report";
    const result = ScriptParser.parse(input);

    expect(result.statements[0].command).toBe("search_project");
    expect(result.statements[0]).toMatchObject({
      searchText: "report",
    });
  });

  // Tests the /qp abbreviation for query_project command with prompt
  it("should parse /qp with text as query_project command", () => {
    const input = "/qp summary";
    const result = ScriptParser.parse(input);

    expect(result.statements[0].command).toBe("query_project");
    expect(result.statements[0]).toMatchObject({
      prompt: "summary",
    });
  });
});

describe("ScriptParser - Error Handling", () => {
  it("should throw on invalid command", () => {
    expect(() => ScriptParser.parse("/invalid command")).toThrow(
      "Unknown command"
    );
  });

  it("should throw on missing prompt for query_project", () => {
    expect(() => ScriptParser.parse("/query_project")).toThrow(
      "Query project command requires a prompt"
    );
  });

  it("should throw on invalid alias syntax", () => {
    expect(() => ScriptParser.parse("/alias invalid")).toThrow(
      "Invalid alias syntax"
    );
  });

  it("should throw on conflicting stop conditions", () => {
    expect(() =>
      ScriptParser.parse("/repeat test /stop_if success /stop_if_not failure")
    ).toThrow("Cannot use both /stop_if and /stop_if_not options together");
  });
});

```

## tests/utils/splitText.processQuotedText.test.ts

```ts
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/tests/utils/splitText.processQuotedText.test.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import { processQuotedText } from "@/utils/splitText";

describe("processQuotedText", () => {
  // Empty or invalid inputs
  describe("empty or invalid inputs", () => {
    it("handles empty text", () => {
      const [result, endIndex] = processQuotedText("", 0, '"');
      expect(result).toBe("");
      expect(endIndex).toBe(0);
    });

    it("handles startIndex at text length", () => {
      const text = "abc";
      const [result, endIndex] = processQuotedText(text, text.length, '"');
      expect(result).toBe("");
      expect(endIndex).toBe(text.length);
    });

    it("handles startIndex beyond text length", () => {
      const text = "abc";
      const [result, endIndex] = processQuotedText(text, text.length + 1, '"');
      expect(result).toBe("");
      expect(endIndex).toBe(text.length + 1);
    });

    // This test documents the current behavior with invalid input
    it("exhibits undefined behavior with negative startIndex", () => {
      const [result, endIndex] = processQuotedText("abc", -1, '"');
      // Current behavior should be documented but might be considered a bug
      expect(endIndex).toBeGreaterThanOrEqual(0);
    });
  });

  // Quote character handling
  describe("quote character handling", () => {
    it("handles text with closing quote", () => {
      const text = 'abc"def';
      const [result, endIndex] = processQuotedText(text, 0, '"');
      expect(result).toBe("abc");
      expect(endIndex).toBe(4);
    });

    it("handles text without closing quote", () => {
      const text = "abcdef";
      const [result, endIndex] = processQuotedText(text, 0, '"');
      expect(result).toBe("abcdef");
      expect(endIndex).toBe(text.length);
    });

    it("handles empty quote character", () => {
      const text = "abcdef";
      const [result, endIndex] = processQuotedText(text, 0, "");
      expect(result).toBe("abcdef");
      expect(endIndex).toBe(text.length);
    });

    it("handles multi-character quote (treats as no match)", () => {
      const text = 'abc""def';
      const [result, endIndex] = processQuotedText(text, 0, '""');
      expect(result).toBe('abc""def');
      expect(endIndex).toBe(text.length);
    });
  });

  // Special character handling
  describe("special character handling", () => {
    it("handles different quote types", () => {
      const text = "abc'def";
      const [result, endIndex] = processQuotedText(text, 0, '"');
      expect(result).toBe("abc'def");
      expect(endIndex).toBe(text.length);
    });

    it("handles multi-byte characters", () => {
      const text = "abc👋def";
      const [result, endIndex] = processQuotedText(text, 0, '"');
      expect(result).toBe("abc👋def");
      expect(endIndex).toBe(text.length);
    });
  });
});

```

## tests/utils/splitText.processUnquotedText.test.ts

```ts
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/tests/utils/splitText.processUnquotedText.test.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import { processUnquotedText } from "@/utils/splitText";

describe("processUnquotedText", () => {
  // Empty or invalid inputs
  describe("empty or invalid inputs", () => {
    it("handles empty text", () => {
      const [result, endIndex, quoteChar] = processUnquotedText("", 0);
      expect(result).toBe("");
      expect(endIndex).toBe(0);
      expect(quoteChar).toBeNull();
    });

    it("handles startIndex at text length", () => {
      const text = "abc";
      const [result, endIndex, quoteChar] = processUnquotedText(
        text,
        text.length
      );
      expect(result).toBe("");
      expect(endIndex).toBe(text.length);
      expect(quoteChar).toBeNull();
    });

    // This test documents the current behavior with invalid input
    it("exhibits undefined behavior with negative startIndex", () => {
      const [result, endIndex, quoteChar] = processUnquotedText("abc", -1);
      // Current behavior should be documented but might be considered a bug
      expect(endIndex).toBeGreaterThanOrEqual(0);
    });
  });

  // Escape sequence handling
  describe("escape sequence handling", () => {
    it("handles escaped characters", () => {
      const text = "abc\\def";
      const [result, endIndex, quoteChar] = processUnquotedText(text, 0);
      expect(result).toBe("abcdef");
      expect(endIndex).toBe(text.length);
      expect(quoteChar).toBeNull();
    });

    it("handles escaped quotes", () => {
      const text = 'abc\\"def';
      const [result, endIndex, quoteChar] = processUnquotedText(text, 0);
      expect(result).toBe('abc"def');
      expect(endIndex).toBe(text.length);
      expect(quoteChar).toBeNull();
    });

    it("handles escaped followed by whitespace", () => {
      const text = "abc\\ def";
      const [result, endIndex, quoteChar] = processUnquotedText(text, 0);
      expect(result).toBe("abc");
      expect(endIndex).toBe(4);
      expect(quoteChar).toBeNull();
    });

    it("handles text ending with escape", () => {
      const text = "abc\\";
      const [result, endIndex, quoteChar] = processUnquotedText(text, 0);
      expect(result).toBe("abc");
      expect(endIndex).toBe(text.length);
      expect(quoteChar).toBeNull();
    });
  });

  // Quote handling
  describe("quote handling", () => {
    it("handles unquoted text until quote with accumulated text", () => {
      const text = 'abc"def';
      const [result, endIndex, quoteChar] = processUnquotedText(text, 0);
      expect(result).toBe("abc");
      expect(endIndex).toBe(3);
      expect(quoteChar).toBeNull();
    });

    it("detects quote at start with no accumulated text", () => {
      const text = '"abc';
      const [result, endIndex, quoteChar] = processUnquotedText(text, 0);
      expect(result).toBe("");
      expect(endIndex).toBe(0);
      expect(quoteChar).toBe('"');
    });

    it("handles mixed quotes", () => {
      const text = "abc'def";
      const [result, endIndex, quoteChar] = processUnquotedText(text, 0);
      expect(result).toBe("abc");
      expect(endIndex).toBe(3);
      expect(quoteChar).toBeNull();
    });
  });

  // Whitespace handling
  describe("whitespace handling", () => {
    it("handles unescaped whitespace", () => {
      const text = "abc def";
      const [result, endIndex, quoteChar] = processUnquotedText(text, 0);
      expect(result).toBe("abc");
      expect(endIndex).toBe(3);
      expect(quoteChar).toBeNull();
    });

    it("handles multiple whitespace characters", () => {
      const text = "abc   def";
      const [result, endIndex, quoteChar] = processUnquotedText(text, 0);
      expect(result).toBe("abc");
      expect(endIndex).toBe(3);
      expect(quoteChar).toBeNull();
    });
  });

  // Special character handling
  describe("special character handling", () => {
    it("handles multi-byte characters", () => {
      const text = "abc👋 def";
      const [result, endIndex, quoteChar] = processUnquotedText(text, 0);
      expect(result).toBe("abc👋");
      expect(endIndex).toBe(5);
      expect(quoteChar).toBeNull();
    });
  });
});

```

## tests/utils/splitTextWithQuotes.test.ts

```ts
/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/tests/utils/splitTextWithQuotes.test.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import { splitTextWithQuotes } from "@/utils/splitText";

describe("splitTextWithQuotes", () => {
  // Empty or whitespace-only inputs
  describe("empty or whitespace inputs", () => {
    it("handles empty text", () => {
      expect(splitTextWithQuotes("")).toEqual([]);
    });

    it("handles whitespace-only text", () => {
      expect(splitTextWithQuotes("   \t\n  ")).toEqual([]);
    });

    it("handles text with Unicode whitespace", () => {
      expect(splitTextWithQuotes(" \u2000\u2001 abc")).toEqual(["abc"]);
    });
  });

  // Quote handling
  describe("quote handling", () => {
    it("handles text starting with quote", () => {
      expect(splitTextWithQuotes('"abc" def')).toEqual(["abc", "def"]);
    });

    it("handles empty quoted strings", () => {
      expect(splitTextWithQuotes('""')).toEqual([]);
      expect(splitTextWithQuotes('" "')).toEqual([" "]);
    });

    it("handles alternating quoted/unquoted text", () => {
      expect(splitTextWithQuotes('abc "def" ghi')).toEqual([
        "abc",
        "def",
        "ghi",
      ]);
    });

    it("handles text ending with quote", () => {
      expect(splitTextWithQuotes('abc "def"')).toEqual(["abc", "def"]);
    });

    it("handles mixed quote types", () => {
      expect(splitTextWithQuotes(`"abc" 'def'`)).toEqual(["abc", "def"]);
    });
  });

  // Whitespace handling
  describe("whitespace handling", () => {
    it("collapses multiple whitespace between tokens", () => {
      expect(splitTextWithQuotes("abc   def    ghi")).toEqual([
        "abc",
        "def",
        "ghi",
      ]);
    });

    it("preserves whitespace in quotes", () => {
      expect(splitTextWithQuotes('"abc   def"')).toEqual(["abc   def"]);
    });

    it("handles text ending with whitespace", () => {
      expect(splitTextWithQuotes("abc def   ")).toEqual(["abc", "def"]);
    });
  });

  // Escape sequence handling
  describe("escape sequence handling", () => {
    it("handles escaped characters in unquoted text", () => {
      expect(splitTextWithQuotes("abc\\ def ghi")).toEqual([
        "abc",
        "def",
        "ghi",
      ]);
    });

    it("handles escaped quotes in unquoted text", () => {
      expect(splitTextWithQuotes('abc\\"def ghi')).toEqual(['abc"def', "ghi"]);
    });

    it("handles unescaped quotes in quoted text per Rule 2", () => {
      expect(splitTextWithQuotes('"abc\\"def" ghi')).toEqual([
        "abc\\", // Stops at " because Rule 2 says "NO special processing"
        "def", // New token after quote
        " ghi",
      ]);
    });
  });

  // Complex scenarios
  describe("complex scenarios", () => {
    it("handles multiple quoted sections per Rule 2", () => {
      expect(
        splitTextWithQuotes("abc\\ def \"ghi \\\" jkl\" 'mno\\' pqr'")
      ).toEqual([
        "abc",
        "def", // Unquoted text
        "ghi \\",

        "jkl", // Rest of double-quoted section
        " 'mno\\' pqr'", // Single-quoted section stops at ' per Rule 2
      ]);
    });

    it("handles quotes within unquoted text", () => {
      expect(splitTextWithQuotes('abc"def ghi')).toEqual(["abc", "def ghi"]);
    });

    it("handles multi-byte characters", () => {
      expect(splitTextWithQuotes('abc 👋 "def 👋" ghi')).toEqual([
        "abc",
        "👋",
        "def 👋",
        "ghi",
      ]);
    });

    it("handles multiple types of whitespace and quotes", () => {
      expect(splitTextWithQuotes("  abc \t\"def \n ghi\"\t'jkl'  ")).toEqual([
        "abc",
        "def \n ghi",
        "jkl",
      ]);
    });
  });
});

```
