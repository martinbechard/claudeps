/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/utils/EventStreamParser.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Handles parsing of Server-Sent Events from Claude API responses
 * Note: Making event streams as smooth as a well-oiled machine!
 */

/**
 * Basic event data structure
 */
interface EventData {
  type: string;
  completion?: string;
  id?: string;
  stop_reason?: string | null;
  model?: string;
  stop?: string | null;
  log_id?: string;
  messageLimit?: {
    type: string;
    resetsAt: string | null;
    remaining: number | null;
    perModelLimit: number | null;
  };
  completion_type?: string;
}

/**
 * Structured event with type and data
 */
interface StreamEvent {
  type: string;
  data: EventData;
}

/**
 * Parser for Server-Sent Events from Claude's API
 */
export class EventStreamParser {
  private buffer: string = "";
  private currentMessage: string = "";
  private isComplete: boolean = false;

  /**
   * Processes a chunk of data from the event stream
   * @param chunk - Raw chunk data from stream
   * @param onEvent - Optional callback for each parsed event
   * @returns The accumulated text content
   */
  public processChunk(
    chunk: string,
    onEvent?: (event: StreamEvent) => void
  ): string {
    // Add new data to buffer
    this.buffer += chunk;

    // Process complete events in buffer
    const events = this.buffer.split("\n\n");
    this.buffer = events.pop() || ""; // Keep last incomplete event

    for (const event of events) {
      if (!event.trim()) continue;

      try {
        const parsed = this.parseEvent(event);
        if (parsed) {
          if (onEvent) {
            onEvent(parsed);
          }
          this.processEvent(parsed);
        }
      } catch (error) {
        console.error("Error parsing event:", error);
      }
    }

    return this.currentMessage;
  }

  /**
   * Parses a single event string into structured data
   * @param eventString - Raw event data
   * @returns Parsed event data or null if invalid
   */
  private parseEvent(eventString: string): StreamEvent | null {
    const lines = eventString.split("\n");
    let eventType = "";
    let eventData: EventData | null = null;

    for (const line of lines) {
      if (!line.trim()) continue;

      const [field, ...values] = line.split(": ");
      const value = values.join(": ").trim();

      if (field === "event") {
        eventType = value;
      } else if (field === "data") {
        try {
          eventData = JSON.parse(value);
        } catch (error) {
          console.error("Error parsing event data:", error);
          return null;
        }
      }
    }

    // Require both event type and data
    if (!eventType || !eventData) {
      return null;
    }

    return {
      type: eventType,
      data: eventData,
    };
  }

  /**
   * Processes a parsed event and updates internal state
   * @param event - Parsed event data
   */
  private processEvent(event: StreamEvent): void {
    // Skip ping events
    if (event.type === "ping") return;

    // Handle completion events
    if (event.type === "completion" && event.data) {
      if (event.data.completion) {
        this.currentMessage += event.data.completion;
      }

      // Check for completion
      if (event.data.stop_reason) {
        this.isComplete = true;
      }
    }
  }

  /**
   * Gets the entire accumulated message
   */
  public getMessage(): string {
    return this.currentMessage;
  }

  /**
   * Checks if the message is complete
   */
  public isMessageComplete(): boolean {
    return this.isComplete;
  }

  /**
   * Resets the parser state
   */
  public reset(): void {
    this.buffer = "";
    this.currentMessage = "";
    this.isComplete = false;
  }
}
