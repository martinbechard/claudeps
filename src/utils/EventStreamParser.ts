/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/utils/EventStreamParser.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Handles parsing of Server-Sent Events from Claude API responses
 * Note: Making event streams as smooth as a well-oiled machine!
 */

/**
 * Basic event data structure
 */
interface EventData {
  type: string;
  completion?: string;
  id?: string;
  stop_reason?: string | null;
  model?: string;
  stop?: string | null;
  log_id?: string;
  messageLimit?: {
    type: string;
    resetsAt: string | null;
    remaining: number | null;
    perModelLimit: number | null;
  };
  completion_type?: string;
  delta?: {
    type: string;
    text: string;
  };
  message?: {
    content: any[];
    id: string;
    model: string;
    role: string;
    stop_reason: string | null;
    type: string;
  };
  content_block?: {
    type: string;
    text: string;
  };
}

/**
 * Structured event with type and data
 */
interface StreamEvent {
  type: string;
  data: EventData;
}

/**
 * Parser for Server-Sent Events from Claude's API
 */
export class EventStreamParser {
  private buffer: string = "";
  private currentMessage: string = "";
  private isComplete: boolean = false;
  private debug: boolean = false;
  private hasStarted: boolean = false;

  constructor(debug: boolean = false) {
    this.debug = debug;
  }

  /**
   * Processes a chunk of data from the event stream
   * @param chunk - Raw chunk data from stream
   * @param onEvent - Optional callback for each parsed event
   * @returns The accumulated text content
   */
  public processChunk(
    chunk: string,
    onEvent?: (event: StreamEvent) => void
  ): string {
    if (this.debug) {
      console.log("Processing chunk:", chunk);
    }

    // Add new data to buffer
    this.buffer += chunk;

    // Process complete events in buffer
    const events = this.buffer.split("\n\n");
    this.buffer = events.pop() || ""; // Keep last incomplete event

    for (const event of events) {
      if (!event.trim()) continue;

      try {
        const parsed = this.parseEvent(event);
        if (parsed) {
          if (this.debug) {
            console.log("Parsed event:", parsed);
          }
          if (onEvent) {
            onEvent(parsed);
          }
          this.processEvent(parsed);
        }
      } catch (error) {
        console.error("Error parsing event:", error);
        if (this.debug) {
          console.error("Raw event:", event);
        }
      }
    }

    return this.currentMessage;
  }

  /**
   * Parses a single event string into structured data
   * @param eventString - Raw event data
   * @returns Parsed event data or null if invalid
   */
  private parseEvent(eventString: string): StreamEvent | null {
    const lines = eventString.split("\n");
    let eventType = "";
    let eventData: EventData | null = null;

    for (const line of lines) {
      if (!line.trim()) continue;

      const [field, ...values] = line.split(": ");
      const value = values.join(": ").trim();

      if (field === "event") {
        eventType = value;
      } else if (field === "data") {
        try {
          eventData = JSON.parse(value);
        } catch (error) {
          if (this.debug) {
            console.error("Error parsing event data:", error);
            console.error("Raw data:", value);
          }
          return null;
        }
      }
    }

    // Require both event type and data
    if (!eventType || !eventData) {
      return null;
    }

    return {
      type: eventType,
      data: eventData,
    };
  }

  /**
   * Processes a parsed event and updates internal state
   * @param event - Parsed event data
   */
  private processEvent(event: StreamEvent): void {
    if (this.debug) {
      console.log("Processing event type:", event.type);
    }

    // Skip ping events
    if (event.type === "ping") return;

    // Handle message start
    if (event.type === "message_start") {
      this.hasStarted = true;
      return;
    }

    // Handle content block delta events
    if (event.type === "content_block_delta" && event.data.delta?.text) {
      if (!this.hasStarted) {
        if (this.debug) {
          console.warn("Received content before message_start");
        }
        this.hasStarted = true;
      }
      this.currentMessage += event.data.delta.text;
      return;
    }

    // Handle completion events (legacy support)
    if (event.type === "completion" && event.data.completion) {
      if (!this.hasStarted) {
        if (this.debug) {
          console.warn("Received completion before message_start");
        }
        this.hasStarted = true;
      }
      this.currentMessage += event.data.completion;
    }

    // Check for completion
    if (
      event.type === "message_complete" ||
      (event.data.stop_reason && event.data.stop_reason !== null)
    ) {
      if (this.debug) {
        console.log("Message complete, final content:", this.currentMessage);
      }
      this.isComplete = true;
    }
  }

  /**
   * Gets the entire accumulated message
   */
  public getMessage(): string {
    return this.currentMessage;
  }

  /**
   * Checks if the message is complete
   */
  public isMessageComplete(): boolean {
    return this.isComplete;
  }

  /**
   * Checks if message streaming has started
   */
  public hasMessageStarted(): boolean {
    return this.hasStarted;
  }

  /**
   * Resets the parser state
   */
  public reset(): void {
    this.buffer = "";
    this.currentMessage = "";
    this.isComplete = false;
    this.hasStarted = false;
  }
}
