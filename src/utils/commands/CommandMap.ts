/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/utils/commands/CommandMap.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Defines commands and their options
 */

/**
 * Type of argument required for an option
 */
export type OptionType = "no_arg" | "with_arg" | "with_prompt";

/**
 * Option format:
 * key: option name
 * value: OptionType indicating argument requirement
 */
type CommandOptionDefinitions = { [key: string]: OptionType };

/**
 * Base command info without options
 */
interface BaseCommandInfo {
  full: string;
  abbreviation: string;
  options?: CommandOptionDefinitions;
}

/**
 * Maps command names to their full names, abbreviations and allowed options
 */
export const COMMAND_MAP: { [key: string]: BaseCommandInfo } = {
  // Basic commands
  repeat: {
    full: "repeat",
    abbreviation: "r",
    options: {
      max: "with_arg", // Requires number argument
      stop_if: "with_prompt", // Requires condition text
      stop_if_not: "with_prompt", // Requires condition text
    },
  },

  prompt: {
    full: "prompt",
    abbreviation: "",
    options: {
      stop_if: "with_prompt", // Requires condition text
      stop_if_not: "with_prompt", // Requires condition text
    },
  },

  // Content commands
  conversation: {
    full: "conversation",
    abbreviation: "c",
    options: {
      artifacts: "no_arg", // Flag only
      a: "no_arg", // Flag only
      multiple: "no_arg", // Flag only
      m: "no_arg", // Flag only
    },
  },

  stop_if: {
    full: "stop_if",
    abbreviation: "",
  },

  stop_if_not: {
    full: "stop_if_not",
    abbreviation: "",
  },

  artifacts: {
    full: "artifacts",
    abbreviation: "a",
    options: {
      multiple: "no_arg", // Flag only
    },
  },

  // Project commands with no options
  knowledge: { full: "knowledge", abbreviation: "k" },
  project: { full: "project", abbreviation: "p" },
  search_project: { full: "search_project", abbreviation: "sp" },
  query_project: { full: "query_project", abbreviation: "qp" },

  // Alias commands (with @ syntax support)
  alias: { full: "alias", abbreviation: "@+" },
  list_alias: { full: "list_alias", abbreviation: "@?" },
  delete_alias: { full: "delete_alias", abbreviation: "@-" },
} as const;

export type CommandName = keyof typeof COMMAND_MAP;

/**
 * Gets the full command name for an abbreviation
 */
export function getFullCommand(abbr: string): string | undefined {
  // Handle the special case where alias command starts with @
  if (abbr.startsWith("@")) {
    switch (abbr) {
      case "@+":
        return "alias";
      case "@-":
        return "delete_alias";
      case "@?":
        return "list_alias";
      default:
        return undefined;
    }
  }

  const entry = Object.entries(COMMAND_MAP).find(
    ([_, info]) => info.abbreviation === abbr.toLowerCase()
  );
  return entry?.[0];
}

/**
 * Gets all possible command matches for a partial string
 */
export function getCommandMatches(partial: string): CommandName[] {
  // Handle special alias abbreviations
  if (partial.startsWith("@")) {
    switch (partial) {
      case "@+":
        return ["alias"];
      case "@-":
        return ["delete_alias"];
      case "@?":
        return ["list_alias"];
    }
  }

  const search = partial.toLowerCase();
  return Object.entries(COMMAND_MAP)
    .filter(([command, info]) => {
      return info.full === search || info.abbreviation.toLowerCase() === search;
    })
    .map(([command]) => command as CommandName);
}

/**
 * Gets the option requirements for a command
 */
export function getCommandOptionDefinitions(
  command: string
): { [key: string]: OptionType } | undefined {
  const commands = getCommandMatches(command);

  return COMMAND_MAP[commands[0] as CommandName]?.options;
}
