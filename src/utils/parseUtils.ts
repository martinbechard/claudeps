/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /src/utils/parseUtils.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import type { CommandOptions, ScriptStatement } from "../types";

/**
 * Maps command aliases to their full names and abbreviations
 */
export type CommandMap = {
  [key: string]: {
    full: string;
    abbreviation: string;
  };
};

/**
 * Processes condition text by removing surrounding quotes
 * @param text Condition text to process
 * @returns Processed text
 */
export function processConditionText(text: string): string {
  const trimmed = text.trim();
  // Remove surrounding quotes if present
  if (
    (trimmed.startsWith('"') && trimmed.endsWith('"')) ||
    (trimmed.startsWith("'") && trimmed.endsWith("'"))
  ) {
    return trimmed.slice(1, -1);
  }
  return trimmed;
}

/**
 * Splits text into statements respecting quotes
 * @param text Text to split
 * @returns Array of statement strings
 */
export function splitStatements(text: string): string[] {
  const statements: string[] = [];
  let current = "";
  let inQuotes = false;
  let inSingleQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const char = text[i];

    // Handle quote toggling
    if (char === '"' && !inSingleQuotes) {
      inQuotes = !inQuotes;
      current += char;
    } else if (char === "'" && !inQuotes) {
      inSingleQuotes = !inSingleQuotes;
      current += char;
    }
    // Handle statement separation
    else if (char === ";" && !inQuotes && !inSingleQuotes) {
      if (current.trim()) {
        statements.push(current.trim());
      }
      current = "";
    }
    // Handle newlines (treat like semicolons when not in quotes)
    else if (char === "\n" && !inQuotes && !inSingleQuotes) {
      if (current.trim()) {
        statements.push(current.trim());
      }
      current = "";
    }
    // Collect all other characters
    else {
      current += char;
    }
  }

  // Add final statement if not empty
  if (current.trim()) {
    statements.push(current.trim());
  }

  // Filter out empty statements
  return statements.filter((stmt) => stmt.length > 0);
}

/**
 * Parses command options from a command line
 * @param commandLine Command line to parse
 * @param optionMap Map of valid options
 * @returns Parsed command options
 */
export function parseCommandOptions(
  commandLine: string,
  optionMap: CommandMap
): CommandOptions {
  const options: CommandOptions = {};
  const parts = commandLine.trim().split(/\s+/);

  parts.forEach((part) => {
    if (!part.startsWith("/")) return;

    const option = part.slice(1).toLowerCase();
    const matches = Object.entries(optionMap).filter(([key, info]) => {
      return (
        key.toLowerCase().startsWith(option) ||
        info.abbreviation.toLowerCase() === option
      );
    });

    if (matches.length === 0) {
      throw new Error(`Invalid option: ${part}`);
    }

    if (matches.length > 1) {
      const possibilities = matches
        .map(([key, info]) => `${info.full} (/${info.abbreviation})`)
        .join(", ");
      throw new Error(`Ambiguous option '${part}'. Could be: ${possibilities}`);
    }

    const [fullOption] = matches[0];
    switch (fullOption) {
      case "artifacts":
        options.includeArtifacts = true;
        break;
      case "multiple":
        options.downloadMultiple = true;
        break;
    }
  });

  return options;
}
