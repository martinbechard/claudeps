/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/utils/ScriptParser.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import {
  Script,
  ScriptStatement,
  ParsedCommandLine as ParsedCommandText,
  StopCondition,
} from "../types";
import { parseStopConditionCommand } from "./commands/parseStopConditions";
import {
  getCommandMatches,
  getCommandOptionDefinitions,
  OptionType,
} from "./commands/CommandMap";
import { parseRepeatCommand } from "./commands/parseRepeatCommand";
import { parseAliasCommand } from "./commands/parseAliasCommand";
import {
  parseProjectCommand,
  parseSearchProjectCommand,
  parseQueryProjectCommand,
} from "./commands/parseProjectCommands";
import {
  parseConversationCommand,
  parseArtifactsCommand,
} from "./commands/parseContentCommands";
import { splitTextWithQuotes } from "./splitText";
import { parseDocsCommand } from "./commands/parseDocsCommand";

export class ScriptParser {
  private static readonly COMMAND_PREFIX = "/";

  /**
   * Parses text into a Script object
   */
  public static parse(text: string): Script {
    const statements = this.parseStatements(text);
    return { statements };
  }

  /**
   * Splits text into statements while preserving quoted strings
   */
  private static parseStatements(text: string): ScriptStatement[] {
    const statements: ScriptStatement[] = [];
    let current = "";
    let inQuotes = false;
    let quoteChar: string | null = null;

    for (let i = 0; i < text.length; i++) {
      const char = text[i];

      // Handle quoted text
      if ((char === '"' || char === "'") && !inQuotes) {
        inQuotes = true;
        quoteChar = char;
        current += char;
      } else if (char === quoteChar && inQuotes) {
        inQuotes = false;
        quoteChar = null;
        current += char;
      }
      // Handle statement separators
      else if (char === ";" && !inQuotes) {
        if (current.trim()) {
          statements.push(this.parseStatement(current.trim()));
        }
        current = "";
      }
      // Collect characters
      else {
        current += char;
      }
    }

    // Handle final statement
    if (current.trim()) {
      statements.push(this.parseStatement(current.trim()));
    }

    const finalStatements: ScriptStatement[] = [];
    statements.forEach((statement) => {
      if (
        statement.command === "stop_if" ||
        statement.command === "stop_if_not"
      ) {
        const last = finalStatements[0];
        if (!last) {
          throw new Error("Stop statement without preceding prompt.");
        }

        last.addStopCondition({
          target: statement.prompt || "",
          type: statement.command === "stop_if" ? "if" : "if_not",
        });
      } else {
        finalStatements.push(statement);
      }
    });

    return finalStatements;
  }

  /**
   * Parses a single statement with stop conditions
   */
  private static parseStatement(text: string): ScriptStatement {
    const statementText = text.trim();

    // Parse main statement (command or prompt)
    /*let statement = statementText.startsWith(this.COMMAND_PREFIX)
      ? this.parseCommandStatement(statementText)
      : this.parsePromptStatement(statementText);
*/
    const statement = this.parseCommandStatement(statementText);
    return statement;
  }

  /**
   * Parses a prompt statement
   */
  private static parsePromptStatement(text: string): ScriptStatement {
    return new ScriptStatement({
      prompt: text,
      isCommand: false,
      command: null,
    });
  }

  /**
   * Parses a command statement
   */
  private static parseCommandStatement(text: string): ScriptStatement {
    const parsed = this.parseCommandText(text);

    switch (parsed.command) {
      case "repeat":
        return parseRepeatCommand(parsed);
      case "stop_if":
      case "stop_if_not":
        return parseStopConditionCommand(parsed);
      case "alias":
      case "list_alias":
      case "delete_alias":
        return parseAliasCommand(parsed);
      case "project":
        return parseProjectCommand(parsed);
      case "search_project":
        return parseSearchProjectCommand(parsed);
      case "query_project":
        return parseQueryProjectCommand(parsed);
      case "conversation":
        return parseConversationCommand(parsed);
      case "artifacts":
        return parseArtifactsCommand(parsed);
      case "docs":
        return parseDocsCommand(parsed);
      case "prompt": {
        const statement = this.parsePromptStatement(parsed.prompt);
        const stopIfCondition = parsed?.options?.["stop_if"];
        const stopIfNotCondition = parsed?.options?.["stop_if_not"];

        if (stopIfCondition || stopIfNotCondition) {
          statement.addStopCondition({
            target: stopIfCondition || stopIfNotCondition,
            type: stopIfCondition ? "if" : "if_not",
          });
        }

        return statement;
      }
      default:
        throw new Error(`Unhandled command: ${parsed.command}`);
    }
  }

  /**
   * Parses a multi-line command text
   */
  private static parseCommandText(text: string): ParsedCommandText {
    const isCommand = text.startsWith(this.COMMAND_PREFIX);

    // Extract command and remaining text
    const parts = splitTextWithQuotes(text);

    const rawCommand = isCommand ? parts[0] : "";
    let commandName = isCommand ? rawCommand.substring(1) : "prompt";

    if (isCommand) {
      // Resolve command
      const matches = getCommandMatches(commandName);
      if (matches.length === 0) {
        throw new Error(`Unknown command: ${rawCommand}`);
      }
      if (matches.length > 1) {
        throw new Error(
          `Ambiguous command '${rawCommand}'. Could be: ${matches.join(", ")}`
        );
      }
      commandName = matches[0].toString();
    }

    // Parse options and content
    const options: Record<string, string> = {};
    let promptParts: string[] = [];

    for (let i = isCommand ? 1 : 0; i < parts.length; i++) {
      const part = parts[i];

      if (part.startsWith(this.COMMAND_PREFIX)) {
        const definitions = getCommandOptionDefinitions(commandName);
        if (!definitions) {
          throw new Error(
            `invalid option: "${part}", command "${commandName}" has no options`
          );
        }

        // Parse option
        const optionKey = part.substring(1);
        const option = definitions[optionKey];

        if (!option) {
          throw new Error(
            `invalid option: "${part}", command "${rawCommand}" has options: ${JSON.stringify(
              Object.keys(definitions)
            )}`
          );
        }

        if (option === "with_arg") {
          i++;
          if (i < parts.length) {
            options[optionKey] = parts[i];
          } else {
            throw new Error(
              `Missing value for option: "${part}", command "${rawCommand}"`
            );
          }
        } else if (option === "with_prompt") {
          i++;
          let arg = "";
          while (i < parts.length) {
            const nextPart = parts[i];
            if (nextPart.startsWith(this.COMMAND_PREFIX)) {
              i--;
              break;
            }
            arg = (arg ? " " + arg : "") + parts[i];
            i++;
          }

          if (!arg) {
            throw new Error(
              `Missing value for option: "${part}", command "${rawCommand}"`
            );
          }
          options[optionKey] = arg;
        } else {
          options[optionKey] = "true";
        }
      } else {
        promptParts.push(part);
      }
    }

    return {
      command: commandName,
      rawCommand,
      options,
      prompt: promptParts.join(" "),
    };
  }
}
