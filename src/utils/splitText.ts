// splitTextWithQuotes.ts
/*
 * Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
 * This software is licensed under the MIT License.
 * File path: src/utils/splitText.ts
 * Generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Splits text into tokens, handling quoted strings and escape sequences in unquoted text.
 */

/**
 * Text splitting rules:
 *
 * For processQuotedText(text, startIndex, quoteChar):
 * 1. Starts AFTER the opening quote (startIndex is position after quote)
 * 2. Collects ALL characters literally, with NO special processing - this means any quoteChar is an unescaped quoteChar
 * 3. Stops at the first occurrence of quoteChar
 * 4. Returns:
 *    * result: all characters collected up to (but not including) quoteChar
 *    * position: index after the quoteChar
 *
 * For processUnquotedText(text, startIndex):
 * 1. When sees backslash:
 *    * Skips the backslash
 *    * Takes next character literally unless it's a whitespace since that's a delimitor
 * 2. When sees unescaped quote:
 *    * If has collected chars: returns [collected, quotePos, null]
 *    * If no collected chars: returns ["", quotePos, quoteChar]
 * 3. When sees unescaped whitespace:
 *    * Returns [collected, whitespacePos, null]
 * 4. Returns:
 *    * result: collected characters with escape processing
 *    * position: where it stopped
 *    * quoteChar: quote character found (if any) or null
 *
 * For splitTextWithQuotes(text):
 * 1. Skips leading whitespace
 * 2. If sees quote:
 *    * Calls processQuotedText
 *    * Skips trailing whitespace after quote
 * 3. If sees non-quote:
 *    * Calls processUnquotedText
 *    * If it returned a quote char, continues at same position
 *    * If no quote char, skips trailing whitespace
 * 4. Repeats until end of text
 * 5. Only adds non-empty tokens to result array
 * 6. Spaces cannot be escaped
 */

export function processQuotedText(
  text: string,
  startIndex: number,
  quoteChar: string
): [string, number] {
  let result = "";
  let i = startIndex;

  while (i < text.length) {
    const char = text[i];
    if (char === quoteChar) {
      return [result, i + 1]; // Skip past closing quote
    }
    result += char;
    i++;
  }

  return [result, i]; // No closing quote found, return all remaining text
}

/**
 * Processes unquoted text, splitting at whitespace and handling escape sequences.
 * Watches for quotes to enable mode switching.
 */

export function processUnquotedText(
  text: string,
  startIndex: number
): [string, number, string | null] {
  let result = "";
  let i = startIndex;
  let escaped = false;

  while (i < text.length) {
    const char = text[i];

    if (escaped) {
      if (/\s/.test(char)) {
        // Stop at escaped whitespace - it's a delimiter
        return [result, i, null];
      }
      // For non-whitespace, add literally
      result += char;
      escaped = false;
      i++;
      continue;
    }

    if (char === "\\") {
      escaped = true;
      i++;
      continue;
    }

    if (/\s/.test(char) && !escaped) {
      // Any unescaped whitespace is a delimiter
      return [result, i, null];
    }

    if ((char === '"' || char === "'") && !escaped) {
      // Handle both quote types the same way
      if (result === "") {
        // If we haven't collected any chars, return the quote char found
        return ["", i, char];
      }
      // If we have collected chars, return them and let caller handle the quote
      return [result, i, null];
    }

    result += char;
    i++;
  }

  return [result, i, null];
}

/**
 * Splits a given text into tokens based on whitespace and quotes.
 * Processes escape sequences only in unquoted text.
 */
export function splitTextWithQuotes(text: string): string[] {
  const result: string[] = [];
  let i = 0;
  text = text.trim();

  while (i < text.length) {
    if (text[i] === '"' || text[i] === "'") {
      const [token, newIndex] = processQuotedText(text, i + 1, text[i]);
      if (token !== "") {
        result.push(token); // No trim - quoted text is literal
      }
      i = newIndex;
    } else {
      const [token, newIndex, quoteChar] = processUnquotedText(text, i);
      if (token !== "") {
        result.push(token); // No trim - processUnquotedText handles it
      }
      if (token === "" && newIndex === i) {
        i++;
      } else {
        i = newIndex;
      }
    }
  }

  return result;
}
