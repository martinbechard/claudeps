/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/utils/requestCompletion.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import { getHeaders } from "./getHeaders";
import { getOrganizationId } from "./getClaudeIds";
import {
  getCurrentConversationDetails,
  getConversationDetails,
} from "./getConversation";
import { EventStreamParser } from "./EventStreamParser";
import type { CompletionResponse } from "../types";

const API_URL = "https://api.claude.ai/api/organizations";
const STREAMING_API_URL = "https://claude.ai/api/organizations";
const DEFAULT_TIMEZONE = "America/Toronto";

/**
 * Parameters for completion requests
 */
interface CompletionRequestParams {
  prompt: string;
  timezone?: string;
  attachments?: any[];
  files?: any[];
  syncSources?: any[];
  renderingMode?: "messages" | "json";
  stream?: boolean;
  conversationId?: string;
  onProgress?: (chunk: string) => void;
}

/**
 * Makes a non-streaming completion request to Claude's API
 */
async function makeNonStreamingRequest(
  orgId: string,
  endpoint: string,
  requestBody: any
): Promise<CompletionResponse> {
  const response = await fetch(endpoint, {
    method: "POST",
    headers: {
      ...getHeaders(),
      Accept: "application/json",
    },
    credentials: "include",
    body: JSON.stringify(requestBody),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data = await response.json();
  return {
    completion: data.completion,
    stop_reason: data.stop_reason || "", // Convert null to empty string
    model: data.model || "",
    stop: data.stop,
    log_id: data.log_id || "",
    messageLimit: data.messageLimit || {
      type: "none",
      remaining: 0,
    },
  };
}

/**
 * Handles a streaming response with the event stream parser
 */
async function handleStreamingResponse(
  response: Response,
  onProgress?: (chunk: string) => void
): Promise<string> {
  if (!response.body) {
    throw new Error("Response has no body");
  }

  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  const parser = new EventStreamParser();

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      const chunk = decoder.decode(value, { stream: true });
      const message = parser.processChunk(chunk);

      if (onProgress && message) {
        onProgress(message);
      }

      if (parser.isMessageComplete()) {
        break;
      }
    }

    return parser.getMessage();
  } finally {
    reader.releaseLock();
  }
}

/**
 * Makes a completion request to Claude's API
 * @param params Request parameters
 * @returns Promise resolving to completion response
 * @throws Error if the request fails
 */
export async function requestCompletion(
  params: CompletionRequestParams
): Promise<CompletionResponse> {
  try {
    const orgId = getOrganizationId();

    // Get conversation details using appropriate utility function
    const {
      uuid: conversationId,
      current_leaf_message_uuid: parentMessageUuid,
    } = params.conversationId
      ? await getConversationDetails(params.conversationId)
      : await getCurrentConversationDetails();

    const endpoint = `${STREAMING_API_URL}/${orgId}/chat_conversations/${conversationId}/completion`;

    const requestBody = {
      prompt: params.prompt,
      parent_message_uuid: parentMessageUuid,
      timezone: params.timezone || DEFAULT_TIMEZONE,
      attachments: params.attachments || [],
      files: params.files || [],
      sync_sources: params.syncSources || [],
      rendering_mode: params.renderingMode || "messages",
    };

    if (!params.stream) {
      // Non-streaming request
      return await makeNonStreamingRequest(orgId, endpoint, requestBody);
    }

    // Streaming request
    const response = await fetch(endpoint, {
      method: "POST",
      headers: {
        ...getHeaders(),
        Accept: "text/event-stream",
      },
      credentials: "include",
      body: JSON.stringify(requestBody),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    // Handle streaming response with parser
    const fullCompletion = await handleStreamingResponse(
      response,
      params.onProgress
    );

    return {
      completion: fullCompletion,
      stop_reason: "", // Empty string instead of null
      model: "",
      stop: null,
      log_id: "",
      messageLimit: {
        type: "none",
        remaining: 0,
      },
    };
  } catch (error) {
    throw new Error(
      `Completion request failed: ${
        error instanceof Error ? error.message : "Unknown error"
      }`
    );
  }
}
