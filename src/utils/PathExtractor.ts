/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /src/utils/PathExtractor.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Utility functions for extracting file paths from code artifacts
 * Note: Finding needles in comment haystacks since 2024!
 */

/**
 * Extracts the file path from a code artifact's comments
 * Checks both single-line and block comments at the start of the file
 * @param content - The content to analyze
 * @returns The extracted path or undefined if not found
 */
export function extractPathFromComments(content: string): string | undefined {
  // Normalize line endings
  const normalizedContent = content.replace(/\r\n/g, "\n");
  const lines = normalizedContent.split("\n");

  let inBlockComment = false;
  let collectedLines: string[] = [];

  for (let i = 0; i < Math.min(20, lines.length); i++) {
    // Only check first 20 lines
    const line = lines[i].trim();

    // Skip empty lines
    if (!line) continue;

    // Check for start of block comment
    if (line.startsWith("/*")) {
      inBlockComment = true;
      collectedLines.push(line.substring(2).trim());
      continue;
    }

    // Check for end of block comment
    if (inBlockComment && line.includes("*/")) {
      inBlockComment = false;
      collectedLines.push(line.substring(0, line.indexOf("*/")).trim());
      break;
    }

    // Collect block comment lines
    if (inBlockComment) {
      // Remove leading * if present
      const cleanLine = line.startsWith("*") ? line.substring(1).trim() : line;
      collectedLines.push(cleanLine);
      continue;
    }

    // Check for single-line comments
    if (line.startsWith("//")) {
      collectedLines.push(line.substring(2).trim());
      continue;
    }

    // If we hit a non-comment line, stop processing
    if (!inBlockComment) break;
  }

  // Look for path in collected lines
  for (const line of collectedLines) {
    // Check for explicit path declarations
    const pathMatches = [
      /File:\s*([^*\n]+)/i, // File: path
      /Path:\s*([^*\n]+)/i, // Path: path
      /FilePath:\s*([^*\n]+)/i, // FilePath: path
      /@path\s+([^*\n]+)/i, // @path path
      /^[\\/].*\.[\w]+$/, // Absolute path with extension
    ];

    for (const pattern of pathMatches) {
      const match = line.match(pattern);
      if (match) {
        const path = match[1] || match[0];
        return path.trim();
      }
    }
  }

  return undefined;
}

/**
 * Handles special cases where the path might be in a non-standard format
 * Such as in JSON files with _path property
 * @param content - The content to analyze
 * @returns The extracted path or undefined if not found
 */
export function extractPathFromSpecialCases(
  content: string
): string | undefined {
  try {
    // Check if it's a JSON file
    const jsonContent = JSON.parse(content);
    if (jsonContent._path || jsonContent._file) {
      return jsonContent._path || jsonContent._file;
    }
  } catch {
    // Not JSON, continue with normal processing
  }

  return undefined;
}

/**
 * Main function to extract a relative path to one of the main project subdirectories
 * Tries different strategies in order of reliability
 * @param content - The content to analyze
 * @param subdirectories - Optional list of subdirectories to match
 * @returns The extracted path or undefined if not found
 */
export function extractRelPath(
  content: string,
  subdirectories?: string[]
): string | undefined {
  return extractPath(
    content,
    subdirectories || ["src", "doc", "tests", "web", "api", "app"]
  );
}

/**
 * Main function to extract path from content
 * Tries different strategies in order of reliability
 * @param content - The content to analyze
 * @param subdirectories - Optional list of subdirectories to match
 * @returns The extracted path or undefined if not found
 */
export function extractPath(
  content: string,
  subdirectories?: string[]
): string | undefined {
  // First try special cases (like JSON)
  const specialCasePath = extractPathFromSpecialCases(content);
  if (specialCasePath) {
    return filterPathFromSubdirectories(specialCasePath, subdirectories);
  }

  // Then try extracting from comments
  const commentPath = extractPathFromComments(content);
  if (commentPath) {
    return filterPathFromSubdirectories(commentPath, subdirectories);
  }

  return undefined;
}

/**
 * Helper function to filter the path based on the provided subdirectories.
 * Keeps only the path segment from the first match of the subdirectory onwards.
 * @param path - The full path extracted from content
 * @param subdirectories - List of subdirectories to search for in the path
 * @returns The filtered path or the original path if no subdirectory match
 */
export function filterPathFromSubdirectories(
  path: string,
  subdirectories?: string[]
): string {
  if (!subdirectories) return path;

  // Join the subdirectories with | for regex OR, ensuring word boundaries
  const subdirectoryPattern = new RegExp(
    `\\b(${subdirectories.join("|")})\\b`,
    "i"
  );
  const match = path.match(subdirectoryPattern);

  if (match && match.index !== undefined) {
    return path.slice(match.index);
  }

  return path;
}
