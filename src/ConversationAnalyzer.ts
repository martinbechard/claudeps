// Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
// This software is licensed under the MIT License.
// Path: src/ConversationAnalyzer.ts
// This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
// Analyzes conversation data to extract metrics about message lengths and totals
// "I analyze conversations so thoroughly, I can tell you how many characters it takes to say 'hello' in every language!"

export interface Message {
  id: string;
  sender: string;
  content: string;
}

export interface Conversation {
  id: string;
  name: string;
  messages: Message[];
}

export interface MessageStats {
  length: number;
  byteLength: number; // Add byte length
  messageId: string;
}

export interface ConversationMetrics {
  conversationId: string;
  conversationName: string;
  messageLengths: MessageStats[];
  longestMessage: MessageStats;
  totalSize: number;
  conversations: Conversation[]; // Add conversations for message lookup
}

export interface AnalysisResults {
  conversationMetrics: ConversationMetrics[];
  totalSize: number;
}

/**
 * Analyzes conversation data to extract various metrics about message lengths
 */
export class ConversationAnalyzer {
  private conversations: Conversation[];

  /**
   * Creates a new ConversationAnalyzer instance
   * @param data Array of conversations to analyze
   */
  constructor(data: Conversation[]) {
    this.conversations = data;
  }

  /**
   * Analyzes all conversations and returns comprehensive metrics
   * @returns Analysis results including per-conversation metrics and total size
   */
  public analyze(): AnalysisResults {
    const metrics = this.conversations.map((conv) =>
      this.analyzeConversation(conv)
    );
    const totalSize = metrics.reduce((sum, conv) => sum + conv.totalSize, 0);

    return {
      conversationMetrics: metrics,
      totalSize,
    };
  }

  /**
   * Analyzes a single conversation to extract its metrics
   * @param conversation The conversation to analyze
   * @returns Metrics for the specific conversation
   */
  private analyzeConversation(conversation: Conversation): ConversationMetrics {
    const messageLengths = conversation.messages.map((msg) => {
      const content = msg.content;
      // Get byte length using TextEncoder
      const byteLength = new TextEncoder().encode(content).length;
      return {
        length: content.length,
        byteLength,
        messageId: msg.id,
      };
    });

    const longestMessage = messageLengths.reduce(
      (max, current) => (current.byteLength > max.byteLength ? current : max),
      messageLengths[0]
    );

    const totalSize = messageLengths.reduce(
      (sum, msg) => sum + msg.byteLength,
      0
    );

    return {
      conversationId: conversation.id,
      conversationName: conversation.name,
      messageLengths,
      longestMessage,
      totalSize,
      conversations: [conversation], // Add conversation for message lookup
    };
  }

  /**
   * Finds a message by ID across all conversations
   * @param messageId The ID of the message to find
   * @returns The message details with conversation context or null if not found
   */
  public findMessageById(messageId: string): {
    message: Message;
    conversation: {
      id: string;
      name: string;
    };
  } | null {
    for (const conversation of this.conversations) {
      const message = conversation.messages.find((msg) => msg.id === messageId);
      if (message) {
        return {
          message,
          conversation: {
            id: conversation.id,
            name: conversation.name,
          },
        };
      }
    }
    return null;
  }
}
