/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/DownloadTable.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * A reusable component for displaying and managing downloadable documents with path editing
 * Note: Making document management a breeze since 2024!
 */

import type { DocumentInfo, SearchResultInfo } from "../../types";
import { DocumentDownload } from "../../services/DocumentDownload";
import { ConversationPreview } from "./ConversationPreview";
import { ContentPreview } from "./ContentPreview";
import { ConversationRetrieval } from "../../services/ConversationRetrieval";
import { getOrganizationId } from "../../utils/getClaudeIds";
import { ProjectSearchService } from "../../services/ProjectSearchService";
import { SearchResultPreview } from "./SearchResultPreview";
import {
  createButton,
  createButtonContainer,
  createTableCell,
  createCheckboxCell,
  createEmptyState,
  createNameCell,
  createSearchResultCell,
  createDateCell,
} from "./DownloadWidgets";

/**
 * Sort direction for table columns
 */
type SortDirection = "asc" | "desc" | null;

/**
 * Configuration for table columns
 */
type TableConfig = {
  id: string;
  label: string;
  width?: string;
  sortable?: boolean;
};

/**
 * Component for displaying and managing downloadable documents in a table format
 */
export class DownloadTable {
  private items: DocumentInfo[];
  private readonly container: HTMLElement;
  private readonly previewDialog: ConversationPreview;
  private readonly contentPreview: ContentPreview;
  private readonly searchResultPreview: SearchResultPreview;
  private readonly showResults: boolean;
  private readonly showCancelButton: boolean;
  private currentTable: HTMLTableElement | null = null;
  private currentSortColumn: string | null = null;
  private currentSortDirection: SortDirection = null;
  private tbody: HTMLTableSectionElement | null = null;
  private processedRows: Set<string> = new Set();

  constructor(
    container: HTMLElement,
    itemsOrShowResults: DocumentInfo[] | boolean = false,
    showCancelButton: boolean = true
  ) {
    this.container = container;

    // Handle backward compatibility
    if (Array.isArray(itemsOrShowResults)) {
      this.items = itemsOrShowResults;
      this.showResults = false;
    } else {
      this.items = [];
      this.showResults = itemsOrShowResults;
    }

    this.showCancelButton = showCancelButton;
    this.previewDialog = new ConversationPreview();
    this.contentPreview = new ContentPreview();

    // Initialize SearchResultPreview with conversation preview callback
    this.searchResultPreview = new SearchResultPreview(
      async (conversationId, messageId) => {
        try {
          // Hide search result preview before showing conversation
          this.searchResultPreview.hide();

          const orgId = getOrganizationId();
          if (!orgId) {
            throw new Error("Unable to get organization ID");
          }
          const conversation = await ConversationRetrieval.getConversation(
            orgId,
            conversationId,
            true // Force refresh
          );
          this.previewDialog.show(
            conversation.name || "Conversation Preview",
            conversation.chat_messages,
            undefined,
            messageId
          );
        } catch (error) {
          console.error("Failed to load conversation:", error);
          throw error;
        }
      }
    );

    this.initializeTable();

    // If items were provided, add them all at once
    if (Array.isArray(itemsOrShowResults)) {
      this.items.forEach((item, index) => {
        const row = this.createItemRow(item, index);
        this.tbody?.appendChild(row);
      });
    }
  }

  /**
   * Checks if a row has been processed
   */
  public isRowProcessed(conversationId: string): boolean {
    return this.processedRows.has(conversationId);
  }

  /**
   * Initializes the table with just the headers
   */
  private initializeTable(): void {
    this.container.innerHTML = "";

    // Add cancel button before the table if showing results and cancel button is enabled
    if (this.showResults && this.showCancelButton) {
      const cancelButton = createButton(
        "Cancel",
        () => {
          ProjectSearchService.abortSearch();
        },
        { variant: "danger" }
      );
      cancelButton.style.marginBottom = "10px";
      this.container.appendChild(cancelButton);
    }

    const table = this.createTable();
    const headerRow = this.createTableHeader(table);
    table.appendChild(headerRow);
    this.tbody = table.createTBody();
    table.appendChild(this.tbody);
    this.container.appendChild(table);
    this.currentTable = table;
    this.addDownloadButtons();
  }

  /**
   * Adds a new row to the table
   */
  public addRow(item: DocumentInfo): void {
    if (!this.tbody) return;

    this.items.push(item);
    const row = this.createItemRow(item, this.items.length - 1);
    this.tbody.appendChild(row);
  }

  /**
   * Updates a single row's search result cell
   */
  public updateSearchResult(
    conversationId: string,
    searchResult: SearchResultInfo | undefined,
    error?: string,
    select: boolean = false
  ): void {
    if (!this.currentTable) return;

    // Mark row as processed unless it's in "Working..." state
    if (error !== "Working...") {
      this.processedRows.add(conversationId);
    }

    const row = this.currentTable.querySelector(
      `tr[data-conversation-id="${conversationId}"]`
    );
    if (!row) return;

    // Find the search result cell (third cell, index 2)
    const oldCell = row.children[2] as HTMLTableCellElement;
    if (!oldCell) return;

    // Create new cell with error if provided
    const newCell = error
      ? createSearchResultCell(undefined, error, this.searchResultPreview)
      : createSearchResultCell(
          searchResult,
          undefined,
          this.searchResultPreview
        );
    oldCell.replaceWith(newCell);

    // Update the item in our items array
    const itemIndex = this.items.findIndex(
      (item) => item.metadata?.conversationId === conversationId
    );
    if (itemIndex !== -1) {
      this.items[itemIndex] = {
        ...this.items[itemIndex],
        searchResult,
        isSelected: select && !!searchResult,
      };

      // Update checkbox if there's a result
      const checkbox = row.querySelector(
        'input[type="checkbox"]'
      ) as HTMLInputElement;
      if (checkbox) {
        checkbox.checked = select && !!searchResult;
      }
    }
  }

  /**
   * Gets configuration for table headers
   */
  private getTableHeaders(): TableConfig[] {
    const baseHeaders: TableConfig[] = [
      { id: "checkbox", label: "", width: "40px", sortable: false },
      { id: "fileName", label: "Name", width: "25%", sortable: true },
    ];

    if (this.showResults) {
      baseHeaders.push({
        id: "searchResult",
        label: "Results",
        sortable: false,
      });
    }

    baseHeaders.push(
      { id: "created", label: "Created", width: "180px", sortable: true },
      { id: "updated", label: "Updated", width: "180px", sortable: true },
      { id: "filePath", label: "Path", sortable: true }
    );

    return baseHeaders;
  }

  /**
   * Creates a new table element
   */
  private createTable(): HTMLTableElement {
    const table = document.createElement("table");
    table.style.width = "100%";
    table.style.borderCollapse = "collapse";
    table.style.marginTop = "10px";
    return table;
  }

  /**
   * Creates the table header section with sorting
   */
  private createTableHeader(table: HTMLTableElement): HTMLTableSectionElement {
    const header = document.createElement("thead");
    const headerRow = document.createElement("tr");

    this.getTableHeaders().forEach((config) => {
      const th = createTableCell(true);
      if (config.width) {
        th.style.width = config.width;
      }

      if (config.id === "checkbox") {
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.addEventListener("change", (e) =>
          this.handleHeaderCheckbox(e, table)
        );
        th.appendChild(checkbox);
      } else {
        // Create header content container
        const headerContent = document.createElement("div");
        headerContent.style.cssText = `
          display: flex;
          align-items: center;
          gap: 4px;
          ${config.sortable ? "cursor: pointer;" : ""}
          padding: 4px;
          border-radius: 4px;
          transition: background-color 0.2s ease;
        `;

        // Add label
        const label = document.createElement("span");
        label.textContent = config.label;
        headerContent.appendChild(label);

        // Add sort indicator if sortable
        if (config.sortable) {
          const sortIndicator = document.createElement("span");
          sortIndicator.style.cssText = `
            font-size: 0.8em;
            opacity: ${this.currentSortColumn === config.id ? "1" : "0.3"};
            transition: opacity 0.2s ease;
          `;
          sortIndicator.textContent = this.getSortIndicator(config.id);
          headerContent.appendChild(sortIndicator);

          // Add click handler for sorting
          headerContent.addEventListener("click", () =>
            this.handleSort(config.id)
          );

          // Add hover effect
          headerContent.addEventListener("mouseover", () => {
            headerContent.style.backgroundColor = "#f0f0f0";
          });
          headerContent.addEventListener("mouseout", () => {
            headerContent.style.backgroundColor = "transparent";
          });
        }

        th.appendChild(headerContent);
      }

      headerRow.appendChild(th);
    });

    header.appendChild(headerRow);
    return header;
  }

  /**
   * Gets the sort indicator symbol based on current sort state
   */
  private getSortIndicator(columnId: string): string {
    if (this.currentSortColumn !== columnId) return "↕";
    return this.currentSortDirection === "asc" ? "↑" : "↓";
  }

  /**
   * Handles sorting when a header is clicked
   */
  private handleSort(columnId: string): void {
    // If clicking a different column, reset sort direction
    if (this.currentSortColumn !== columnId) {
      this.currentSortDirection = null;
    }

    // Update sort state
    this.currentSortColumn = columnId;
    this.currentSortDirection = this.getNextSortDirection(
      this.currentSortDirection
    );

    // Sort items
    if (this.currentSortDirection) {
      this.items.sort((a, b) => {
        const comparison = this.compareItems(a, b, columnId);
        return this.currentSortDirection === "asc" ? comparison : -comparison;
      });
    }

    // Re-render table
    this.render();
  }

  /**
   * Gets the next sort direction in the cycle
   */
  private getNextSortDirection(current: SortDirection): SortDirection {
    if (current === null) return "asc";
    if (current === "asc") return "desc";
    return null;
  }

  /**
   * Compares two items for sorting
   */
  private compareItems(
    a: DocumentInfo,
    b: DocumentInfo,
    columnId: string
  ): number {
    switch (columnId) {
      case "fileName":
        return a.fileName.localeCompare(b.fileName);
      case "filePath":
        return a.filePath.localeCompare(b.filePath);
      case "created":
        return this.compareDates(
          a.metadata?.created_at,
          b.metadata?.created_at
        );
      case "updated":
        return this.compareDates(
          a.metadata?.updated_at,
          b.metadata?.updated_at
        );
      default:
        return 0;
    }
  }

  /**
   * Compares two date strings
   */
  private compareDates(a: string | undefined, b: string | undefined): number {
    // Handle undefined dates
    if (!a && !b) return 0;
    if (!a) return -1;
    if (!b) return 1;

    // Compare dates
    return new Date(a).getTime() - new Date(b).getTime();
  }

  /**
   * Handles header checkbox changes
   */
  private handleHeaderCheckbox(e: Event, table: HTMLTableElement): void {
    const target = e.target as HTMLInputElement;
    const checkboxes = table.querySelectorAll('tbody input[type="checkbox"]');
    checkboxes.forEach(
      (cb) => ((cb as HTMLInputElement).checked = target.checked)
    );

    // Update item selection state
    this.items.forEach((item) => {
      item.isSelected = target.checked;
    });
  }

  /**
   * Handles preview requests for files and conversations
   */
  private async handlePreview(item: DocumentInfo): Promise<void> {
    // If it's a conversation, use conversation preview
    if (item.metadata?.conversationId) {
      try {
        // Hide search result preview before showing conversation
        this.searchResultPreview.hide();

        const orgId = getOrganizationId();
        const conversation = await ConversationRetrieval.getConversation(
          orgId,
          item.metadata.conversationId
        );
        this.previewDialog.show(
          item.fileName,
          conversation.chat_messages,
          item.metadata.url
        );
      } catch (error) {
        console.error("Failed to load conversation preview:", error);
        alert("Failed to load conversation preview");
      }
      return;
    }

    // Otherwise show content preview
    try {
      const content = item.contentCallback
        ? await item.contentCallback(item)
        : item.content;

      this.contentPreview.show(item.fileName, content, item.fileName);
    } catch (error) {
      console.error("Failed to load content preview:", error);
      alert("Failed to load content preview");
    }
  }

  /**
   * Handles updating a file path
   */
  private handlePathUpdate(index: number, newPath: string): void {
    this.items[index] = {
      ...this.items[index],
      filePath: newPath,
    };

    // Re-render table
    this.render();
  }

  /**
   * Creates a table row for an item
   */
  private createItemRow(
    item: DocumentInfo,
    index: number
  ): HTMLTableRowElement {
    const row = document.createElement("tr");
    row.style.borderBottom = "1px solid #ccc";
    row.dataset.conversationId = item.metadata?.conversationId;

    // Checkbox cell
    const checkboxCell = createCheckboxCell(item.isSelected);
    checkboxCell.querySelector("input")?.addEventListener("change", (e) => {
      const checkbox = e.target as HTMLInputElement;
      this.items[index].isSelected = checkbox.checked;
    });
    row.appendChild(checkboxCell);

    // Name cell with preview for both conversations and content
    const onPreview = () => this.handlePreview(item);
    row.appendChild(
      createNameCell(item.fileName, item.metadata?.url, onPreview)
    );

    // Results cell (if enabled)
    if (this.showResults) {
      row.appendChild(
        createSearchResultCell(
          item.searchResult,
          undefined,
          this.searchResultPreview
        )
      );
    }

    // Created date cell
    row.appendChild(createDateCell(item.metadata?.created_at));

    // Updated date cell
    row.appendChild(createDateCell(item.metadata?.updated_at));

    // Path cell with edit functionality
    const onPathUpdate = (newPath: string) =>
      this.handlePathUpdate(index, newPath);
    row.appendChild(
      createNameCell(item.filePath, undefined, undefined, onPathUpdate)
    );

    return row;
  }

  /**
   * Creates and adds download buttons
   */
  private addDownloadButtons(): void {
    // Remove any existing button container
    const existingContainer = this.container.querySelector(".download-buttons");
    if (existingContainer) {
      existingContainer.remove();
    }

    const buttonContainer = createButtonContainer();
    buttonContainer.classList.add("download-buttons");

    const downloadSelectedButton = createButton("Download Selected", () =>
      this.handleDownload(false)
    );

    const downloadBundleButton = createButton("Download as Bundle", () =>
      this.handleDownload(true)
    );

    buttonContainer.appendChild(downloadSelectedButton);
    buttonContainer.appendChild(downloadBundleButton);
    this.container.appendChild(buttonContainer);
  }

  /**
   * Handles download requests
   */
  private async handleDownload(asBundle: boolean): Promise<void> {
    const selectedItems = this.items.filter((item) => item.isSelected);

    if (selectedItems.length === 0) {
      alert("Please select items to download");
      return;
    }

    try {
      if (asBundle) {
        await DocumentDownload.handleSingleDownload(selectedItems);
      } else {
        await DocumentDownload.handleMultipleDownload(selectedItems);
      }
    } catch (error) {
      console.error("Download failed:", error);
      alert(
        "Download failed: " +
          (error instanceof Error ? error.message : "Unknown error")
      );
    }
  }

  /**
   * Updates the table with new items while preserving selection state
   */
  public updateItems(newItems: DocumentInfo[]): void {
    // Store current selection state
    const selectionMap = new Map<string, boolean>();
    this.items.forEach((item) => {
      if (item.metadata?.conversationId) {
        selectionMap.set(
          item.metadata.conversationId,
          item.isSelected || false
        );
      }
    });

    // Update items while preserving selection
    this.items = newItems.map((item) => {
      if (item.metadata?.conversationId) {
        const wasSelected = selectionMap.get(item.metadata.conversationId);
        if (wasSelected !== undefined) {
          return { ...item, isSelected: wasSelected };
        }
      }
      return item;
    });

    // Re-render table
    this.render();
  }

  /**
   * Renders the table with current items
   */
  public render(): void {
    this.container.innerHTML = "";

    if (this.items.length === 0) {
      this.container.appendChild(createEmptyState("No documents found"));
      return;
    }

    // Add cancel button before the table if showing results and cancel button is enabled
    if (this.showResults && this.showCancelButton) {
      const cancelButton = createButton(
        "Cancel",
        () => {
          ProjectSearchService.abortSearch();
        },
        { variant: "danger" }
      );
      cancelButton.style.marginBottom = "10px";
      this.container.appendChild(cancelButton);
    }

    const table = this.createTable();
    const headerRow = this.createTableHeader(table);
    table.appendChild(headerRow);

    const tbody = table.createTBody();
    this.items.forEach((item, index) => {
      const row = this.createItemRow(item, index);
      tbody.appendChild(row);
    });

    this.container.appendChild(table);
    this.currentTable = table;
    this.addDownloadButtons();
  }

  /**
   * Cleans up the component
   */
  public destroy(): void {
    this.container.innerHTML = "";
    this.previewDialog.destroy();
    this.contentPreview.destroy();
    this.searchResultPreview.destroy();
    this.currentTable = null;
  }
}
