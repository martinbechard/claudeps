/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/ui/components/UIStateManager.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Manages UI state and logging for the Claude extension
 * Note: Making your UI state as predictable as a well-written script!
 */

import type { StatusManager } from "./StatusManager";
import type { FloatingWindowElements } from "../../types";
import { WindowStateService } from "../../services/WindowStateService";

export class UIStateManager {
  private readonly elements: FloatingWindowElements;
  private readonly statusManager: StatusManager;
  private isMinimized: boolean = false;
  private isCollapsed: boolean = false;
  private resizeObserver: ResizeObserver | null = null;

  constructor(elements: FloatingWindowElements, statusManager: StatusManager) {
    this.elements = elements;
    this.statusManager = statusManager;
    this.bindKeyboardEvents();
    this.setupResizeObserver();
  }

  /**
   * Sets up observer for window size changes
   */
  private setupResizeObserver(): void {
    if (typeof ResizeObserver === "undefined") {
      console.warn("ResizeObserver not supported in this browser");
      return;
    }

    this.resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        const element = entry.target as HTMLElement;
        if (!this.isMinimized) {
          WindowStateService.saveGeometry(
            element.style.width,
            element.style.height
          );
        }
      }
    });

    this.resizeObserver.observe(this.elements.window);

    // Also observe script textarea height
    const scriptContainer = this.elements.scriptText.parentElement;
    if (scriptContainer) {
      const scriptObserver = new ResizeObserver((entries) => {
        for (const entry of entries) {
          const element = entry.target as HTMLElement;
          WindowStateService.saveScriptHeight(element.style.height);
        }
      });
      scriptObserver.observe(scriptContainer);
    }
  }

  /**
   * Binds keyboard events for the script input
   */
  private bindKeyboardEvents(): void {
    this.elements.scriptText.addEventListener("keydown", (e: KeyboardEvent) => {
      // Run script on Enter without shift
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.elements.runButton.click();
      }

      // Allow new line on Shift+Enter
      else if (e.key === "Enter" && e.shiftKey) {
        // Default behavior will add new line
        return;
      }

      // Cancel on Escape when script is running
      else if (
        e.key === "Escape" &&
        this.statusManager.getCurrentState() === "working"
      ) {
        e.preventDefault();
        this.elements.runButton.click(); // Will trigger cancel in working state
      }
    });
  }

  /**
   * Toggles the minimize state of the window
   */
  public toggleMinimize(): void {
    this.isMinimized = !this.isMinimized;

    // Save current dimensions before toggling
    const currentWidth = this.elements.window.style.width;
    const currentHeight = this.elements.window.style.height;

    if (this.isMinimized) {
      // Store dimensions for restoration
      if (currentWidth && currentHeight) {
        this.elements.window.dataset.prevWidth = currentWidth;
        this.elements.window.dataset.prevHeight = currentHeight;
      }
      // Clear dimensions to allow shrinking
      this.elements.window.style.width = "";
      this.elements.window.style.height = "";
    } else {
      // Restore previous dimensions if they exist
      const prevWidth = this.elements.window.dataset.prevWidth;
      const prevHeight = this.elements.window.dataset.prevHeight;
      if (prevWidth && prevHeight) {
        this.elements.window.style.width = prevWidth;
        this.elements.window.style.height = prevHeight;

        // Save restored dimensions
        WindowStateService.saveGeometry(prevWidth, prevHeight);
      }
    }

    // Toggle minimized class for CSS styling
    this.elements.window.classList.toggle("minimized", this.isMinimized);
    this.elements.minimizeButton.textContent = this.isMinimized ? "□" : "_";
    this.elements.minimizeButton.title = this.isMinimized
      ? "Restore"
      : "Minimize";

    // Save window state
    WindowStateService.saveWindowState(this.isMinimized, this.isCollapsed);
  }

  /**
   * Toggles the collapse state of the output panel
   */
  public toggleCollapse(): void {
    this.isCollapsed = !this.isCollapsed;

    if (this.isCollapsed) {
      // Store current window height for restoration
      const currentWindowHeight = this.elements.window.style.height;
      if (currentWindowHeight) {
        this.elements.window.dataset.prevHeight = currentWindowHeight;
      }

      // Store output height for restoration
      const currentOutputHeight = this.elements.output.style.height;
      if (currentOutputHeight) {
        this.elements.output.dataset.prevHeight = currentOutputHeight;
      }

      // Collapse output area
      this.elements.output.style.maxHeight = "3em";
      this.elements.output.style.overflowY = "hidden";

      // Shrink window to fit collapsed content
      this.elements.window.style.height = "auto";
      this.elements.window.style.minHeight = "auto";
    } else {
      // Restore window height
      const prevWindowHeight = this.elements.window.dataset.prevHeight;
      if (prevWindowHeight) {
        this.elements.window.style.height = prevWindowHeight;
        this.elements.window.style.minHeight = "200px"; // Restore default min-height
      }

      // Restore output height
      const prevOutputHeight = this.elements.output.dataset.prevHeight;
      if (prevOutputHeight) {
        this.elements.output.style.height = prevOutputHeight;
      }
      this.elements.output.style.maxHeight = "";
      this.elements.output.style.overflowY = "auto";
    }

    this.elements.collapseButton.textContent = this.isCollapsed ? "▶" : "▼";
    this.elements.collapseButton.title = this.isCollapsed
      ? "Expand"
      : "Collapse";

    // Save window state
    WindowStateService.saveWindowState(this.isMinimized, this.isCollapsed);
    const windowHeight = this.elements.window.style.height;
    if (windowHeight) {
      WindowStateService.saveGeometry(
        this.elements.window.style.width,
        windowHeight
      );
    }
  }

  /**
   * Updates button states based on execution state
   * @param isExecuting - Whether a script is currently executing
   */
  public updateButtonStates(isExecuting: boolean): void {
    this.elements.runButton.textContent = isExecuting ? "Cancel" : "Run Script";
    this.elements.runButton.disabled = false;
    this.elements.scriptText.disabled = isExecuting;
  }

  public setMode(scriptMode: boolean): void {
    WindowStateService.saveMode(scriptMode);
    // Update UI elements visibility
    if (
      this.elements.scriptModeContainer &&
      this.elements.simpleModeContainer
    ) {
      this.elements.scriptModeContainer.style.display = scriptMode
        ? "block"
        : "none";
      this.elements.simpleModeContainer.style.display = scriptMode
        ? "none"
        : "block";
    }
  }

  /**
   * Logs a message to the output area
   * @param message - Message to log
   * @param type - Type of message for styling
   */
  public log(
    message: string,
    type: "info" | "error" | "success" = "info"
  ): void {
    const log = document.createElement("div");
    log.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
    log.style.color =
      type === "error" ? "red" : type === "success" ? "green" : "black";
    this.elements.output.appendChild(log);
    this.elements.output.scrollTop = this.elements.output.scrollHeight;
  }

  /**
   * Cleans up resources
   */
  public destroy(): void {
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
  }

  /**
   * Clears the output area
   */
  public clearOutput(): void {
    this.elements.output.innerHTML = "";
  }
}
