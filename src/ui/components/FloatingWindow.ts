/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/FloatingWindow.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import type { FloatingWindowElements } from "../../types";
import { WindowStateService } from "../../services/WindowStateService";
import { SettingsService } from "../../services/SettingsService";
import { HelpManager } from "./HelpManager";
import { UIStateManager } from "./UIStateManager";

/**
 * Manages the floating window interface for the extension.
 */
export class FloatingWindow {
  private element: HTMLElement | null = null;
  private outputDiv: HTMLElement | null = null;
  private uiStateManager: UIStateManager | null = null;
  private helpManager: HelpManager | null = null;

  private readonly template = `
    <div class="floating-window">
      <div class="status ready" style="display: flex; justify-content: space-between; align-items: center;">
        <div style="display: flex; align-items: center; gap: 5px;">
          <span class="status-label">ClaudePS - </span>
          <span class="status-text">READY</span>
          <span class="status-details"></span>
        </div>
        <div style="display: flex; gap: 5px;">
          <button id="minimizeButton" style="font-size: 12px; padding: 2px 8px;">_</button>
          <button id="modeToggleButton" title="Switch to Script Mode" style="font-size: 12px; padding: 2px 8px;">üìù</button>
          <button id="starredButton" title="View Starred Messages" style="font-size: 12px; padding: 2px 8px;">‚òÖ</button>
          <button id="helpButton" style="font-size: 12px; padding: 2px 8px;">?</button>
        </div>
      </div>
      <div class="input-container">
        <div class="script-mode" style="display: none;">
          <div class="script-container">
            <textarea id="scriptText" placeholder="Simple prompt:
Type your prompt here

-- or --

/repeat MAX 3 /stop_if success
Your prompt here

-- or -- 

/repeat MAX 3 /stop_if_not failure
Your prompt here"></textarea>
            <div class="resize-handle"></div>
          </div>
          <button id="runScript">Run Script</button>
        </div>
        <div class="simple-mode">
          <div class="simple-buttons" style="display: flex; gap: 8px; margin-bottom: 10px;">
            <button class="command-button search-button" data-command="/search_project " data-no-auto-run="true">Search</button>
            <button class="command-button project-button" data-command="/project">Project</button>
            <button class="command-button" data-command="/conversation">Conversation</button>
            <button class="command-button" data-command="/artifacts">Artifacts</button>
            <button class="command-button" data-command="/knowledge">Knowledge</button>
          </div>
          <div class="project-search-container">
            <input type="text" class="project-search-input" placeholder="Enter search criteria..." />
            <button class="project-search-glyph">üîç</button>
            <button class="project-search-cancel">Cancel</button>
          </div>
        </div>
        <div class="output-container">
          <div id="scriptOutput"></div>
          <div id="collapseButton" style="cursor: pointer; user-select: none; padding: 5px;">‚ñº</div>
        </div>
      </div>
    </div>
  `;

  /**
   * Creates and injects the floating window into the DOM.
   * @returns The floating window element
   * @throws Error if window creation fails
   */
  public async create(): Promise<HTMLElement> {
    const container = document.createElement("div");
    container.innerHTML = this.template.trim();

    const window = container.querySelector(".floating-window");
    if (!window) {
      throw new Error("Failed to create floating window");
    }

    document.body.appendChild(container);
    this.element = window as HTMLElement;
    this.outputDiv = this.element.querySelector("#scriptOutput") as HTMLElement;

    // Get elements and bind event listeners
    const elements = this.getElements();
    this.bindEventListeners(elements);

    // Initialize help manager
    this.helpManager = new HelpManager(this.outputDiv);

    // Restore saved window state
    WindowStateService.applyState(this.element);

    // Set up resize functionality
    this.setupResizeHandles();

    // Apply theme
    await this.applyTheme();

    // Listen for theme changes from options page
    chrome.runtime.onMessage.addListener((message) => {
      if (message.type === "theme_changed") {
        this.applyThemeClass(message.theme);
      }
    });

    return this.element;
  }

  /**
   * Applies the saved theme or default theme
   */
  private async applyTheme(): Promise<void> {
    if (!this.element) return;
    const theme = (await SettingsService.getSetting("theme")) as
      | "light"
      | "dark";
    this.applyThemeClass(theme);
  }

  /**
   * Applies the theme class to the window
   */
  private applyThemeClass(theme: "light" | "dark"): void {
    if (!this.element) return;
    this.element.classList.remove("light-theme", "dark-theme");
    this.element.classList.add(`${theme}-theme`);
  }

  /**
   * Sets up the resize handle functionality
   */
  private setupResizeHandles(): void {
    if (!this.element) return;

    const scriptContainer = this.element.querySelector(
      ".script-container"
    ) as HTMLElement;
    const scriptText = this.element.querySelector(
      "#scriptText"
    ) as HTMLTextAreaElement;
    const resizeHandle = this.element.querySelector(
      ".resize-handle"
    ) as HTMLElement;

    if (!scriptContainer || !scriptText || !resizeHandle) return;

    let startY = 0;
    let startHeight = 0;
    let isDragging = false;

    resizeHandle.addEventListener("mousedown", (e) => {
      isDragging = true;
      startY = e.clientY;
      startHeight = scriptText.offsetHeight;

      document.body.style.cursor = "row-resize";
      document.body.style.userSelect = "none";
    });

    document.addEventListener("mousemove", (e) => {
      if (!isDragging) return;

      const deltaY = e.clientY - startY;
      const newHeight = Math.max(100, startHeight + deltaY);

      scriptText.style.height = `${newHeight}px`;
      WindowStateService.saveScriptHeight(`${newHeight}px`);
    });

    document.addEventListener("mouseup", () => {
      if (!isDragging) return;
      isDragging = false;
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    });
  }

  /**
   * Binds event listeners to UI elements
   */
  private bindEventListeners(elements: FloatingWindowElements): void {
    // Command button handlers
    elements.window.querySelectorAll(".command-button").forEach((button) => {
      button.addEventListener("click", () => {
        const command = button.getAttribute("data-command");
        if (command) {
          if (button.classList.contains("search-button")) {
            // Show search UI for search button
            const searchContainer = elements.window.querySelector(
              ".project-search-container"
            ) as HTMLElement;
            if (searchContainer) {
              searchContainer.style.display = "block";
              const searchInput = searchContainer.querySelector(
                ".project-search-input"
              ) as HTMLInputElement;
              if (searchInput) {
                searchInput.focus();
              }
            }
          } else {
            // For other buttons, just execute the command
            elements.scriptText.value = command;
            elements.runButton.click();
          }
        }
      });
    });

    // Project search handlers
    const searchContainer = elements.window.querySelector(
      ".project-search-container"
    ) as HTMLElement;
    const searchInput = searchContainer?.querySelector(
      ".project-search-input"
    ) as HTMLInputElement;
    const searchGlyph = searchContainer?.querySelector(
      ".project-search-glyph"
    ) as HTMLButtonElement;
    const searchCancel = searchContainer?.querySelector(
      ".project-search-cancel"
    ) as HTMLButtonElement;

    const executeProjectSearch = () => {
      if (searchInput && searchInput.value.trim()) {
        // Execute search in simple mode
        elements.scriptText.value = `/search_project ${searchInput.value.trim()}`;
        elements.runButton.click();

        // Show cancel button
        if (searchCancel) {
          searchCancel.style.display = "block";
          searchCancel.textContent = "Cancel";
        }
      }
    };

    const cancelSearch = () => {
      // Hide search UI and cancel button
      if (searchContainer) {
        searchContainer.style.display = "none";
      }
      if (searchInput) {
        searchInput.value = "";
      }
      if (searchCancel) {
        searchCancel.style.display = "none";
      }

      // Click the run button to trigger cancel in working state
      elements.runButton.click();
    };

    if (searchInput) {
      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          executeProjectSearch();
        } else if (e.key === "Escape") {
          cancelSearch();
        }
      });
    }

    if (searchGlyph) {
      searchGlyph.addEventListener("click", executeProjectSearch);
    }

    if (searchCancel) {
      searchCancel.addEventListener("click", cancelSearch);
    }

    // Mode toggle handler
    elements.modeToggleButton.addEventListener("click", () => {
      const isScriptMode =
        elements.scriptModeContainer.style.display !== "none";
      elements.scriptModeContainer.style.display = isScriptMode
        ? "none"
        : "block";
      elements.simpleModeContainer.style.display = isScriptMode
        ? "block"
        : "none";
      elements.modeToggleButton.title = isScriptMode
        ? "Switch to Script Mode"
        : "Switch to Command Mode";
      elements.modeToggleButton.textContent = isScriptMode ? "üìù" : "üîò";
    });

    elements.runButton.addEventListener("click", () =>
      this.uiStateManager?.updateButtonStates(true)
    );
    elements.helpButton.addEventListener("click", () =>
      this.helpManager?.show()
    );

    elements.minimizeButton.addEventListener("click", () =>
      this.uiStateManager?.toggleMinimize()
    );

    elements.collapseButton.addEventListener("click", () =>
      this.uiStateManager?.toggleCollapse()
    );
  }

  /**
   * Retrieves all UI elements managed by the floating window.
   * @returns Object containing all UI elements
   * @throws Error if any element is not found
   */
  public getElements(): FloatingWindowElements {
    if (!this.element) {
      throw new Error("Floating window not initialized");
    }

    const elements = {
      window: this.element,
      status: this.element.querySelector(".status"),
      statusText: this.element.querySelector(".status-text"),
      statusDetails: this.element.querySelector(".status-details"),
      scriptText: this.element.querySelector("#scriptText"),
      runButton: this.element.querySelector("#runScript"),
      output: this.element.querySelector("#scriptOutput"),
      helpButton: this.element.querySelector("#helpButton"),
      starredButton: this.element.querySelector("#starredButton"),
      collapseButton: this.element.querySelector("#collapseButton"),
      minimizeButton: this.element.querySelector("#minimizeButton"),
      modeToggleButton: this.element.querySelector("#modeToggleButton"),
      scriptModeContainer: this.element.querySelector(".script-mode"),
      simpleModeContainer: this.element.querySelector(".simple-mode"),
    };

    // Validate all elements exist
    for (const [key, value] of Object.entries(elements)) {
      if (!value) {
        throw new Error(`Failed to find element: ${key}`);
      }
    }

    // Type assertion is safe here because we validated all elements exist
    return elements as FloatingWindowElements;
  }

  /**
   * Sets the UI state manager - critical for window state management
   */
  public setUIStateManager(manager: UIStateManager): void {
    this.uiStateManager = manager;
  }

  /**
   * Removes the floating window from the DOM.
   */
  public destroy(): void {
    // Save window state before removal
    if (this.element) {
      WindowStateService.saveGeometry(
        this.element.style.width,
        this.element.style.height
      );
    }
    this.element?.parentElement?.remove();
    this.element = null;
    this.outputDiv = null;
  }
}
