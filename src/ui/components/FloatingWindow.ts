/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/FloatingWindow.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import type { FloatingWindowElements } from "../../types";
import { WindowStateService } from "../../services/WindowStateService";
import { SettingsService } from "../../services/SettingsService";
import { HelpManager } from "./HelpManager";
import { UIStateManager } from "./UIStateManager";
import { simpleCommands } from "../../utils/commands/simpleCommands";
import { CommandHistoryService } from "../../services/CommandHistoryService";
import { DraggableManager } from "./DraggableManager";

/**
 * Manages the floating window interface for the extension.
 */
export class FloatingWindow {
  private element: HTMLElement | null = null;
  private outputDiv: HTMLElement | null = null;
  private uiStateManager: UIStateManager | null = null;
  private helpManager: HelpManager | null = null;
  private domObserver: MutationObserver | null = null;
  private lastPathname: string = window.location.pathname;
  private historyService: CommandHistoryService | null = null;
  private draggableManager: DraggableManager | null = null;

  private isOnClaudeSite(): boolean {
    return window.location.hostname.includes("claude.ai");
  }

  /**
   * Sets the command history service
   */
  public setHistoryService(service: CommandHistoryService): void {
    this.historyService = service;
  }

  private async generateSimpleButtons(): Promise<string> {
    const visibleCommands = await Promise.all(
      simpleCommands.map(async (cmd) => {
        if (cmd.isVisible) {
          const isVisible = await cmd.isVisible();
          if (!isVisible) return "";
        }
        return `
          <button 
            class="command-button ${cmd.className || ""}" 
            data-command="${cmd.command}"
            ${cmd.noAutoRun ? 'data-no-auto-run="true"' : ""}
          >${cmd.label}</button>
        `;
      })
    );

    const filteredCommands = visibleCommands.filter((cmd) => cmd !== "");

    if (filteredCommands.length === 0) {
      return `
        <div class="simple-buttons" style="display: flex; gap: 8px; margin-bottom: 10px;">
          <div style="color: #666; font-style: italic;">Please select a Project or a Chat</div>
        </div>
      `;
    }

    return `
      <div class="simple-buttons" style="display: flex; gap: 8px; margin-bottom: 10px;">
        ${filteredCommands.join("")}
      </div>
    `;
  }

  private async generateTemplate(): Promise<string> {
    const simpleButtonsHtml = await this.generateSimpleButtons();
    return `
    <div class="floating-window">
      <div class="status ready" style="display: flex; justify-content: space-between; align-items: center;">
        <div style="display: flex; align-items: center; gap: 5px;">
          <span class="status-label">ClaudePS - </span>
          <span class="status-text">READY</span>
          <span class="status-details"></span>
        </div>
        <div style="display: flex; gap: 5px;">
          <button id="minimizeButton" style="font-size: 12px; padding: 2px 8px;">_</button>
          <button id="modeToggleButton" title="Switch to Script Mode" style="font-size: 12px; padding: 2px 8px;">üìù</button>
          <button id="starredButton" title="View Starred Messages" style="font-size: 12px; padding: 2px 8px;">‚òÖ</button>
          <button id="helpButton" style="font-size: 12px; padding: 2px 8px;">?</button>
        </div>
      </div>
      <div class="input-container">
        <div class="script-mode" style="display: none;">
          <div class="script-container">
            <div style="position: relative;">
              <div style="position: absolute; right: 35px; top: 5px; display: flex; gap: 5px; z-index: 100;">
                <button id="prevCommand" class="btn btn-neutral btn-sm" title="Previous command">‚Üë</button>
                <button id="nextCommand" class="btn btn-neutral btn-sm" title="Next command">‚Üì</button>
                <button id="clearScript" class="btn btn-neutral btn-sm" title="Clear script">‚úï</button>
              </div>
            <textarea id="scriptText" placeholder="Simple prompt:
Type your prompt here

-- or --

/repeat MAX 3 /stop_if success
Your prompt here

-- or -- 

/repeat MAX 3 /stop_if_not failure
Your prompt here"></textarea>
            </div>
            <div class="resize-handle"></div>
          </div>
          <button id="runScript">Run Script</button>
        </div>
        <div class="simple-mode">
          ${simpleButtonsHtml}
          <div class="project-search-container">
            <input type="text" class="project-search-input" placeholder="Enter search criteria..." />
            <button class="project-search-glyph">üîç</button>
            <button class="project-search-cancel">Cancel</button>
          </div>
        </div>
        <div class="output-container">
          <div id="scriptOutput"></div>
          <div id="collapseButton" style="cursor: pointer; user-select: none; padding: 5px;">‚ñº</div>
        </div>
      </div>
    </div>
  `;
  }

  /**
   * Creates and injects the floating window into the DOM.
   * @returns The floating window element
   * @throws Error if window creation fails
   */
  public async create(): Promise<HTMLElement> {
    // Check if we're on claude.ai before creating the window
    if (!this.isOnClaudeSite()) {
      throw new Error("Not on claude.ai");
    }

    const container = document.createElement("div");
    container.innerHTML = (await this.generateTemplate()).trim();

    const window = container.querySelector(".floating-window");
    if (!window) {
      throw new Error("Failed to create floating window");
    }

    document.body.appendChild(container);
    this.element = window as HTMLElement;
    this.outputDiv = this.element.querySelector("#scriptOutput") as HTMLElement;

    // Get elements and bind event listeners
    const elements = this.getElements();
    this.bindEventListeners(elements);

    // Initialize help manager
    this.helpManager = new HelpManager(this.outputDiv);

    // Set up draggable behavior
    const statusBar = this.element.querySelector(".status") as HTMLElement;
    if (statusBar) {
      this.draggableManager = new DraggableManager(this.element, statusBar);
    }

    // Set up resize functionality
    this.setupResizeHandles();

    // Apply theme
    await this.applyTheme();

    // Listen for theme changes from options page
    chrome.runtime.onMessage.addListener((message) => {
      if (message.type === "theme_changed") {
        this.applyThemeClass(message.theme);
      }
    });

    // Set up URL and DOM change detection
    this.setupChangeDetection();

    return this.element;
  }

  /**
   * Sets up URL and DOM change detection
   */
  private setupChangeDetection(): void {
    // Listen for popstate events (browser back/forward)
    window.addEventListener("popstate", this.handleLocationChange.bind(this));

    // Listen for pushState/replaceState
    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;

    history.pushState = function (...args) {
      originalPushState.apply(this, args);
      window.dispatchEvent(new Event("locationchange"));
    };

    history.replaceState = function (...args) {
      originalReplaceState.apply(this, args);
      window.dispatchEvent(new Event("locationchange"));
    };

    window.addEventListener(
      "locationchange",
      this.handleLocationChange.bind(this)
    );

    // Set up DOM observer for button visibility updates when on claude.ai
    if (this.isOnClaudeSite()) {
      this.setupDomObserver();
    }
  }

  /**
   * Handles URL changes
   */
  private handleLocationChange(): void {
    if (this.element) {
      if (this.isOnClaudeSite()) {
        this.element.style.display = "";
        // Check if path changed
        if (window.location.pathname !== this.lastPathname) {
          this.lastPathname = window.location.pathname;
          this.updateButtonVisibility();
        }
        // Set up DOM observer if we're back on claude.ai
        this.setupDomObserver();
      } else {
        this.element.style.display = "none";
        // Remove DOM observer when not on claude.ai
        if (this.domObserver) {
          this.domObserver.disconnect();
          this.domObserver = null;
        }
      }
    }
  }

  /**
   * Sets up DOM observer for button visibility updates
   */
  private setupDomObserver(): void {
    if (this.domObserver) {
      this.domObserver.disconnect();
    }

    this.domObserver = new MutationObserver((mutations) => {
      // Skip if mutation is in our own UI
      const relevantChange = mutations.some((mutation) => {
        const target = mutation.target as Element;
        return !this.element?.contains(target);
      });

      if (relevantChange) {
        this.updateButtonVisibility();
      }
    });

    // Watch document.body like content.ts does
    this.domObserver.observe(document.body, {
      childList: true,
      subtree: true,
    });
  }

  /**
   * Updates button visibility based on current URL context
   */
  private async updateButtonVisibility(): Promise<void> {
    if (!this.element || !this.isOnClaudeSite()) return;

    const simpleModeContainer = this.element.querySelector(".simple-mode");
    if (!simpleModeContainer) return;

    const simpleButtonsHtml = await this.generateSimpleButtons();
    const simpleButtonsContainer =
      simpleModeContainer.querySelector(".simple-buttons");
    if (simpleButtonsContainer) {
      simpleButtonsContainer.innerHTML = simpleButtonsHtml;
      this.bindCommandButtonListeners();
    }
  }

  /**
   * Binds event listeners to UI elements
   */
  private bindEventListeners(elements: FloatingWindowElements): void {
    this.bindCommandButtonListeners();

    // Add Enter key handler for script text area
    elements.scriptText.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        elements.runButton.click();
      }
    });

    // Add history navigation handlers
    const prevCommand = this.element?.querySelector(
      "#prevCommand"
    ) as HTMLButtonElement;
    const nextCommand = this.element?.querySelector(
      "#nextCommand"
    ) as HTMLButtonElement;
    const clearScript = this.element?.querySelector(
      "#clearScript"
    ) as HTMLButtonElement;
    const scriptText = elements.scriptText as HTMLTextAreaElement;

    if (
      prevCommand &&
      nextCommand &&
      clearScript &&
      scriptText &&
      this.historyService
    ) {
      prevCommand.addEventListener("click", () => {
        const prevCmd = this.historyService?.getPreviousCommand();
        if (prevCmd) {
          scriptText.value = prevCmd;
          scriptText.focus();
        }
      });

      nextCommand.addEventListener("click", () => {
        const nextCmd = this.historyService?.getNextCommand();
        if (nextCmd) {
          scriptText.value = nextCmd;
          scriptText.focus();
        }
      });

      clearScript.addEventListener("click", () => {
        scriptText.value = "";
        scriptText.focus();
      });

      // Add keyboard shortcuts
      scriptText.addEventListener("keydown", (e) => {
        if (e.key === "ArrowUp" && e.ctrlKey) {
          e.preventDefault();
          const prevCmd = this.historyService?.getPreviousCommand();
          if (prevCmd) {
            scriptText.value = prevCmd;
          }
        } else if (e.key === "ArrowDown" && e.ctrlKey) {
          e.preventDefault();
          const nextCmd = this.historyService?.getNextCommand();
          if (nextCmd) {
            scriptText.value = nextCmd;
          }
        }
      });
    }

    // Project search handlers
    const searchContainer = elements.window.querySelector(
      ".project-search-container"
    ) as HTMLElement;
    const searchInput = searchContainer?.querySelector(
      ".project-search-input"
    ) as HTMLInputElement;
    const searchGlyph = searchContainer?.querySelector(
      ".project-search-glyph"
    ) as HTMLButtonElement;
    const searchCancel = searchContainer?.querySelector(
      ".project-search-cancel"
    ) as HTMLButtonElement;

    const executeProjectSearch = () => {
      if (searchInput && searchInput.value.trim()) {
        // Execute search in simple mode
        elements.scriptText.value = `/search_project ${searchInput.value.trim()}`;
        elements.runButton.click();

        // Show cancel button
        if (searchCancel) {
          searchCancel.style.display = "block";
          searchCancel.textContent = "Cancel";
        }
      }
    };

    const cancelSearch = () => {
      // Hide search UI and cancel button
      if (searchContainer) {
        searchContainer.style.display = "none";
      }
      if (searchInput) {
        searchInput.value = "";
      }
      if (searchCancel) {
        searchCancel.style.display = "none";
      }

      // Click the run button to trigger cancel in working state
      elements.runButton.click();
    };

    if (searchInput) {
      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          executeProjectSearch();
        } else if (e.key === "Escape") {
          cancelSearch();
        }
      });
    }

    if (searchGlyph) {
      searchGlyph.addEventListener("click", executeProjectSearch);
    }

    if (searchCancel) {
      searchCancel.addEventListener("click", cancelSearch);
    }

    // Mode toggle handler
    elements.modeToggleButton.addEventListener("click", () => {
      const isScriptMode =
        elements.scriptModeContainer.style.display !== "none";
      elements.scriptModeContainer.style.display = isScriptMode
        ? "none"
        : "block";
      elements.simpleModeContainer.style.display = isScriptMode
        ? "block"
        : "none";
      elements.modeToggleButton.title = isScriptMode
        ? "Switch to Script Mode"
        : "Switch to Command Mode";
      elements.modeToggleButton.textContent = isScriptMode ? "üìù" : "üîò";
    });

    elements.runButton.addEventListener("click", () =>
      this.uiStateManager?.updateButtonStates(true)
    );
    elements.helpButton.addEventListener("click", () =>
      this.helpManager?.show()
    );

    elements.minimizeButton.addEventListener("click", () =>
      this.uiStateManager?.handleMinimizeClick()
    );

    elements.collapseButton.addEventListener("click", () =>
      this.uiStateManager?.toggleCollapse()
    );
  }

  /**
   * Binds event listeners to command buttons
   */
  private bindCommandButtonListeners(): void {
    if (!this.element) return;

    const elements = this.getElements();
    this.element.querySelectorAll(".command-button").forEach((button) => {
      button.addEventListener("click", () => {
        const command = button.getAttribute("data-command");
        if (command) {
          if (button.classList.contains("search-button")) {
            // Show search UI for search button
            const searchContainer = this.element?.querySelector(
              ".project-search-container"
            ) as HTMLElement;
            if (searchContainer) {
              searchContainer.style.display = "block";
              const searchInput = searchContainer.querySelector(
                ".project-search-input"
              ) as HTMLInputElement;
              if (searchInput) {
                searchInput.focus();
              }
            }
          } else {
            // For other buttons, just execute the command
            elements.scriptText.value = command;
            elements.runButton.click();
          }
        }
      });
    });
  }

  /**
   * Applies the saved theme or default theme
   */
  private async applyTheme(): Promise<void> {
    if (!this.element) return;
    const theme = (await SettingsService.getSetting("theme")) as
      | "light"
      | "dark";
    this.applyThemeClass(theme);
  }

  /**
   * Applies the theme class to the window
   */
  private applyThemeClass(theme: "light" | "dark"): void {
    if (!this.element) return;
    this.element.classList.remove("light-theme", "dark-theme");
    this.element.classList.add(`${theme}-theme`);
  }

  /**
   * Sets up the resize handle functionality
   */
  private setupResizeHandles(): void {
    if (!this.element) return;

    const scriptContainer = this.element.querySelector(
      ".script-container"
    ) as HTMLElement;
    const scriptText = this.element.querySelector(
      "#scriptText"
    ) as HTMLTextAreaElement;
    const resizeHandle = this.element.querySelector(
      ".resize-handle"
    ) as HTMLElement;

    if (!scriptContainer || !scriptText || !resizeHandle) return;

    let startY = 0;
    let startHeight = 0;
    let isDragging = false;

    resizeHandle.addEventListener("mousedown", (e) => {
      isDragging = true;
      startY = e.clientY;
      startHeight = scriptText.offsetHeight;

      document.body.style.cursor = "row-resize";
      document.body.style.userSelect = "none";
    });

    document.addEventListener("mousemove", (e) => {
      if (!isDragging) return;

      const deltaY = e.clientY - startY;
      const newHeight = Math.max(100, startHeight + deltaY);

      scriptText.style.height = `${newHeight}px`;
      WindowStateService.saveScriptHeight(`${newHeight}px`);
    });

    document.addEventListener("mouseup", () => {
      if (!isDragging) return;
      isDragging = false;
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    });
  }

  /**
   * Retrieves all UI elements managed by the floating window.
   * @returns Object containing all UI elements
   * @throws Error if any element is not found
   */
  public getElements(): FloatingWindowElements {
    if (!this.element) {
      throw new Error("Floating window not initialized");
    }

    const elements = {
      window: this.element,
      status: this.element.querySelector(".status"),
      statusText: this.element.querySelector(".status-text"),
      statusDetails: this.element.querySelector(".status-details"),
      scriptText: this.element.querySelector("#scriptText"),
      runButton: this.element.querySelector("#runScript"),
      output: this.element.querySelector("#scriptOutput"),
      helpButton: this.element.querySelector("#helpButton"),
      starredButton: this.element.querySelector("#starredButton"),
      collapseButton: this.element.querySelector("#collapseButton"),
      minimizeButton: this.element.querySelector("#minimizeButton"),
      modeToggleButton: this.element.querySelector("#modeToggleButton"),
      scriptModeContainer: this.element.querySelector(".script-mode"),
      simpleModeContainer: this.element.querySelector(".simple-mode"),
    };

    // Validate all elements exist
    for (const [key, value] of Object.entries(elements)) {
      if (!value) {
        throw new Error(`Failed to find element: ${key}`);
      }
    }

    // Type assertion is safe here because we validated all elements exist
    return elements as FloatingWindowElements;
  }

  /**
   * Sets the UI state manager - critical for window state management
   */
  public setUIStateManager(manager: UIStateManager): void {
    this.uiStateManager = manager;
  }

  /**
   * Removes the floating window from the DOM.
   */
  public destroy(): void {
    // Remove URL change listeners
    window.removeEventListener(
      "popstate",
      this.handleLocationChange.bind(this)
    );
    window.removeEventListener(
      "locationchange",
      this.handleLocationChange.bind(this)
    );

    // Remove DOM observer
    if (this.domObserver) {
      this.domObserver.disconnect();
      this.domObserver = null;
    }

    // Clean up draggable manager
    if (this.draggableManager) {
      this.draggableManager.destroy();
      this.draggableManager = null;
    }

    this.element?.parentElement?.remove();
    this.element = null;
    this.outputDiv = null;
  }
}
