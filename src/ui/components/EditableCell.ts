/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/EditableCell.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import { ThemeManager } from "../theme";

// UI component for editing file names in the download table
// The cell that lets you rename without the drama!

const styles = {
  spacing: {
    sm: "4px",
    md: "8px",
  },
  borderRadius: "4px",
  fontSize: {
    sm: "12px",
    md: "14px",
  },
};

interface EditableCellOptions {
  initialValue: string;
  onSave: (newValue: string) => void;
  onCancel: () => void;
  validator?: (value: string) => string | null;
}

export class EditableCell {
  private container: HTMLElement;
  private input: HTMLInputElement;
  private error: HTMLElement;
  private initialValue: string;
  private validator: (value: string) => string | null;
  private onSave: (value: string) => void;
  private onCancel: () => void;
  private isEditing: boolean = false;
  private buttons: HTMLButtonElement[] = [];

  constructor(options: EditableCellOptions) {
    this.initialValue = options.initialValue;
    this.onSave = options.onSave;
    this.onCancel = options.onCancel;
    this.validator = options.validator || (() => null);

    this.container = document.createElement("div");
    this.container.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: ${styles.spacing.sm};
      `;

    // Create input field
    this.input = document.createElement("input");
    this.input.type = "text";
    this.input.value = this.initialValue;
    this.updateInputStyles();

    // Create error message element
    this.error = document.createElement("div");
    this.error.style.cssText = `
        color: #dc3545;
        font-size: ${styles.fontSize.sm};
        display: none;
      `;

    // Create button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.cssText = `
        display: flex;
        gap: ${styles.spacing.sm};
        margin-top: ${styles.spacing.sm};
      `;

    // Create save button
    const saveButton = this.createButton(
      "Save",
      () => this.handleSave(),
      "primary"
    );

    // Create cancel button
    const cancelButton = this.createButton(
      "Cancel",
      () => this.handleCancel(),
      "secondary"
    );

    buttonContainer.appendChild(saveButton);
    buttonContainer.appendChild(cancelButton);

    this.container.appendChild(this.input);
    this.container.appendChild(this.error);
    this.container.appendChild(buttonContainer);

    // Add keyboard handlers
    this.input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        this.handleSave();
      } else if (e.key === "Escape") {
        e.preventDefault();
        this.handleCancel();
      }
    });

    // Listen for theme changes
    ThemeManager.addThemeChangeListener(() => {
      this.updateInputStyles();
      this.updateButtonStyles();
    });
  }

  private updateInputStyles(): void {
    const colors = ThemeManager.getColors();
    this.input.style.cssText = `
        padding: ${styles.spacing.sm} ${styles.spacing.md};
        border: 1px solid ${colors.border};
        border-radius: ${styles.borderRadius};
        font-size: ${styles.fontSize.md};
        width: calc(100% - ${styles.spacing.md} * 2);
        background: ${colors.inputBg};
        color: ${colors.inputText};
      `;
  }

  private updateButtonStyles(): void {
    this.buttons.forEach((button) => {
      const variant = button.dataset.variant as "primary" | "secondary";
      this.applyButtonStyles(button, variant);
    });
  }

  private createButton(
    text: string,
    onClick: () => void,
    variant: "primary" | "secondary"
  ): HTMLButtonElement {
    const button = document.createElement("button");
    button.textContent = text;
    button.dataset.variant = variant;
    this.applyButtonStyles(button, variant);

    button.addEventListener("mouseover", () => {
      const colors = ThemeManager.getColors();
      button.style.background =
        variant === "primary" ? colors.hoverBg : colors.hoverBg;
    });

    button.addEventListener("mouseout", () => {
      this.applyButtonStyles(button, variant);
    });

    button.addEventListener("click", onClick);
    this.buttons.push(button);
    return button;
  }

  private applyButtonStyles(
    button: HTMLButtonElement,
    variant: "primary" | "secondary"
  ): void {
    const colors = ThemeManager.getColors();
    button.style.cssText = `
        padding: ${styles.spacing.sm} ${styles.spacing.md};
        border: none;
        border-radius: ${styles.borderRadius};
        font-size: ${styles.fontSize.sm};
        cursor: pointer;
        background: ${
          variant === "primary" ? colors.buttonBg : colors.background
        };
        color: ${variant === "primary" ? colors.buttonText : colors.text};
        border: 1px solid ${
          variant === "primary" ? "transparent" : colors.border
        };
      `;
  }

  private showError(message: string): void {
    this.error.textContent = message;
    this.error.style.display = "block";
    this.input.style.borderColor = "#dc3545";
  }

  private clearError(): void {
    const colors = ThemeManager.getColors();
    this.error.style.display = "none";
    this.input.style.borderColor = colors.border;
  }

  private handleSave(): void {
    const newValue = this.input.value.trim();
    const error = this.validator(newValue);

    if (error) {
      this.showError(error);
      return;
    }

    this.clearError();
    this.onSave(newValue);
  }

  private handleCancel(): void {
    this.input.value = this.initialValue;
    this.clearError();
    this.onCancel();
  }

  public getElement(): HTMLElement {
    return this.container;
  }

  public focus(): void {
    this.input.focus();
    // Select all text except extension
    const lastDot = this.input.value.lastIndexOf(".");
    if (lastDot > 0) {
      this.input.setSelectionRange(0, lastDot);
    } else {
      this.input.select();
    }
  }

  public destroy(): void {
    ThemeManager.removeThemeChangeListener(() => {
      this.updateInputStyles();
      this.updateButtonStyles();
    });
    this.container.remove();
  }
}
