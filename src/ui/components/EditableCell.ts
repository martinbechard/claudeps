/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/ui/components/EditableCell.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

// UI component for editing file names in the download table
// The cell that lets you rename without the drama!

const styles = {
  colors: {
    primary: "#0066cc",
    primaryHover: "#0052a3",
    border: "#ccc",
    text: "#333",
    textMuted: "#666",
    background: "#f8f9fa",
    error: "#dc3545",
    success: "#28a745",
  },
  spacing: {
    sm: "4px",
    md: "8px",
  },
  borderRadius: "4px",
  fontSize: {
    sm: "12px",
    md: "14px",
  },
};

interface EditableCellOptions {
  initialValue: string;
  onSave: (newValue: string) => void;
  onCancel: () => void;
  validator?: (value: string) => string | null;
}

export class EditableCell {
  private container: HTMLElement;
  private input: HTMLInputElement;
  private error: HTMLElement;
  private initialValue: string;
  private validator: (value: string) => string | null;
  private onSave: (value: string) => void;
  private onCancel: () => void;
  private isEditing: boolean = false;

  constructor(options: EditableCellOptions) {
    this.initialValue = options.initialValue;
    this.onSave = options.onSave;
    this.onCancel = options.onCancel;
    this.validator = options.validator || (() => null);

    this.container = document.createElement("div");
    this.container.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: ${styles.spacing.sm};
      `;

    // Create input field
    this.input = document.createElement("input");
    this.input.type = "text";
    this.input.value = this.initialValue;
    this.input.style.cssText = `
        padding: ${styles.spacing.sm} ${styles.spacing.md};
        border: 1px solid ${styles.colors.border};
        border-radius: ${styles.borderRadius};
        font-size: ${styles.fontSize.md};
        width: calc(100% - ${styles.spacing.md} * 2);
      `;

    // Create error message element
    this.error = document.createElement("div");
    this.error.style.cssText = `
        color: ${styles.colors.error};
        font-size: ${styles.fontSize.sm};
        display: none;
      `;

    // Create button container
    const buttonContainer = document.createElement("div");
    buttonContainer.style.cssText = `
        display: flex;
        gap: ${styles.spacing.sm};
        margin-top: ${styles.spacing.sm};
      `;

    // Create save button
    const saveButton = this.createButton(
      "Save",
      () => this.handleSave(),
      "primary"
    );

    // Create cancel button
    const cancelButton = this.createButton(
      "Cancel",
      () => this.handleCancel(),
      "secondary"
    );

    buttonContainer.appendChild(saveButton);
    buttonContainer.appendChild(cancelButton);

    this.container.appendChild(this.input);
    this.container.appendChild(this.error);
    this.container.appendChild(buttonContainer);

    // Add keyboard handlers
    this.input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        this.handleSave();
      } else if (e.key === "Escape") {
        e.preventDefault();
        this.handleCancel();
      }
    });
  }

  private createButton(
    text: string,
    onClick: () => void,
    variant: "primary" | "secondary"
  ): HTMLButtonElement {
    const button = document.createElement("button");
    button.textContent = text;
    button.style.cssText = `
        padding: ${styles.spacing.sm} ${styles.spacing.md};
        border: none;
        border-radius: ${styles.borderRadius};
        font-size: ${styles.fontSize.sm};
        cursor: pointer;
        background: ${
          variant === "primary"
            ? styles.colors.primary
            : styles.colors.background
        };
        color: ${variant === "primary" ? "white" : styles.colors.text};
        border: 1px solid ${
          variant === "primary" ? "transparent" : styles.colors.border
        };
      `;

    button.addEventListener("mouseover", () => {
      button.style.background =
        variant === "primary"
          ? styles.colors.primaryHover
          : styles.colors.border;
    });

    button.addEventListener("mouseout", () => {
      button.style.background =
        variant === "primary"
          ? styles.colors.primary
          : styles.colors.background;
    });

    button.addEventListener("click", onClick);
    return button;
  }

  private showError(message: string): void {
    this.error.textContent = message;
    this.error.style.display = "block";
    this.input.style.borderColor = styles.colors.error;
  }

  private clearError(): void {
    this.error.style.display = "none";
    this.input.style.borderColor = styles.colors.border;
  }

  private handleSave(): void {
    const newValue = this.input.value.trim();
    const error = this.validator(newValue);

    if (error) {
      this.showError(error);
      return;
    }

    this.clearError();
    this.onSave(newValue);
  }

  private handleCancel(): void {
    this.input.value = this.initialValue;
    this.clearError();
    this.onCancel();
  }

  public getElement(): HTMLElement {
    return this.container;
  }

  public focus(): void {
    this.input.focus();
    // Select all text except extension
    const lastDot = this.input.value.lastIndexOf(".");
    if (lastDot > 0) {
      this.input.setSelectionRange(0, lastDot);
    } else {
      this.input.select();
    }
  }

  public destroy(): void {
    this.container.remove();
  }
}
