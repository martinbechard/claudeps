/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/ui/components/DraggableManager.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import { WindowStateService } from "../../services/WindowStateService";
import { trace, DEBUG_KEYS } from "../../utils/trace";

/**
 * Configuration for draggable bounds.
 */
type DraggableBounds = {
  minX: number;
  maxX: number;
  minY: number;
  maxY: number;
};

/**
 * Manages draggable behavior for HTML elements.
 */
export class DraggableManager {
  private readonly window: HTMLElement;
  private readonly handle: HTMLElement;
  private isDragging: boolean = false;
  private currentX: number = 0;
  private currentY: number = 0;
  private initialX: number = 0;
  private initialY: number = 0;
  private startX: number = 0;
  private startY: number = 0;

  /**
   * Creates a new DraggableManager instance.
   * @param window - Element to make draggable
   * @param handle - Element that triggers dragging
   */
  constructor(window: HTMLElement, handle: HTMLElement) {
    this.window = window;
    this.handle = handle;
    this.setupEventListeners();
  }

  /**
   * Sets up event listeners for drag behavior.
   */
  private setupEventListeners(): void {
    this.handle.addEventListener("mousedown", this.handleMouseDown.bind(this));
    document.addEventListener("mousemove", this.handleMouseMove.bind(this));
    document.addEventListener("mouseup", this.handleMouseUp.bind(this));
  }

  /**
   * Gets the actual position of the window accounting for transforms
   */
  private getWindowPosition(): { x: number; y: number } {
    const rect = this.window.getBoundingClientRect();
    return {
      x: rect.left,
      y: rect.top,
    };
  }

  /**
   * Handles the start of a drag operation.
   * @param e - Mouse event
   */
  private handleMouseDown(e: MouseEvent): void {
    trace(DEBUG_KEYS.WINDOW, "DraggableManager.handleMouseDown Enter", {
      x: e.clientX,
      y: e.clientY,
    });
    const target = e.target as HTMLElement;

    // Don't initiate drag if clicking on a button or any interactive element
    if (
      target.tagName.toLowerCase() === "button" ||
      target.closest("button") ||
      target.hasAttribute("data-command")
    ) {
      trace(
        DEBUG_KEYS.WINDOW,
        "DraggableManager.handleMouseDown Exit - clicked on button/interactive element"
      );
      return;
    }

    // Only allow dragging from the handle area (status bar)
    if (e.target === this.handle || this.handle.contains(e.target as Node)) {
      this.isDragging = true;

      // Get the actual window position
      const pos = this.getWindowPosition();
      this.startX = pos.x;
      this.startY = pos.y;
      trace(
        DEBUG_KEYS.WINDOW,
        "DraggableManager.handleMouseDown Starting position:",
        pos
      );

      // Calculate the initial mouse offset
      this.initialX = e.clientX - this.startX;
      this.initialY = e.clientY - this.startY;

      // Remove transform and set absolute positioning
      this.window.style.transform = "none";
      this.window.style.position = "fixed";
      this.window.style.right = "auto";

      // Set initial position explicitly
      this.window.style.left = `${this.startX}px`;
      this.window.style.top = `${this.startY}px`;
      trace(
        DEBUG_KEYS.WINDOW,
        "DraggableManager.handleMouseDown Initial styles set"
      );
    }
    trace(DEBUG_KEYS.WINDOW, "DraggableManager.handleMouseDown Exit");
  }

  /**
   * Handles the drag movement.
   * @param e - Mouse event
   */
  private handleMouseMove(e: MouseEvent): void {
    if (!this.isDragging) return;

    trace(DEBUG_KEYS.WINDOW, "DraggableManager.handleMouseMove Enter", {
      x: e.clientX,
      y: e.clientY,
    });
    e.preventDefault();
    this.currentX = e.clientX - this.initialX;
    this.currentY = e.clientY - this.initialY;

    const bounds = this.calculateBounds();
    this.constrainToBounds(bounds);

    this.window.style.left = `${this.currentX}px`;
    this.window.style.top = `${this.currentY}px`;
    trace(DEBUG_KEYS.WINDOW, "DraggableManager.handleMouseMove New position:", {
      x: this.currentX,
      y: this.currentY,
    });
    trace(DEBUG_KEYS.WINDOW, "DraggableManager.handleMouseMove Exit");
  }

  /**
   * Calculates the bounds for dragging.
   * @returns Bounds object with min/max values
   */
  private calculateBounds(): DraggableBounds {
    return {
      minX: 0,
      maxX: window.innerWidth - this.window.offsetWidth,
      minY: 0,
      maxY: window.innerHeight - this.window.offsetHeight,
    };
  }

  /**
   * Constrains the current position to the specified bounds.
   * @param bounds - Bounds to constrain to
   */
  private constrainToBounds(bounds: DraggableBounds): void {
    this.currentX = Math.max(bounds.minX, Math.min(this.currentX, bounds.maxX));
    this.currentY = Math.max(bounds.minY, Math.min(this.currentY, bounds.maxY));
  }

  /**
   * Handles the end of a drag operation.
   */
  private handleMouseUp(): void {
    trace(DEBUG_KEYS.WINDOW, "DraggableManager.handleMouseUp Enter");
    if (!!this.isDragging) {
      // Get the final absolute position by using getBoundingClientRect
      const finalPosition = this.getWindowPosition();
      trace(
        DEBUG_KEYS.WINDOW,
        "DraggableManager.handleMouseUp Final position:",
        finalPosition
      );
      WindowStateService.savePosition(finalPosition.x, finalPosition.y);
      trace(DEBUG_KEYS.WINDOW, "DraggableManager.handleMouseUp Position saved");
    }
    this.isDragging = false;
    trace(DEBUG_KEYS.WINDOW, "DraggableManager.handleMouseUp Exit");
  }

  /**
   * Removes all event listeners.
   */
  public destroy(): void {
    trace(DEBUG_KEYS.WINDOW, "DraggableManager.destroy Enter");
    this.handle.removeEventListener(
      "mousedown",
      this.handleMouseDown.bind(this)
    );
    document.removeEventListener("mousemove", this.handleMouseMove.bind(this));
    document.removeEventListener("mouseup", this.handleMouseUp.bind(this));
    trace(
      DEBUG_KEYS.WINDOW,
      "DraggableManager.destroy Exit - All listeners removed"
    );
  }
}
