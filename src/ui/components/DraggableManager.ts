/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/ui/components/DraggableManager.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import { WindowStateService } from "../../services/WindowStateService";

/**
 * Configuration for draggable bounds.
 */
type DraggableBounds = {
  minX: number;
  maxX: number;
  minY: number;
  maxY: number;
};

/**
 * Manages draggable behavior for HTML elements.
 */
export class DraggableManager {
  private readonly window: HTMLElement;
  private readonly handle: HTMLElement;
  private isDragging: boolean = false;
  private currentX: number = 0;
  private currentY: number = 0;
  private initialX: number = 0;
  private initialY: number = 0;

  /**
   * Creates a new DraggableManager instance.
   * @param window - Element to make draggable
   * @param handle - Element that triggers dragging
   */
  constructor(window: HTMLElement, handle: HTMLElement) {
    this.window = window;
    this.handle = handle;
    this.setupEventListeners();
  }

  /**
   * Sets up event listeners for drag behavior.
   */
  private setupEventListeners(): void {
    this.handle.addEventListener("mousedown", this.handleMouseDown.bind(this));
    document.addEventListener("mousemove", this.handleMouseMove.bind(this));
    document.addEventListener("mouseup", this.handleMouseUp.bind(this));
  }

  /**
   * Handles the start of a drag operation.
   * @param e - Mouse event
   */
  private handleMouseDown(e: MouseEvent): void {
    if (e.target === this.handle || this.handle.contains(e.target as Node)) {
      this.isDragging = true;
      this.initialX = e.clientX - this.window.offsetLeft;
      this.initialY = e.clientY - this.window.offsetTop;
      this.window.style.position = "absolute";
      this.window.style.right = "auto";
    }
  }

  /**
   * Handles the drag movement.
   * @param e - Mouse event
   */
  private handleMouseMove(e: MouseEvent): void {
    if (!this.isDragging) return;

    e.preventDefault();
    this.currentX = e.clientX - this.initialX;
    this.currentY = e.clientY - this.initialY;

    const bounds = this.calculateBounds();
    this.constrainToBounds(bounds);

    this.window.style.left = `${this.currentX}px`;
    this.window.style.top = `${this.currentY}px`;
  }

  /**
   * Calculates the bounds for dragging.
   * @returns Bounds object with min/max values
   */
  private calculateBounds(): DraggableBounds {
    return {
      minX: 0,
      maxX: window.innerWidth - this.window.offsetWidth,
      minY: 0,
      maxY: window.innerHeight - this.window.offsetHeight,
    };
  }

  /**
   * Constrains the current position to the specified bounds.
   * @param bounds - Bounds to constrain to
   */
  private constrainToBounds(bounds: DraggableBounds): void {
    this.currentX = Math.max(bounds.minX, Math.min(this.currentX, bounds.maxX));
    this.currentY = Math.max(bounds.minY, Math.min(this.currentY, bounds.maxY));
  }

  /**
   * Handles the end of a drag operation.
   */
  private handleMouseUp(): void {
    if (this.isDragging) {
      // Save position when drag ends
      WindowStateService.savePosition(this.currentX, this.currentY);
    }
    this.isDragging = false;
  }

  /**
   * Removes all event listeners.
   */
  public destroy(): void {
    this.handle.removeEventListener(
      "mousedown",
      this.handleMouseDown.bind(this)
    );
    document.removeEventListener("mousemove", this.handleMouseMove.bind(this));
    document.removeEventListener("mouseup", this.handleMouseUp.bind(this));
  }
}
