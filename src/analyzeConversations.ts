// Copyright (c) 2024 Martin Bechard martin.bechard@DevConsult.ca
// This software is licensed under the MIT License.
// Path: src/analyzeConversations.ts
// This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
// Script to analyze conversation data from a JSON file
// "I count characters so you don't have to!"

import { ConversationAnalyzer } from "./ConversationAnalyzer";
import * as fs from "fs/promises";

async function analyzeFile(
  filePath: string,
  options: {
    messageId?: string;
    minBytes?: number;
  }
) {
  try {
    const data = await fs.readFile(filePath, "utf8");
    const analyzer = new ConversationAnalyzer(JSON.parse(data));

    // If message ID is provided, show detailed message info
    if (options.messageId) {
      const result = analyzer.findMessageById(options.messageId);
      if (!result) {
        console.error(`Message with ID ${options.messageId} not found`);
        process.exit(1);
      }

      const byteLength = new TextEncoder().encode(
        result.message.content
      ).length;

      console.log("\nMessage Details:");
      console.log("-----------------");
      console.log(
        `Conversation: ${result.conversation.name} (${result.conversation.id})`
      );
      console.log(`Message ID: ${result.message.id}`);
      console.log(`Sender: ${result.message.sender}`);
      console.log(
        `Character Length: ${result.message.content.length} characters`
      );
      console.log(`Byte Length: ${byteLength} bytes`);
      console.log("\nContent:");
      console.log("-----------------");
      console.log(result.message.content);
      return;
    }

    // Otherwise show general analysis
    const results = analyzer.analyze();

    // Print results in a formatted way
    console.log("Conversation Analysis Results\n");

    // Sort conversations by total size, largest first
    const sortedConversations = results.conversationMetrics.sort(
      (a, b) => b.totalSize - a.totalSize
    );

    // Find the longest ID for alignment
    const idLength = 36; // UUID length
    const bytesLength = 12; // Length for formatted byte numbers

    // Helper function to pad spaces for alignment
    const padSpaces = (length: number) => " ".repeat(length);

    // Process each conversation
    let totalConversations = 0;
    let grandTotal = 0;

    sortedConversations.forEach((conv) => {
      // Filter messages if minBytes is specified
      const filteredMessages = options.minBytes
        ? conv.messageLengths.filter(
            (msg) => msg.byteLength >= options.minBytes!
          )
        : conv.messageLengths;

      // Skip conversation if all messages were filtered out
      if (filteredMessages.length === 0) return;

      totalConversations++;
      grandTotal += conv.totalSize;

      // Sort messages by byte length in descending order
      const sortedMessages = filteredMessages.sort(
        (a, b) => b.byteLength - a.byteLength
      );

      // Print conversation line
      console.log(
        `${conv.conversationId} - ${conv.totalSize
          .toLocaleString()
          .padStart(bytesLength)} - ${conv.conversationName}`
      );

      // Print each message that passed the filter
      sortedMessages.forEach((msg) => {
        const message = conv.conversations
          .find((c) => c.messages.find((m) => m.id === msg.messageId))
          ?.messages.find((m) => m.id === msg.messageId);

        if (message) {
          const truncatedContent =
            message.content.length > 80
              ? message.content.substring(0, 77) + "..."
              : message.content;
          const contentLine = truncatedContent
            .replace(/\\n/g, " ")
            .replace(/\\s+/g, " ");
          console.log(
            `${padSpaces(2)}${msg.messageId} - ${msg.byteLength
              .toLocaleString()
              .padStart(bytesLength)} - ${contentLine}`
          );
        }
      });

      console.log(""); // Empty line between conversations
    });

    // Print grand total
    console.log(
      `Total: ${totalConversations} conversation${
        totalConversations === 1 ? "" : "s"
      }, ${grandTotal.toLocaleString()} bytes`
    );
  } catch (error) {
    console.error("Error analyzing file:", error);
    process.exit(1);
  }
}

// Parse command line arguments
const args = process.argv.slice(2);
let filePath: string | undefined;
const options: { messageId?: string; minBytes?: number } = {};

// Parse arguments
for (let i = 0; i < args.length; i++) {
  if (args[i] === "--message" || args[i] === "-m") {
    options.messageId = args[i + 1];
    i++; // Skip next argument since we used it
  } else if (args[i] === "--min") {
    const minBytes = parseInt(args[i + 1], 10);
    if (isNaN(minBytes)) {
      console.error("Error: --min value must be a number");
      process.exit(1);
    }
    options.minBytes = minBytes;
    i++; // Skip next argument since we used it
  } else {
    filePath = args[i];
  }
}

if (!filePath) {
  console.error(
    "Usage: node analyzeConversations.js <file_path> [--message|-m message_id] [--min minimum_bytes]"
  );
  process.exit(1);
}

analyzeFile(filePath, options);
