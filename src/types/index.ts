/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/types/index.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import { CommandName } from "../utils/commands/CommandMap";

/**
 * Search result information for conversations
 */
export interface SearchResultInfo {
  conversationId: string; // ID of the matching conversation
  messageId: string; // UUID of the specific message that matches
  matchReason: string; // Clear explanation of why this conversation matches
  relevantSnippet: string; // The specific text snippet that matches (max 200 chars)
}

/**
 * Stop condition information for script parsing
 */
export interface StopCondition {
  target: string;
  type: "if" | "if_not";
}

/**
 * Parsed command line information
 */
export interface ParsedCommandLine {
  command: CommandName;
  rawCommand: string;
  options: { [key: string]: string };
  prompt: string;
}

/**
 * Represents a single script statement with its stop conditions
 */
export interface ScriptStatementProps {
  prompt?: string;
  isCommand: boolean;
  command?: CommandName | null;
  options?: CommandOptions; // Includes maxTries
  searchText?: string; // Optional search text for search commands
  aliasCommand?: AliasCommand; // Optional alias command details
}

export class ScriptStatement {
  public readonly prompt?: string;
  public readonly isCommand: boolean;
  public readonly command?: CommandName | null;
  public readonly options: CommandOptions;
  public readonly searchText?: string; // Optional search text for search commands
  public readonly aliasCommand?: AliasCommand; // Optional alias command details

  constructor(props: ScriptStatementProps) {
    this.prompt = props.prompt;
    this.isCommand = props.isCommand;
    this.command = props.command;
    this.options = props.options || {};
    this.searchText = props.searchText;
    this.aliasCommand = props.aliasCommand;
  }

  public addStopCondition(stopCondition: StopCondition) {
    let conditions = this.options["stopConditions"];
    if (!conditions) {
      this.options["stopConditions"] = conditions = [];
    }
    conditions.push(stopCondition);
  }
}

/**
 * Options for command execution
 */
export interface CommandOptions {
  includeArtifacts?: boolean;
  includeConversation?: boolean;
  downloadMultiple?: boolean;
  maxTries?: number; // For repeat command
  stopConditions?: StopCondition[];
}

/**
 * Represents an alias command operation
 */
export interface AliasCommand {
  type: "alias" | "delete_alias" | "list_alias";
  name?: string; // For set and delete
  text?: string; // For set
}

/**
 * Represents a script to be executed
 */
export interface Script {
  statements: ScriptStatement[];
}

/**
 * Callback type for custom content retrieval before download
 */
export type ContentCallback = (docInfo: DocumentInfo) => Promise<string>;

/**
 * Represents document metadata and content
 */
export interface DocumentInfo {
  fileName: string;
  filePath: string;
  content: string;
  isSelected?: boolean;
  metadata?: Record<string, any>;
  contentCallback?: ContentCallback;
  searchResult?: SearchResultInfo;
}

/**
 * Status types for operation states
 */
export type StatusState = "ready" | "working" | "error";

/**
 * Configuration for status states and their display properties
 */
export interface StatusConfig {
  text: string;
  class: string;
}

/**
 * Required elements for status management
 */
export interface StatusElements {
  statusElement: HTMLElement;
  statusText: HTMLElement;
  statusDetails: HTMLElement;
  scriptInput: HTMLTextAreaElement;
  runButton: HTMLButtonElement;
}

/**
 * Elements managed by floating window interface
 */
export interface FloatingWindowElements {
  window: HTMLElement;
  status: HTMLElement;
  statusText: HTMLElement;
  statusDetails: HTMLElement;
  scriptText: HTMLTextAreaElement;
  runButton: HTMLButtonElement;
  output: HTMLElement;
  helpButton: HTMLButtonElement;
  minimizeButton: HTMLButtonElement;
  collapseButton: HTMLElement;
  modeToggleButton: HTMLButtonElement;
  scriptModeContainer: HTMLElement;
  simpleModeContainer: HTMLElement;
}

/**
 * Settings for a conversation
 */
export interface ConversationSettings {
  preview_feature_uses_artifacts: boolean;
  preview_feature_uses_latex: boolean;
  enabled_artifacts_attachments: boolean;
}

/**
 * Project information
 */
export interface Project {
  uuid: string;
  name: string;
}

/**
 * File attachment information
 */
export interface Attachment {
  id: string;
  file_name: string;
  file_size: number;
  file_type: string;
  extracted_content?: string;
  created_at?: string;
}

/**
 * V2 File attachment information
 */
export interface FileV2 extends Attachment {
  // Add any v2-specific fields here if they exist
}

/**
 * Represents a message content item in the conversation
 */
export interface ChatMessageContent {
  type: "text" | "tool_use" | "tool_result";

  // Type text
  text?: string;

  // Type tool_use
  name?: string;
  input?: ChatMessageInput;

  // Type tool_result
  content?: any[];
  is_error?: boolean;
}

/**
 * Represents input for tool-based messages
 */
export interface ChatMessageInput {
  command: "create" | "update";
  id: string;
  type?: "text" | "application/vnd.ant.code";
  title?: string;

  // Full file
  content?: string;
  language?: string;
  version_uuid?: string;

  // Update command
  old_str?: string;
  new_str?: string;
}

/**
 * Represents a message in the conversation
 */
export interface ChatMessage {
  uuid: string;
  text: string;
  content: ChatMessageContent[];
  sender: "human" | "assistant";
  index: number;
  created_at: string;
  updated_at: string;
  truncated: boolean;
  stop_reason?: string;
  attachments: Attachment[];
  files: Attachment[];
  files_v2: FileV2[];
  sync_sources: any[];
  parent_message_uuid: string;
}

/**
 * Represents a conversation within a project
 */
export interface ProjectConversation {
  uuid: string;
  name: string;
  summary?: string;
  created_at: string;
  updated_at: string;
  message_count: number;
}

/**
 * Represents a complete conversation
 */
export interface Conversation {
  uuid: string;
  name: string;
  summary: string;
  created_at: string;
  updated_at: string;
  settings: ConversationSettings;
  is_starred: boolean;
  project_uuid: string;
  project?: Project;
  current_leaf_message_uuid: string;
  chat_messages: ChatMessage[];
}

/**
 * Represents an artifact extracted from a conversation
 */
export interface ConversationArtifact {
  id: string;
  title: string;
  language?: string;
  content?: string;
  delta?: { old: string; new: string };
  filePath?: string;
  created_at: string; // Add this
  updated_at: string; // Add this
}

/**
 * Response from the Claude API for completions
 */
export interface CompletionResponse {
  completion: string;
  stop_reason: string;
  model: string;
  stop: string | null;
  log_id: string;
  messageLimit: {
    type: string;
    remaining: number;
  };
}
