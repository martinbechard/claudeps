/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/services/ScriptExecutionManager.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Manages script execution and state
 * Note: Keeping your scripts running smoothly since 2024!
 */

import { ScriptParser } from "../utils/ScriptParser";
import { ScriptRunner } from "./ScriptRunner";
import { CommandExecutor } from "./CommandExecutor";
import { ClaudeCache } from "./ClaudeCache";
import type { Script, ScriptStatement } from "../types";
import type { StatusManager } from "../ui/components/StatusManager";

type LogFunction = (
  message: string,
  type?: "info" | "error" | "success"
) => void;

export class ScriptExecutionManager {
  private readonly scriptRunner: ScriptRunner;

  private readonly statusManager: StatusManager;
  private readonly handleLog: LogFunction;
  private isExecuting: boolean = false;

  constructor(
    statusManager: StatusManager,
    handleLog: LogFunction,
    outputElement: HTMLElement
  ) {
    this.statusManager = statusManager;
    this.handleLog = handleLog;
    this.scriptRunner = new ScriptRunner(
      handleLog,
      new CommandExecutor(statusManager, handleLog, outputElement)
    );
  }

  /**
   * Executes a script from raw text input
   * @param scriptText - Raw script text to execute
   * @throws Error if script execution fails
   */
  public async executeScript(scriptText: string): Promise<void> {
    if (this.isExecuting) {
      this.handleLog("Cancelling current execution...", "info");
      this.cancel();
      return;
    }

    const text = scriptText.trim();
    if (!text) {
      this.handleLog("Please enter a script", "error");
      return;
    }

    try {
      this.isExecuting = true;

      // Clear cache at start of any new execution
      ClaudeCache.clearCache();
      this.handleLog("Cache cleared", "info");

      const script = ScriptParser.parse(text);
      await this.statusManager.setStatus("working", "Running script...");

      await this.scriptRunner.runScript(script);

      await this.statusManager.setStatus("ready", "Complete");
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      this.handleLog(`Script error: ${message}`, "error");
      await this.statusManager.setStatus("error", message);
      setTimeout(() => this.statusManager.setStatus("ready"), 2000);
    } finally {
      this.isExecuting = false;
    }
  }

  /**
   * Cancels the current script execution
   */
  public cancel(): void {
    if (this.isExecuting) {
      this.scriptRunner.cancel();
      this.isExecuting = false;
    }
  }

  /**
   * Checks if a script is currently executing
   * @returns True if script is executing
   */
  public isScriptExecuting(): boolean {
    return this.isExecuting;
  }
}
