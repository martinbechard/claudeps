/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/services/WindowStateService.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for managing and persisting window state
 * Note: Remembering your window preferences, so you don't have to!
 */

import { StorageService } from "./StorageService";
import { trace, DEBUG_KEYS } from "../utils/trace";

interface WindowGeometry {
  x: number;
  y: number;
  width: string;
  height: string;
  isMinimized: boolean;
  isCollapsed: boolean;
  isScriptMode: boolean;
  scriptHeight?: string;
}

export class WindowStateService {
  private static readonly STORAGE_KEY = "claude_extension_window_state";
  private static readonly DEFAULT_STATE: WindowGeometry = {
    x: 20,
    y: 20,
    width: "500px",
    height: "500px",
    isMinimized: false,
    isCollapsed: false,
    scriptHeight: "100px",
    isScriptMode: false,
  };

  private static cachedState: WindowGeometry | undefined;

  /**
   * Loads the saved window state from storage or cache
   */
  public static async loadState(): Promise<WindowGeometry> {
    try {
      // Return cached state if available
      if (this.cachedState) {
        return this.cachedState;
      }

      // Load from storage if no cached state
      const savedState = await StorageService.get<WindowGeometry>(
        this.STORAGE_KEY
      );
      trace(
        DEBUG_KEYS.WINDOW,
        "WindowStateService Loading state from storage:",
        savedState
      );

      // Cache and return the loaded state
      this.cachedState = savedState || { ...this.DEFAULT_STATE };
      return this.cachedState;
    } catch (error) {
      console.error("Failed to load window state:", error);
      this.cachedState = { ...this.DEFAULT_STATE };
      return this.cachedState;
    }
  }

  /**
   * Updates window state, optionally persisting to storage and cache
   */
  public static async saveState(state: Partial<WindowGeometry>): Promise<void> {
    try {
      // Get current state from cache or load it
      const currentState = this.cachedState || (await this.loadState());

      // Check if any values are different
      let hasChanges = false;
      for (const [key, value] of Object.entries(state)) {
        if (currentState[key as keyof WindowGeometry] !== value) {
          hasChanges = true;
          trace(
            DEBUG_KEYS.WINDOW,
            `WindowStateService State change: ${key} = ${value}`
          );
          break;
        }
      }

      // Only update if there are actual changes
      if (hasChanges) {
        const newState = { ...currentState, ...state };

        trace(
          DEBUG_KEYS.WINDOW,
          "WindowStateService Updating cache and storage:",
          newState
        );
        this.cachedState = newState;
        await StorageService.set(this.STORAGE_KEY, newState);
      } else {
        trace(DEBUG_KEYS.WINDOW, "WindowStateService No changes to save");
      }
    } catch (error) {
      console.error("Failed to save window state:", error);
    }
  }

  public static async saveMode(isScriptMode: boolean): Promise<void> {
    await this.saveState({ isScriptMode });
  }

  /**
   * Updates window position - temporary during drag, persisted on drag end
   */
  public static async savePosition(x: number, y: number): Promise<void> {
    await this.saveState({ x, y });
  }

  /**
   * Updates window dimensions - temporary during resize, persisted on resize end
   */
  public static async saveGeometry(
    width: string,
    height: string
  ): Promise<void> {
    await this.saveState({ width, height });
  }

  /**
   * Updates script textarea height
   */
  public static async saveScriptHeight(height: string): Promise<void> {
    await this.saveState({ scriptHeight: height });
  }

  /**
   * Updates window state flags
   */
  public static async saveWindowState(
    isMinimized: boolean,
    isCollapsed: boolean
  ): Promise<void> {
    await this.saveState({ isMinimized, isCollapsed });
  }

  /**
   * Ensures coordinates are within viewport bounds
   */
  private static constrainToViewport(
    x: number,
    y: number,
    width: string,
    height: string
  ): { x: number; y: number } {
    const viewportWidth =
      window.innerWidth || document.documentElement.clientWidth;
    const viewportHeight =
      window.innerHeight || document.documentElement.clientHeight;

    // Parse dimensions, removing 'px' suffix
    const widthNum = parseInt(width) || 400;
    const heightNum = parseInt(height) || 500;

    // Ensure at least 100px of the window is always visible
    const minVisibleWidth = Math.min(widthNum, 100);
    const minVisibleHeight = Math.min(heightNum, 100);

    return {
      x: Math.min(Math.max(0, x), viewportWidth - minVisibleWidth),
      y: Math.min(Math.max(0, y), viewportHeight - minVisibleHeight),
    };
  }

  /**
   * Applies saved state to window element
   */
  public static async applyState(
    windowElement: HTMLElement,
    scriptElement?: HTMLElement
  ): Promise<void> {
    const state = await this.loadState();

    // Set absolute positioning
    windowElement.style.position = "absolute";
    windowElement.style.right = "auto"; // Clear any right positioning

    // Constrain position to viewport using the stored dimensions directly
    const { x, y } = this.constrainToViewport(
      state.x,
      state.y,
      state.width,
      state.height
    );

    // Always apply constrained position
    windowElement.style.left = `${x}px`;
    windowElement.style.top = `${y}px`;

    // Apply minimized state
    if (state.isMinimized) {
      windowElement.classList.add("minimized");
      windowElement.style.width = "";
      windowElement.style.height = "";
    } else {
      windowElement.classList.remove("minimized");
      // Use stored dimensions directly
      windowElement.style.width = state.width;
      windowElement.style.height = state.height;
    }

    // Apply script height if element provided
    if (scriptElement && state.scriptHeight) {
      scriptElement.style.height = state.scriptHeight;
    }

    // Handle collapse state
    if (state.isCollapsed) {
      const outputDiv = windowElement.querySelector(
        "#scriptOutput"
      ) as HTMLElement;
      if (outputDiv) {
        outputDiv.style.maxHeight = "3em";
        outputDiv.style.overflowY = "hidden";
      }
    }
  }
}
