/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: /Users/martinbechard/dev/claudeext/src/services/ScriptRunner.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import type { Script, ScriptStatement, StopCondition } from "../types";
import { CommandExecutor } from "./CommandExecutor";
import type { StatusManager } from "../ui/components/StatusManager";

/**
 * Callback type for logging output from the script runner.
 */
type LogCallback = (
  message: string,
  type?: "info" | "error" | "success"
) => void;

/**
 * Manages script execution and streaming state.
 */
export class ScriptRunner {
  private isRunning: boolean = false;
  private readonly logCallback: LogCallback;
  private readonly MAX_ATTEMPTS_WAIT_RESPONSE: number = 300;
  private readonly CHECK_INTERVAL: number = 100;
  private readonly commandExecutor: CommandExecutor;
  private readonly statusManager: StatusManager;

  constructor(
    logCallback: LogCallback,
    commandExecutor: CommandExecutor,
    statusManager: StatusManager
  ) {
    this.logCallback = logCallback;
    this.commandExecutor = commandExecutor;
    this.statusManager = statusManager;
  }

  /**
   * Executes a command script
   * @param script - Parsed command script to execute
   * @throws Error if command execution fails
   */
  private async executeCommand(script: ScriptStatement): Promise<void> {
    if (!script.command && !script.aliasCommand) {
      throw new Error("No command specified");
    }

    await this.commandExecutor.executeCommand(script);
  }

  /**
   * Executes a script with the provided configuration.
   * @param script - Script configuration to execute
   * @throws Error if script execution fails
   */
  public async runScript(script: Script): Promise<void> {
    if (this.isRunning) {
      throw new Error("Script is already running");
    }

    try {
      this.isRunning = true;

      // Execute each statement in sequence
      let shouldContinue = true;
      for (const statement of script.statements) {
        if (!shouldContinue || !this.isRunning) break;

        try {
          if (statement.isCommand) {
            await this.executeCommand(statement);
            continue;
          }

          if (!statement.prompt) {
            continue;
          }

          const response = await this.executePrompt(statement.prompt);

          // Check all stop conditions
          if (statement.options?.stopConditions?.length) {
            const stopReason = this.checkStopConditions(
              response,
              statement.options?.stopConditions
            );

            if (stopReason) {
              this.logCallback(`Stop condition met: ${stopReason}`, "info");
              shouldContinue = false;
              break;
            }
          }
        } catch (error) {
          this.logCallback(
            `Statement execution failed: ${
              error instanceof Error ? error.message : "Unknown error"
            }`,
            "error"
          );
          return;
        }
      }

      // If all statements executed and no stop conditions met, we're done
      if (shouldContinue) {
        this.logCallback("Script completed successfully", "success");
        return;
      }
    } catch (error) {
      this.logCallback(
        `Script execution failed: ${
          error instanceof Error ? error.message : "Unknown error"
        }`,
        "error"
      );
      throw error;
    } finally {
      this.isRunning = false;
    }
  }

  /**
   * Executes a single statement and waits for response
   * @param prompt - Prompt text to execute
   * @returns The response text
   * @throws Error if execution fails
   */
  private async executePrompt(prompt: string): Promise<string> {
    const targetDiv = await this.findInputElement();
    await this.insertPrompt(prompt);
    await this.simulateEnterKey(targetDiv);
    return await this.checkStreaming();
  }

  /**
   * Checks stop conditions against a response
   * @param response - Response text to check
   * @param stopConditions - Array of conditions to check
   * @returns The matching condition or null if none match
   */
  private checkStopConditions(
    response: string,
    stopConditions: StopCondition[]
  ): string | null {
    for (const condition of stopConditions) {
      const contained = response.includes(condition.target);
      if (
        (condition.type === "if" && contained) ||
        (condition.type === "if_not" && !contained)
      ) {
        return `${condition.type} ${condition.target}`;
      }
    }
    return null;
  }

  /**
   * Monitors the streaming state of Claude's response.
   * @returns The final response text
   * @throws Error if monitoring times out
   */
  private async checkStreaming(): Promise<string> {
    let stableCount = 0;
    let attempts = 0;
    let lastContent = "";
    let lastStreamingDiv: Element | null = null;

    while (attempts < this.MAX_ATTEMPTS_WAIT_RESPONSE && this.isRunning) {
      const streamingDiv = document.querySelector(
        'div[data-is-streaming="true"]'
      );

      if (streamingDiv) {
        if (streamingDiv.textContent !== lastContent) {
          stableCount = 0;
          lastContent = streamingDiv.textContent || "";
          lastStreamingDiv = streamingDiv;
        } else {
          stableCount++;
        }
      } else if (lastStreamingDiv) {
        return lastStreamingDiv.textContent || "";
      } else {
        stableCount++;
      }

      if (stableCount >= 20) {
        return lastContent;
      }

      await new Promise((resolve) => setTimeout(resolve, this.CHECK_INTERVAL));
      attempts++;
    }

    if (!this.isRunning) {
      throw new Error("Operation cancelled");
    }
    throw new Error("Response timeout");
  }

  /**
   * Finds the input element for script execution.
   * @returns Promise resolving to the input element
   * @throws Error if element not found
   */
  private async findInputElement(): Promise<Element> {
    const targetDiv = document.querySelector('div[enterkeyhint="enter"]');
    if (!targetDiv) {
      throw new Error("Input element not found");
    }
    return targetDiv;
  }

  /**
   * Inserts or updates prompt text in the input element
   * @param text - Text to insert
   */
  private async insertPrompt(text: string): Promise<void> {
    const targetDiv = await this.findInputElement();
    const paragraphs = targetDiv.querySelectorAll("p");

    if (
      paragraphs.length === 1 &&
      paragraphs[0].hasAttribute("data-placeholder")
    ) {
      // Empty state - replace content
      paragraphs[0].innerHTML = text;
    } else {
      // Has content - append new paragraph
      const newP = document.createElement("p");
      newP.innerHTML = text;
      targetDiv.appendChild(newP);
    }

    (targetDiv as HTMLElement).focus();
    await new Promise((resolve) => setTimeout(resolve, 100));
  }

  /**
   * Simulates pressing the Enter key.
   * @param element - Element to receive the key event
   */
  private simulateEnterKey(element: Element): void {
    const events = [
      new KeyboardEvent("keydown", {
        key: "Enter",
        code: "Enter",
        keyCode: 13,
        which: 13,
        bubbles: true,
      }),
      new KeyboardEvent("keypress", {
        key: "Enter",
        code: "Enter",
        keyCode: 13,
        which: 13,
        bubbles: true,
      }),
      new KeyboardEvent("keyup", {
        key: "Enter",
        code: "Enter",
        keyCode: 13,
        which: 13,
        bubbles: true,
      }),
    ];

    events.forEach((event) => element.dispatchEvent(event));
  }

  /**
   * Cancels the currently running script.
   */
  public cancel(): void {
    this.isRunning = false;
  }
}
