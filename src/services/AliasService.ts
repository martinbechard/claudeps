/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/services/AliasService.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 */

import { IStorage, BrowserStorage, MemoryStorage } from "../types/storage";

/**
 * Structure for storing alias data
 */
interface AliasData {
  [key: string]: string;
}

/**
 * Service for managing aliases stored in storage
 */
export class AliasService {
  private static readonly STORAGE_KEY = "claude_extension_aliases";
  private static storage: IStorage;

  /**
   * Initialize the storage system
   */
  public static initialize(storage?: IStorage): void {
    if (storage) {
      this.storage = storage;
    } else {
      try {
        // Test if we're in a browser environment
        if (typeof window !== "undefined" && window.localStorage) {
          this.storage = new BrowserStorage();
        } else {
          this.storage = new MemoryStorage();
        }
      } catch (error) {
        this.storage = new MemoryStorage();
      }
    }
  }

  /**
   * Ensures storage is initialized
   */
  private static ensureStorage(): void {
    if (!this.storage) {
      this.initialize();
    }
  }

  /**
   * Retrieves all stored aliases
   */
  public static async getAliases(): Promise<AliasData> {
    this.ensureStorage();
    try {
      const data = await this.storage.getItem(this.STORAGE_KEY);
      return data ? JSON.parse(data) : {};
    } catch (error) {
      console.error("Error retrieving aliases:", error);
      return {};
    }
  }

  /**
   * Gets a specific alias by name
   */
  public static async getAlias(name: string): Promise<string | undefined> {
    this.ensureStorage();
    const aliases = await this.getAliases();
    return aliases[name];
  }

  /**
   * Creates or updates an alias
   */
  public static async setAlias(name: string, text: string): Promise<void> {
    this.ensureStorage();
    if (!this.isValidAliasName(name)) {
      throw new Error(
        "Invalid alias name. Use only letters, numbers, and underscores."
      );
    }

    try {
      const aliases = await this.getAliases();
      aliases[name] = text;
      await this.storage.setItem(this.STORAGE_KEY, JSON.stringify(aliases));
    } catch (error) {
      throw new Error(
        `Failed to save alias: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
    }
  }

  /**
   * Deletes an alias
   */
  public static async deleteAlias(name: string): Promise<boolean> {
    this.ensureStorage();
    const aliases = await this.getAliases();
    if (!(name in aliases)) {
      return false;
    }

    delete aliases[name];
    await this.storage.setItem(this.STORAGE_KEY, JSON.stringify(aliases));
    return true;
  }

  /**
   * Validates an alias name
   */
  private static isValidAliasName(name: string): boolean {
    return /^[a-zA-Z0-9_]+$/.test(name);
  }

  /**
   * Processes text to replace all aliases with their values
   */
  public static async processText(text: string): Promise<string> {
    this.ensureStorage();
    const aliases = await this.getAliases();
    let processedText = text;

    // Sort aliases by length (longest first) to handle nested aliases correctly
    const sortedAliases = Object.entries(aliases).sort(
      (a, b) => b[0].length - a[0].length
    );

    for (const [name, value] of sortedAliases) {
      // Use lookbehind to ensure @ is not preceded by non-whitespace characters
      const regex = new RegExp(`(?<!\\S)@${name}\\b`, "g");
      processedText = processedText.replace(regex, value);
    }

    return processedText;
  }

  /**
   * Clears all aliases from storage
   */
  public static async clearAllAliases(): Promise<void> {
    this.ensureStorage();
    await this.storage.removeItem(this.STORAGE_KEY);
  }

  /**
   * Gets a formatted list of all aliases
   */
  public static async getAliasList(): Promise<string[]> {
    this.ensureStorage();
    const aliases = await this.getAliases();
    return Object.entries(aliases).map(([name, value]) => `@${name}: ${value}`);
  }
}
