/**
 * Copyright (c) 2024 Martin Bechard <martin.bechard@DevConsult.ca>
 * This software is licensed under the MIT License.
 * File: src/services/AnthropicService.ts
 * This was generated by Claude Sonnet 3.5, with the assistance of my human mentor
 *
 * Service for making requests to the Anthropic API
 * Note: Your friendly neighborhood AI API whisperer!
 */

import { SettingsService } from "./SettingsService";
import { requestCompletion } from "../utils/requestCompletion";
import { MessageLimitError } from "@/utils/messageUtils";

export interface Message {
  role: "human" | "assistant";
  content: string;
}

export interface AnthropicResponse {
  id: string;
  type: string;
  role: string;
  content: Array<{
    type: string;
    text: string;
  }>;
  model: string;
  stop_reason: string | null;
  stop_sequence: string | null;
  usage: {
    input_tokens: number;
    output_tokens: number;
  };
}

export interface CompletionOptions {
  prompt?: string;
  messages?: Message[];
  maxTokens?: number;
  temperature?: number;
  topP?: number;
  topK?: number;
  signal?: AbortSignal;
  forceNoApiKey?: boolean;
  continueConversation?: boolean;
}

export interface CompletionResult {
  success: boolean;
  text?: string;
  error?: string;
  cancelled?: boolean;
}

export class AnthropicService {
  /**
   * Makes a request to the Anthropic API through the background script
   */
  public static async complete(
    options: CompletionOptions
  ): Promise<CompletionResult> {
    console.log("[AnthropicService] Starting API request");
    let debugTrace = false;

    try {
      const enableApi = await SettingsService.getSetting("enableAnthropicApi");
      debugTrace = (await SettingsService.getSetting(
        "debugTraceRequests"
      )) as boolean;

      if (!enableApi || options.forceNoApiKey) {
        console.log(
          "[AnthropicService] Using claude.ai directly",
          options.forceNoApiKey ? "(forced)" : "(API disabled)"
        );
        try {
          if (debugTrace) {
            console.log("[Debug] Claude.ai Request:", {
              messages: options.messages,
              messageSize: JSON.stringify(options.messages || options.prompt)
                .length,
            });
          }

          const response = await requestCompletion({
            messages: options.messages,
            prompt: options.prompt,
            stream: false,
            renderingMode: "messages",
            continueConversation: options.continueConversation,
          }).catch((error) => {
            // Check for 429 status and throw MessageLimitError
            if (error instanceof Error) {
              if (
                error.message.includes("429") ||
                error.message.includes("Message limit reached")
              ) {
                throw new MessageLimitError();
              }
            }
            throw error;
          });

          if (debugTrace) {
            console.log("[Debug] Claude.ai Response:", {
              completion: response.completion,
              responseSize: response.completion.length,
            });
          }

          return {
            success: true,
            text: response.completion,
          };
        } catch (error) {
          console.error("[AnthropicService] claude.ai request failed:", error);
          if (debugTrace) {
            console.log("[Debug] Claude.ai Error:", error);
          }
          // Re-throw MessageLimitError
          if (error instanceof MessageLimitError) {
            throw error;
          }
          return {
            success: false,
            error:
              error instanceof Error
                ? error.message
                : "Failed to make claude.ai request",
          };
        }
      }

      const settings = await SettingsService.validateSettings();
      if (!settings.valid) {
        console.log("[AnthropicService] Invalid settings:", settings.message);
        return {
          success: false,
          error: settings.message,
        };
      }

      const apiKey = await SettingsService.getSetting("anthropicApiKey");
      if (!apiKey) {
        console.log("[AnthropicService] No API key found");
        return {
          success: false,
          error: "API key not found in settings",
        };
      }

      const model = await SettingsService.getSetting("model");
      console.log("[AnthropicService] Using model:", model);

      const requestBody = {
        model,
        messages: options.messages,
        prompt: options.prompt,
        max_tokens: options.maxTokens || 1024,
        temperature: options.temperature,
        top_p: options.topP,
        top_k: options.topK,
      };

      if (debugTrace) {
        console.log("[Debug] API Request:", {
          model,
          messageCount: options.messages?.length || 1,
          requestSize: JSON.stringify(requestBody).length,
          messages: options.messages,
          prompt: options.prompt,
        });
      }

      return new Promise((resolve, reject) => {
        console.log("[AnthropicService] Sending message to background script");

        // Set up abort handler if signal is provided
        if (options.signal) {
          options.signal.addEventListener("abort", () => {
            console.log("[AnthropicService] Request cancelled");
            if (debugTrace) {
              console.log("[Debug] Request cancelled by user");
            }
            resolve({
              success: false,
              cancelled: true,
              error: "Request cancelled",
            });
          });

          // If signal is already aborted, resolve immediately
          if (options.signal.aborted) {
            console.log("[AnthropicService] Signal already aborted");
            if (debugTrace) {
              console.log("[Debug] Request aborted before sending");
            }
            resolve({
              success: false,
              cancelled: true,
              error: "Request cancelled",
            });
            return;
          }
        }

        chrome.runtime.sendMessage(
          {
            type: "anthropic_complete",
            apiKey,
            body: requestBody,
          },
          (response) => {
            // Check if request was cancelled
            if (options.signal?.aborted) {
              console.log("[AnthropicService] Request was cancelled");
              if (debugTrace) {
                console.log("[Debug] Request cancelled during processing");
              }
              resolve({
                success: false,
                cancelled: true,
                error: "Request cancelled",
              });
              return;
            }

            if (chrome.runtime.lastError) {
              console.error(
                "[AnthropicService] Runtime error:",
                chrome.runtime.lastError
              );
              if (debugTrace) {
                console.log("[Debug] Runtime Error:", chrome.runtime.lastError);
              }
              resolve({
                success: false,
                error: chrome.runtime.lastError.message,
              });
              return;
            }

            if (response.error) {
              console.error("[AnthropicService] API error:", response.error);
              if (debugTrace) {
                console.log("[Debug] API Error:", response.error);
              }
              resolve({
                success: false,
                error: response.error,
              });
              return;
            }

            console.log("[AnthropicService] Received successful response");
            if (debugTrace) {
              console.log("[Debug] API Response:", {
                responseSize: JSON.stringify(response).length,
                content: response.content,
                usage: response.usage,
              });
            }
            resolve({
              success: true,
              text: response.content[0]?.text || "",
            });
          }
        );
      });
    } catch (error) {
      console.error("[AnthropicService] Unexpected error:", error);
      if (debugTrace) {
        console.log("[Debug] Unexpected Error:", error);
      }
      // Re-throw MessageLimitError
      if (error instanceof MessageLimitError) {
        throw error;
      }
      return {
        success: false,
        error: "An unexpected error occurred",
      };
    }
  }
}
